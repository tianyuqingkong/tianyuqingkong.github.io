<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2 docker应用</title>
    <url>/2020/05/17/2docker%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>前端同学的想了解的可以看下面的阮老师两篇文章</p>
<h2 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">Docker 微服务教程</a><h2 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h2></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/container/import_export.html">Docker —— 从入门到实践</a> </li>
<li><a href="https://docs.docker.com/">Docker Documentation</a></li>
</ul>
]]></content>
      <categories>
        <category>jenkins docker</category>
      </categories>
  </entry>
  <entry>
    <title>1 jenkins在GVP_doc项目中的实际使用</title>
    <url>/2020/05/16/1jenkins%E5%AE%9E%E4%BE%8B%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="jenkins在项目中的实际使用"><a href="#jenkins在项目中的实际使用" class="headerlink" title="jenkins在项目中的实际使用"></a>jenkins在项目中的实际使用</h2><p>  在项目中有大体来说三种部署方式，第一种通过推送代码到特定分支完成自动部署线上环境加上本地部署环境，第二种是手动一键式部署线上环境，第三种是手动一键式部署本地环境。下面有这三种方式的简单说明。</p>
<span id="more"></span>
<p>  这三种部署方式触发时都可以登录<a href="http://10.201.81.83:8098/">jenkins网站</a>查看其过程情况，目前有一个账号后面会增加。<br>  账号：chenkuan 密码：xxxxxxx</p>
<ul>
<li><p>推送代码自动部署： 当代码推送到master分支时，<code>线上环境</code>和<code>本地部署环境</code>会自动部署如果部署成功或者失败会有邮件发给推送代码的人。部署成功具体表现是线上环境的网站内容发生了变化，已经本地部署环境的gitlab库tar包发生了替换。下面是注意事项。</p>
<ul>
<li><p>如果只想部署一个环境可以在下图对应代码注释，如下面就是注释了自动本地部署。<br><img src="/2020/05/16/1jenkins%E5%AE%9E%E4%BE%8B%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/choice.png" alt="choice">  </p>
</li>
<li><p>代码推送特定分支发生自动部署， 这个特定分支是可以配置的目前是配置的master，如果想改变有下面步骤：<br>  登录到jenkins网站 -&gt; auto_online_deploy -&gt;auto_online_GVPdocs -&gt; Configure -&gt; Buid Triggers -&gt; Advanced -&gt; Allowed branches -&gt; Filter branches by name -&gt; Include<br>  <img src="/2020/05/16/1jenkins%E5%AE%9E%E4%BE%8B%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/config.png" alt="config"></p>
</li>
</ul>
</li>
<li><p>手动一键式部署线上环境，这个是一键点击完成将特定分支的代码（目前设置是master）部署到线上环境，点击完毕后看下面的job跑完就是发布成功。部署成功具体表现是线上环境的网站内容发生了变化。这里需要注意的是要有两个步骤一个是确认发布的分支是否是你想要发布的分支，另一个就是点击按钮。  </p>
<ul>
<li><p>确认分支<br>登录到jenkins网站 -&gt; manual_online_deploy -&gt; manual_online_GVPdocs -&gt; Configure -&gt; Source Code Management -&gt; Branches to build<br><img src="/2020/05/16/1jenkins%E5%AE%9E%E4%BE%8B%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/vertifyConfig.png" alt="vertifyConfig">  </p>
</li>
<li><p>点击立即构建<br>登录到jenkins网站 -&gt; manual_online_deploy -&gt; manual_online_GVPdocs -&gt; 点击立即构建<br><img src="/2020/05/16/1jenkins%E5%AE%9E%E4%BE%8B%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/trigger.png" alt="trigger"></p>
</li>
</ul>
</li>
<li><p>手动一键式本地部署，和上面的手动一键式部署线上环境只是名字的不同由manual_online_GVPdocs变为manual_local_GVP_docs</p>
</li>
</ul>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
  </entry>
  <entry>
    <title>3 jenkins多环境多项目发布简明</title>
    <url>/2020/05/19/3jenkins%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E7%AE%80%E6%98%8E/</url>
    <content><![CDATA[<h2 id="GVP-frond-web例子"><a href="#GVP-frond-web例子" class="headerlink" title="GVP_frond_web例子"></a>GVP_frond_web例子</h2><h3 id="（1）自动发布：代码推送到特定分支后自动发布一个环境"><a href="#（1）自动发布：代码推送到特定分支后自动发布一个环境" class="headerlink" title="（1）自动发布：代码推送到特定分支后自动发布一个环境"></a>（1）自动发布：代码推送到特定分支后自动发布一个环境</h3><span id="more"></span>
<ul>
<li><p>当代码推送到特定指定分支后，web前端项目将会自动进行线上某个指定环境的发布 </p>
</li>
<li><p>上面说的指定内容都是在项目顶级目录的cicd文件下进行配置的，具体是cicd&#x2F;envConfig.json里面<br><img src="/2020/05/19/3jenkins%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E7%AE%80%E6%98%8E/envConfig.png" alt="envConfig"><br>在上面文件中有两个分支分别是feature&#x2F;cicd以及feature&#x2F;cicdAlpha他们分别对应着两个不同环境dev和alpha，当任何代码向这两个分支推送时两个环境就会发生自动部署。  </p>
</li>
<li><p>上面的两个分支其实还需要在jenkins进行配置以便这两个分支发生变化，进而触发jinkins流程<br><img src="/2020/05/19/3jenkins%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E7%AE%80%E6%98%8E/jenkinsConfig.png" alt="envConfig"></p>
</li>
</ul>
<h3 id="2-手动发布：登录到jenkins网站后手动一键发布"><a href="#2-手动发布：登录到jenkins网站后手动一键发布" class="headerlink" title="(2)手动发布：登录到jenkins网站后手动一键发布"></a>(2)手动发布：登录到jenkins网站后手动一键发布</h3><ul>
<li><p>首先登录到jenkins网站 账号： chenkuan  密码：wearetheone11<br><img src="/2020/05/19/3jenkins%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E7%AE%80%E6%98%8E/loginJenkins.png" alt="loginJenkins"></p>
</li>
<li><p>找到想发布项目点击进入，下图找到的是web前端的dev环境<br><img src="/2020/05/19/3jenkins%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E7%AE%80%E6%98%8E/findJob.png" alt="findJob"></p>
</li>
<li><p>点击左边Configure确认是自己想要发布的分支，或者修改配置分支<br><img src="/2020/05/19/3jenkins%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E7%AE%80%E6%98%8E/ensureBranch.jpg" alt="ensureBranchfindJob"></p>
</li>
<li><p>确认后回到上级页面点击立即构建按钮,进行一键自动发布<br><img src="/2020/05/19/3jenkins%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E7%AE%80%E6%98%8E/trigger.png" alt="trigger"></p>
</li>
</ul>
<h3 id="（3）总结：核心理念是一个分支对应着一个环境，并且这些分支是可以配置的"><a href="#（3）总结：核心理念是一个分支对应着一个环境，并且这些分支是可以配置的" class="headerlink" title="（3）总结：核心理念是一个分支对应着一个环境，并且这些分支是可以配置的"></a>（3）总结：核心理念是一个分支对应着一个环境，并且这些分支是可以配置的</h3>]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
  </entry>
  <entry>
    <title>0 安装和配置jenkins</title>
    <url>/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/</url>
    <content><![CDATA[<h2 id="jenkins在linux的安装与配置（10-201-81-83）：-注意如果不想了解全部步骤可以直接跳到第七步"><a href="#jenkins在linux的安装与配置（10-201-81-83）：-注意如果不想了解全部步骤可以直接跳到第七步" class="headerlink" title="jenkins在linux的安装与配置（10.201.81.83）： 注意如果不想了解全部步骤可以直接跳到第七步"></a>jenkins在linux的安装与配置（10.201.81.83）： 注意如果不想了解全部步骤可以直接跳到第七步</h2><ul>
<li><p>1 确认该机器已经安装jdk：jenkins是java开发的工业级cicd工具</p>
<ul>
<li>java -version, 注意：有些版本的jenkins不能使用1.6的jdk</li>
</ul>
</li>
<li><p>2 在线安装</p>
<ul>
<li>sudo wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo <a href="http://jenkins-ci.org/redhat/jenkins.repo">http://jenkins-ci.org/redhat/jenkins.repo</a>  </li>
<li>sudo rpm –import <a href="http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key">http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key</a> </li>
<li>sudo yum install jenkins</li>
<li>sudo service jenkins start</li>
<li>sudo service jenkins status</li>
</ul>
</li>
</ul>
<span id="more"></span>  

<ul>
<li><p>3 修改端口配置：因为jenkins的默认端口为8080，这个端口在服务器大多数都被占用，这里改为8089(可以为其他没有占用的端口)</p>
<ul>
<li>sudo vim &#x2F;etc&#x2F;sysconfig&#x2F;jenkins &#x2F;&#x2F;修改JENKINS_PORT&#x3D;”8089”</li>
<li>sudo service jenkins restart &#x2F;&#x2F; 重启服务更新配置</li>
</ul>
</li>
<li><p>4 修改jenkins在linux中的角色：jenkine默认角色为jenkins，在linux中权限比较严格，这里设置为root比较方便如后来配置git的免密就比较方便了</p>
<ul>
<li>sudo vim &#x2F;etc&#x2F;sysconfig&#x2F;jenkins &#x2F;&#x2F;修改JENKINS_USER&#x3D;”root”</li>
<li>sudo service jenkins restart &#x2F;&#x2F; 重启服务更新配置</li>
</ul>
</li>
<li><p>5 jenkins初始化</p>
<ul>
<li>进入 <a href="http://10.201.81.83:8098/">http://10.201.81.83:8098/</a> 根据提示初始化密码，以及安装一些默认的插件。完后遇到一个空白页。</li>
<li>进入<a href="http://10.201.81.83:8098/restart%EF%BC%8C%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E9%87%8D%E5%90%AFjenkins%EF%BC%8C%E8%BF%9B%E5%85%A5%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2">http://10.201.81.83:8098/restart，点击页面上的重启jenkins，进入登录界面</a></li>
</ul>
</li>
<li><p>6 jenkins与git的ssh免密配置：一般jenkins需要从git自动拉取代码需要提前加上免密机制，下面的流程需要这个配置（有兴趣的可以googel下ssh）</p>
<ul>
<li><p>一般linux中有git(如果没有自行安装),找到git安装的路径并且配置在jenkins中这样jenkins就可以使用git命令，默认git安装路径为&#x2F;usr&#x2F;libexec&#x2F;git-core&#x2F;git</p>
</li>
<li><p>jenkins-&gt; 系统管理 -&gt; 全局工具配置 -&gt; 下图 -&gt; 保存<br><img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/gitInJenkinsConfig.png" alt="gitInJenkinsConfig" title="rrr"></p>
</li>
<li><p>sudo su :进入服务器切换为root用户 (上面第步4中jenkins角色配置为root，这里免密就是使用root用户)</p>
</li>
<li><p>cd ~&#x2F;.ssh : 进入根目录的.ssh文件夹(如果不存在这个文件夹或者文件夹里面没有东西证明root用户没有加ssh，可以使用ssh-keygen -t rsa 生成)</p>
</li>
<li><p>cat id_rsa.pub ： 将输出的公钥复制（下图）<br><img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/pubKey.png" alt="pubKey"></p>
</li>
<li><p>将复制公钥添加到git用户的ssh中：userLogo -&gt; Settings -&gt; SSH Keys -&gt; Key -&gt; add Keysc(这样配置后jenkins中git的权限就是当前你配置gitlab用户所拥有的权限，如拉取某个项目的权限)<br> <img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/gitKeys.png" alt="gitKeys"></p>
</li>
<li><p>以管理员身份进入jinkins网站(<a href="http://10.201.81.83:8098/):%E8%BF%99%E9%87%8C%E5%BF%85%E9%A1%BB%E4%B8%BA%E7%AE%A1%E7%90%86%E5%91%98%E4%B8%8D%E7%84%B6%E6%97%A0%E6%B3%95%E6%B7%BB%E5%8A%A0%E5%87%AD%E8%AF%81">http://10.201.81.83:8098/):这里必须为管理员不然无法添加凭证</a></p>
</li>
<li><p>凭证 -&gt; 系统 -&gt; 添加域 —&gt; 填写域名（这里随便填写）<br><img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/credentials.png" alt="credentials"></p>
</li>
<li><p>添加凭证<br><img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/addCredential.png" alt="addCredential"></p>
</li>
<li><p>复制linux中root用户的私钥 (和前面一样 sudo cd ~&#x2F;.ssh  cat id_rsa)<br> <img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/priKey.png" alt="priKey"></p>
</li>
<li><p>将刚刚复制的私钥填写到图中对应位置：注意选择类型的时候选择ssh<br><img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/addPrikey.png" alt="addPrikey"></p>
</li>
</ul>
</li>
<li><p>7 jenkin 流程构建：这个步骤是大部分人jenkins用户都要关注的部分，其他上面6个步骤只要jenkin管理员关注，或者想自己搭建一个自己jenkin的同学可以了解</p>
<ul>
<li><p>首先通过一个账户登录到jenkins网站<br><img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/login.png" alt="login"></p>
</li>
<li><p>New任务 -&gt; 选择流水线<br> <img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/addSCM.png" alt="addSCM"></p>
</li>
<li><p>配置流水线<br><img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/configSCM.png" alt="configSCM"></p>
<ul>
<li>1：这里主要关注Pipeline,其他都是可选项</li>
<li>2： 选择Definition，这里我们选择Pipeline script from SCM意思就是利用项目中的Jenkinfile来执行cicd。</li>
<li>3： 选择拉取代码的方式，这里选择git</li>
<li>4： 填写产库地址,注意这里填写仓库地址的形式是亦git@开头的也就是以ssh协议连接的，当然如果想要每次填写用户名和密码也可以是使用http协议</li>
<li>5： 填写Credentials，这里是上面第6部添加凭证后才有的结果，如果上面添加凭证的用户没有这个仓库的权限，这里会报错</li>
<li>6：这里指定cicd执行执行的分支，换句话说这个分支上必须要有Jenkins相关配置文件，在我们这里这个文件就指的是下面的Jenkinsfile</li>
<li>7:这里就是配置Jenkinsfile的路径和文件名了，这里的话只填写了Jenkinsfile，所以cicd的脚本都在项目顶级目录的Jenkinsfile。如果你不想你的cicd命令放在顶级目录这里就可以做修改</li>
<li>8:最后保存</li>
</ul>
</li>
</ul>
</li>
<li><p>8 使用jenkins执行cicd</p>
<ul>
<li>在项目相应的目录添加相应的cicd脚本文件，在第7部我们指定了在项目的顶级目录的Jenkinfile文件写cicd脚本文件 （如何写脚本在下一篇文章中有）<br><img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/jenkinsfileDic.png" alt="jenkinsfileDic"></li>
<li>通过用户名和密码登录到<a href="http://10.201.81.83:8098/%EF%BC%8C%E8%BF%9B%E5%85%A5%E7%9B%B8%E5%BA%94%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E7%82%B9%E5%87%BB%E7%AB%8B%E5%8D%B3%E6%9E%84%E5%BB%BA%E5%B0%B1%E4%BC%9A%E6%89%A7%E8%A1%8C%E9%A1%B9%E7%9B%AE%E4%B8%ADJenkinfile%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%84%9A%E6%9C%AC">http://10.201.81.83:8098/，进入相应的项目中，点击立即构建就会执行项目中Jenkinfile文件中的脚本</a> (其实触发jenkins触发的方式由很多种，这里是采用手动触发)<br><img src="/2020/05/15/0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjenkins/activeProject.png" alt="activeProject"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>jenkins linux</category>
      </categories>
  </entry>
  <entry>
    <title>unicode</title>
    <url>/2017/11/24/Nuicode/</url>
    <content><![CDATA[<h2 id="Unicode的作用"><a href="#Unicode的作用" class="headerlink" title="Unicode的作用"></a>Unicode的作用</h2><p>  Unicode是一个世界通用的字符集，它定义了全世界大部分书写体系的字符集，并为每一个字符分配了一个独一无二的数字（代码点）。</p>
<span id="more"></span>
<h2 id="Unicode基本概念"><a href="#Unicode基本概念" class="headerlink" title="Unicode基本概念"></a>Unicode基本概念</h2><h3 id="字符（characters）与代码点-code-points"><a href="#字符（characters）与代码点-code-points" class="headerlink" title="字符（characters）与代码点(code points)"></a>字符（characters）与代码点(code points)</h3><pre><code>* Unicode中的字符是一个抽象概念。每一个抽象字符都有一个对应的名称，例如LATIN SMALL LETTER A。该抽象字符的图像表现形式（glyph）是a。
* 代码点是指被分配给某个抽象字符的数字：代码点以U+&lt;hex&gt;的形式表示，U+是代表Unicode的前缀，而&lt;hex&gt;是一个16进制数。例如U+0041和U+2603都是代码点。代码点的取值范围是从U+0000到U+10FFFF。
note： 并非所有的代码点都有对应的抽象字符，可用的代码点有1114112个，但分配了抽象字符的只有128237个。
</code></pre>
<h3 id="Unicode平面"><a href="#Unicode平面" class="headerlink" title="Unicode平面"></a>Unicode平面</h3><p>平面是指从U+n0000到U+nFFFF的区间，每个区间相隔65536(0x10000),其中的n可以从0x0取到0x10</p>
<pre><code>* 平面0包含从U+0000到U+FFFF的代码点
* 平面1包含从U+10000到U+1FFFF的代码点
* 平面16包含从U+100000到U+10FFFF的代码点
</code></pre>
<p><img src="/Unicode/Unicode-planes.png" alt="uncode_planes"></p>
<p>平面0比较特殊，被称为基本多文种平面或简称BMP。它包含了大多数现代语言的字符 (基本拉丁字母, 西里尔字母, 希腊字母等)和大量的符号  </p>
<pre><code>*  e对应代码点U+0065 抽象字符名： LATIN SMALL LETTER E
*  |对应代码点U+007C 抽象字符名： VERTICAL BAR
*  ■对应代码点U+25A0 抽象字符名： BLACK SQUARE
*  ☂对应代码点U+2602 抽象字符名： UMBRELLA
</code></pre>
<p>BMP之后的16个平面（平面1，平面2，…，平面16）被称为星光平面或辅助平面。星光平面的代码点被称为星光代码点。这些代码点的取值范围是从U+10000到U+10FFFF。</p>
<h3 id="码元-code-units"><a href="#码元-code-units" class="headerlink" title="码元(code units)"></a>码元(code units)</h3><p>码元是指使用某种给定的编码规则给字符编码后得到的比特序列。</p>
<p>字符编码将抽象层面的码点转换为物理层面的比特序列：码元。</p>
<p>常用的字符编码有UTF-8, UTF-16 和 UTF-32.</p>
<p>大多数JavaScript引擎使用UTF-16编码字符。它会影响JavaScript处理Unicode的方式。  </p>
<ul>
<li>BMP中的码点编码为单个16位的码元</li>
<li>星光平面的码点编码为两个16位的码元<br>BMP中的代码点刚好能存进一个16位的码元。编码BMP可谓小菜一碟。</li>
</ul>
<h3 id="代理对-surrogate-pairs"><a href="#代理对-surrogate-pairs" class="headerlink" title="代理对(surrogate pairs)"></a>代理对(surrogate pairs)</h3><p>存储一个星光代码点（属于星光平面）： GRINNING FACE character 。该字符对应的代码点是 U+1F600。UTF-16需要两个码元来编码，每个16比特。代码点 U+1F600 被拆分为所谓的代理对：0xD83D（高位代理码元）与 0xDE00（低位代理码元）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;\uD83D\uDE00&#x27;);</span><br></pre></td></tr></table></figure>
<p>代理对与码点之间互相转换的算法如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getSurrogatePair(astralCodePoint) &#123;  </span><br><span class="line">  let highSurrogate = </span><br><span class="line">     Math.floor((astralCodePoint - 0x10000) / 0x400) + 0xD800;</span><br><span class="line">  let lowSurrogate = (astralCodePoint - 0x10000) % 0x400 + 0xDC00;</span><br><span class="line">  return [highSurrogate, lowSurrogate];</span><br><span class="line">&#125;</span><br><span class="line">getSurrogatePair(0x1F600); // =&gt; [0xDC00, 0xDFFF]</span><br><span class="line"></span><br><span class="line">function getAstralCodePoint(highSurrogate, lowSurrogate) &#123;  </span><br><span class="line">  return (highSurrogate - 0xD800) * 0x400 </span><br><span class="line">      + lowSurrogate - 0xDC00 + 0x10000;</span><br><span class="line">&#125;</span><br><span class="line">getAstralCodePoint(0xD83D, 0xDE00); // =&gt; 0x1F600</span><br></pre></td></tr></table></figure>

<h3 id="组合用字符-combining-marks"><a href="#组合用字符-combining-marks" class="headerlink" title="组合用字符(combining marks)"></a>组合用字符(combining marks)</h3><p>字素就是用户所认为的一个字符。屏幕上所展示的一个有形的字素称为图像字符（glyph）。</p>
<p>在大多数情况下，一个Unicode字符就代表一个字素。例如 U+0066 LATIN SMALL LETTER F就是一个英文字母f。</p>
<p>但有时候一个字素会包含一系列字符。</p>
<p>例如å在丹麦语书写系统中是一个不可再分的字素。但它是用U+0061 LATIN SMALL LETTER A (渲染为a) 结合一个特殊字符U+030A COMBINING RING ABOVE（渲染为◌̊）来显示的。</p>
<p>U+030A用来修饰前一个字符，这种字符称为组合用字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;\u0061\u030A&#x27;); // =&gt; &#x27;å&#x27;  </span><br><span class="line">console.log(&#x27;\u0061&#x27;);       // =&gt; &#x27;a&#x27;</span><br></pre></td></tr></table></figure>
<p>在用户看来一个组合字符序列（基础字符+组合用字符）是”一”个符号（例如’\u0061\u030A’就是’å’）。但开发者必须清楚实际上要用到两个代码点U+0061和U+030A来生成å。<br><img src="/Unicode/terms.png" alt="terms"></p>
<h2 id="javascript-中的Unicode"><a href="#javascript-中的Unicode" class="headerlink" title="javascript 中的Unicode"></a>javascript 中的Unicode</h2><p>一般源码的存储和交换通常使用UTF-8(web通常编码形式),string类型(字符串)是由16比特无符号整数值(“元素”)组成的集合，每个在字符串的元素被当做UTF-16码元，而字符串的长度就是码元的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let smile = &#x27;\uD83D\uDE00&#x27;;  </span><br><span class="line">console.log(smile);        // =&gt; &#x27;😀&#x27;  </span><br><span class="line">console.log(smile.length); // =&gt; 2</span><br><span class="line"></span><br><span class="line">let letter = &#x27;e\u0301&#x27;;  </span><br><span class="line">console.log(letter);        // =&gt; &#x27;é&#x27;  </span><br><span class="line">console.log(letter.length); // =&gt; 2  </span><br></pre></td></tr></table></figure>
<p>始终将JavaScript中的字符串视为一串码元序列。字符串渲染的结果并不能清晰地表明它包含了怎样的码元。</p>
<p>大多数JavaScript字符串方法都不能 智能识别Unicode 。如果字符串含有混合的Unicode字符，在调用myString.slice()、myString.substring()等方法时就要小心了。</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>在js字符串中转义序列通常是将码点转为码元，一共有三种方式</p>
<h4 id="16进制转义序列-Hexadecimal-escape-sequence-：-x-x为前缀，后面跟一个2位的16进制数"><a href="#16进制转义序列-Hexadecimal-escape-sequence-：-x-x为前缀，后面跟一个2位的16进制数" class="headerlink" title="16进制转义序列(Hexadecimal escape sequence)：\x. \x为前缀，后面跟一个2位的16进制数"></a>16进制转义序列(Hexadecimal escape sequence)：\x<hex>. \x为前缀，后面跟一个2位的16进制数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;\x4A\x61vaScript&#x27;;  </span><br><span class="line">console.log(str);                    // =&gt; &#x27;JavaScript&#x27;  </span><br><span class="line">var reg = /\x4A\x61va.*/;  </span><br><span class="line">console.log(reg.test(&#x27;JavaScript&#x27;)); // =&gt; true </span><br></pre></td></tr></table></figure>
<p>6进制转义序列只能编码从U+00到U+FF的有限数量的代码点，因为它只能有2位数字。但16进制转义序列的好处是它很短。</p>
<h4 id="Unicode转义序列-Unicode-escape-sequence-：你想转义整个BMP中的代码点，转义形式是-u-u为前缀，后面跟一个4位的16进制数。"><a href="#Unicode转义序列-Unicode-escape-sequence-：你想转义整个BMP中的代码点，转义形式是-u-u为前缀，后面跟一个4位的16进制数。" class="headerlink" title="Unicode转义序列(Unicode escape sequence)：你想转义整个BMP中的代码点，转义形式是\u,\u为前缀，后面跟一个4位的16进制数。"></a>Unicode转义序列(Unicode escape sequence)：你想转义整个BMP中的代码点，转义形式是\u<hex>,\u为前缀，后面跟一个4位的16进制数。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;I\u0020learn \u0055nicode&#x27;;  </span><br><span class="line">console.log(str);                 // =&gt; &#x27;I learn Unicode&#x27;  </span><br><span class="line">var reg = /\u0055ni.*/;  </span><br><span class="line">console.log(reg.test(&#x27;Unicode&#x27;)); // =&gt; true</span><br></pre></td></tr></table></figure>
<p>想要在JavaScript文本中表示星光字符，可以用两个连续的Unicode转义序列（高位代理与低位代理），生成代理对：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;My face \uD83D\uDE00&#x27;;  </span><br><span class="line">console.log(str); // =&gt; &#x27;My face 😀&#x27;  </span><br></pre></td></tr></table></figure>

<h4 id="码点转义序列-Code-point-escape-sequence-：-ECMAScript-2015提供了能够表示整个Unicode空间：从U-0000到U-10FFFF，也就是BMP与星光平面的转义序列。-u-，是一个长度为1至6位的16进制数。"><a href="#码点转义序列-Code-point-escape-sequence-：-ECMAScript-2015提供了能够表示整个Unicode空间：从U-0000到U-10FFFF，也就是BMP与星光平面的转义序列。-u-，是一个长度为1至6位的16进制数。" class="headerlink" title="码点转义序列(Code point escape sequence)： ECMAScript 2015提供了能够表示整个Unicode空间：从U+0000到U+10FFFF，也就是BMP与星光平面的转义序列。\u{}，是一个长度为1至6位的16进制数。"></a>码点转义序列(Code point escape sequence)： ECMAScript 2015提供了能够表示整个Unicode空间：从U+0000到U+10FFFF，也就是BMP与星光平面的转义序列。\u{<hex>}，<hex>是一个长度为1至6位的16进制数。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;Funny cat \u&#123;1F639&#125;&#x27;;  </span><br><span class="line">console.log(str);                      // =&gt; &#x27;Funny cat 😹&#x27;  </span><br><span class="line">var reg = /\u&#123;1F639&#125;/u;  </span><br><span class="line">console.log(reg.test(&#x27;Funny cat 😹&#x27;)); // =&gt; true  </span><br></pre></td></tr></table></figure>
<p><img src="/Unicode/EscapeSequences.png" alt="escapeSequences"></p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>JavaScript中的字符串是码元的序列。因此字符串的比较可以看作是码元的计算与匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var firstStr = &#x27;hello&#x27;;  </span><br><span class="line">var secondStr = &#x27;\u0068ell\u006F&#x27;;  </span><br><span class="line">console.log(firstStr === secondStr); // =&gt; true</span><br></pre></td></tr></table></figure>

<p>假设你想比较两个渲染结果相同，但包含不同码元序列的字符串。因为看上去相同的字符串经过比较却不相等.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str1 = &#x27;ça va bien&#x27;;  </span><br><span class="line">var str2 = &#x27;c\u0327a va bien&#x27;;  </span><br><span class="line">console.log(str1);          // =&gt; &#x27;ça va bien&#x27;  </span><br><span class="line">console.log(str2);          // =&gt; &#x27;ça va bien&#x27;  </span><br><span class="line">console.log(str1 === str2); // =&gt; false</span><br></pre></td></tr></table></figure>
<p>str1和str2渲染结果看起来相同，但包含不同的码元。</p>
<p>因为字素ç可以通过两种方法生成：</p>
<ul>
<li>使用U+00E7 LATIN SMALL LETTER C WITH CEDILLA</li>
<li>或者用组合字符序列：U+0063 LATIN SMALL LETTER C 加上组合用字符U+0327 COMBINING CEDILLA.</li>
</ul>
<h3 id="标准化：标准化是指将字符串转换为统一的表示形式，以保证具有标准等价性（或兼容等价性）的字符串只有一种表示形式。"><a href="#标准化：标准化是指将字符串转换为统一的表示形式，以保证具有标准等价性（或兼容等价性）的字符串只有一种表示形式。" class="headerlink" title="标准化：标准化是指将字符串转换为统一的表示形式，以保证具有标准等价性（或兼容等价性）的字符串只有一种表示形式。"></a>标准化：标准化是指将字符串转换为统一的表示形式，以保证具有标准等价性（或兼容等价性）的字符串只有一种表示形式。</h3><p>在JavaScript中对字符串进行标准化需要调用ES2015提供的myString.normalize([normForm])方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str1 = &#x27;ça va bien&#x27;;  </span><br><span class="line">var str2 = &#x27;c\u0327a va bien&#x27;;  </span><br><span class="line">console.log(str1 === str2.normalize()); // =&gt; true  </span><br><span class="line">console.log(str1 === str2);             // =&gt; false</span><br></pre></td></tr></table></figure>
<p>‘ç’与’c\u0327’具有标准等价性。<br>调用str2.normalize()，会返回一个str2 的标准形式副本（’c\u0327’替换为’ç’）。因此比较语句str1 &#x3D;&#x3D;&#x3D; str2.normalize()会如预期一般返回true.<br>但为了使操作符两端都取得标准化字符串，将待比较的2个字符串都标准化也是合理的。</p>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;cat\u&#123;1F639&#125;&#x27;;  </span><br><span class="line">console.log(str);        // =&gt; &#x27;cat😹&#x27;  </span><br><span class="line">console.log(str.length); // =&gt; 5  </span><br></pre></td></tr></table></figure>
<p>然而smile.length等于5，因为U+1F639是一个星光代码点，它被编码成了2个码元（一个代理对）。<br>ECMAScript 2015引入了一种能够识别星光字符的算法。星光字符即使被编译为2个码元，也会被计算为一个字符。<br>这个能够识别Unicode的利器就是字符迭代器String.prototype<a href="">@@iterator</a>。你可以给字符串加上扩展操作符[…str]或Array.from(str)函数（两者都会调用字符串迭代器）。然后再计算返回数组中的字符个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;cat\u&#123;1F639&#125;&#x27;;  </span><br><span class="line">console.log(str);             // =&gt; &#x27;cat?&#x27;  </span><br><span class="line">console.log([...str]);        // =&gt; [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;?&#x27;]  </span><br><span class="line">console.log([...str].length); // =&gt; 4</span><br></pre></td></tr></table></figure>
<p>那么组合字符序列呢？由于每个组合用字符都是一个码元，因此你会遇到同样的困难。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var drink = &#x27;cafe\u0327\u0301&#x27;;  </span><br><span class="line">console.log(drink);                    // =&gt; &#x27;cafȩ́&#x27;  </span><br><span class="line">console.log(drink.length);             // =&gt; 6  </span><br><span class="line">console.log(drink.normalize());        // =&gt; &#x27;cafȩ́&#x27;  </span><br><span class="line">console.log(drink.normalize().length); // =&gt; 5</span><br></pre></td></tr></table></figure>
<p>于是我们很难过地发现drink.normalize().length的值为5，仍然不能正确地计算字符的个数。</p>
<h3 id="字符定位"><a href="#字符定位" class="headerlink" title="字符定位"></a>字符定位</h3><p>由于字符串是码元的序列，通过字符串索引来访问字符同样会有困难。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var omega = &#x27;\u&#123;1D6C0&#125; is omega&#x27;;  </span><br><span class="line">console.log(omega);        // =&gt; &#x27;𝛀 is omega&#x27;  </span><br><span class="line">console.log(omega[0]);     // =&gt; &#x27;&#x27; (unprintable symbol)  </span><br><span class="line">console.log(omega[1]);     // =&gt; &#x27;&#x27; (unprintable symbol)  </span><br></pre></td></tr></table></figure>

<p>想要正确地访问字符串中星光字符，有2种方法：</p>
<ul>
<li>使用能够识别Unicode的字符串迭代器生成一个字符数组[…str][index]</li>
<li>用number &#x3D; myString.codePointAt(index)获取代码点，然后用String.fromCodePoint(number)将代码点转换为字符（推荐方法）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var omega = &#x27;\u&#123;1D6C0&#125; is omega&#x27;;  </span><br><span class="line">console.log(omega);                        // =&gt; &#x27;𝛀 is omega&#x27;  </span><br><span class="line">// Option 1</span><br><span class="line">console.log([...omega][0]);                // =&gt; &#x27;𝛀&#x27;  </span><br><span class="line">// Option 2</span><br><span class="line">var number = omega.codePointAt(0);  </span><br><span class="line">console.log(number.toString(16));          // =&gt; &#x27;1d6c0&#x27;  </span><br><span class="line">console.log(String.fromCodePoint(number)); // =&gt; &#x27;𝛀&#x27;  </span><br></pre></td></tr></table></figure>
<p>函数omega.codePointAt(0)能够识别Unicode，因此它返回了字符串omega第一个字符的星光代码点数字0x1D6C0。函数String.fromCodePoint(number)则返回了这个代码点对应的字符：’𝛀’.</p>
<p>字符定位在遇到组合用字符时会出现和上面一样的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var drink = &#x27;cafe\u0301&#x27;;  </span><br><span class="line">console.log(drink.normalize());        // =&gt; &#x27;café&#x27;  </span><br><span class="line">console.log(drink.normalize().length); // =&gt; 4  </span><br><span class="line">console.log(drink.normalize()[3]);     // =&gt; &#x27;é&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><p>正则表达式与字符串一样，是基于码元工作的。因此与上文描述的情形相似，使用正则表达式在处理代理对和组合字符序列时也会遇到困难。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var smile = &#x27;😀&#x27;;  </span><br><span class="line">var regex = /^.$/;  </span><br><span class="line">console.log(regex.test(smile)); // =&gt; false  </span><br></pre></td></tr></table></figure>
<p>smile包含星光字符U+1F600 GRINNING FACE。U+1F600被编码为一个代理对0xD83D 0xDE00。</p>
<p>然而正则表达式&#x2F;^.$&#x2F;期望的是1个码元，于是正则匹配regexp.test(smile)失败了。</p>
<p>在定义字符区间的时候情况会更糟。JavaScript直接报错了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var regex = /[😀-😎]/;  </span><br><span class="line">// =&gt; SyntaxError: Invalid regular expression: /[😀-😎]/: </span><br><span class="line">// Range out of order in character class</span><br></pre></td></tr></table></figure>
<p>星光代码点会被编码为代理对，因此JavaScript会用码元&#x2F;[\uD83D\uDE00-\uD83D\uDE0E]&#x2F;来表示这个正则表达式。而在pattern中每个码元被视为一个单独的元素，所以正则表达式会忽略代理对这个概念。</p>
<p>好在ECMAScript 2015引入了u标志，使得正则表达式能够识别Unicode。这个标志让我们能够正确处理星光字符。</p>
<p>在正则表达式中可以使用Unicode转义序列&#x2F;u{1F600}&#x2F;u。这样比写高位代理和低位代理&#x2F;\uD83D\uDE00&#x2F;要短。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var smile = &#x27;😀&#x27;;  </span><br><span class="line">var regex = /^.$/u;  </span><br><span class="line">console.log(regex.test(smile)); // =&gt; true  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var smile = &#x27;😀&#x27;;  </span><br><span class="line">var regex = /[😀-😎]/u;  </span><br><span class="line">var regexEscape = /[\u&#123;1F600&#125;-\u&#123;1F60E&#125;]/u;  </span><br><span class="line">var regexSpEscape = /[\uD83D\uDE00-\uD83D\uDE0E]/u;  </span><br><span class="line">console.log(regex.test(smile));         // =&gt; true  </span><br><span class="line">console.log(regexEscape.test(smile));   // =&gt; true  </span><br><span class="line">console.log(regexSpEscape.test(smile)); // =&gt; true  </span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>也许在JavaScript中有关Unicode的最重要的概念就是将字符串视为码元序列，事实也确实如此。</p>
<p>如果开发者认为字符串是由字素（或字符）组成，忽略码元序列这个概念，就会感到困惑。</p>
]]></content>
      <categories>
        <category>编码</category>
      </categories>
  </entry>
  <entry>
    <title>使用Async/Await优化Promise</title>
    <url>/2017/10/17/Async_Await/</url>
    <content><![CDATA[<p>（本来想吐槽下去年才熟练使用Promise但是又要用async-await，但是async-await炒鸡好用，默默流泪）</p>
<h3 id="Async-x2F-Await与Promise的关系"><a href="#Async-x2F-Await与Promise的关系" class="headerlink" title="Async&#x2F;Await与Promise的关系"></a>Async&#x2F;Await与Promise的关系</h3><p>  async-await是promise和generator的语法糖，意在优化promise的写法，简单的说async-await是用来简化pormise写法的，并不是取代关系。</p>
<h3 id="Async-x2F-Await基本语法"><a href="#Async-x2F-Await基本语法" class="headerlink" title="Async&#x2F;Await基本语法"></a>Async&#x2F;Await基本语法</h3><p>  Async放在function关键字前面，await放在Async关键字的函数里，并且最终返回一个promise对象。如下代码所示：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function asyncAwaitDemo()&#123;</span><br><span class="line">    const result = await new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            resolve(&#x27;test&#x27;)</span><br><span class="line">        &#125;,200)</span><br><span class="line">    &#125;)</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">asyncAwaitDemo().then((r)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;result:&#x27;,r);</span><br><span class="line">&#125;)</span><br><span class="line">// result: test</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>


<p>  需要注意的是await只能放在async关键声明的函数里（这点和yield与*的关系一致）<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 正常 for 循环</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    let arr = [1, 2, 3, 4, 5];</span><br><span class="line">    for (let i = 0, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class="line">        await arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">demo();//正常输出</span><br><span class="line">//如果for循环写成下面这样</span><br><span class="line">async function bugDemo() &#123;</span><br><span class="line">    let arr = [1, 2, 3, 4, 5];</span><br><span class="line">    arr.forEach(item =&gt; &#123;</span><br><span class="line">        await item;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">bugDemo();// Uncaught SyntaxError: Unexpected identifier</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h3><p>  这里写一个简单模拟异步api<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  class Api &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.user = &#123; id: 1, name: &#x27;test&#x27; &#125;</span><br><span class="line">    this.friends = [ this.user, this.user, this.user ]</span><br><span class="line">    this.photo = &#x27;not a real photo&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  getUser () &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; resolve(this.user), 200)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  getFriends (userId) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; resolve(this.friends.slice()), 200)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  getPhoto (userId) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; resolve(this.photo), 200)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  throwError () &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; reject(new Error(&#x27;Intentional Error&#x27;)), 200)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="需求1：获得用户信息"><a href="#需求1：获得用户信息" class="headerlink" title="需求1：获得用户信息"></a>需求1：获得用户信息</h4><p>  promise链写法<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  function promiseChain () &#123;</span><br><span class="line">  const api = new Api()</span><br><span class="line">  let user, friends</span><br><span class="line">  api.getUser()</span><br><span class="line">    .then((returnedUser) =&gt; &#123;</span><br><span class="line">      user = returnedUser</span><br><span class="line">      return api.getFriends(user.id)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then((returnedFriends) =&gt; &#123;</span><br><span class="line">      friends = returnedFriends</span><br><span class="line">      return api.getPhoto(user.id)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then((photo) =&gt; &#123;</span><br><span class="line">      console.log(&#x27;promiseChain&#x27;, &#123; user, friends, photo &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Async&#x2F;Await写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function asyncAwaitIsYourNewBestFriend () &#123;</span><br><span class="line">  const api = new Api()</span><br><span class="line">  const user = await api.getUser()</span><br><span class="line">  const friends = await api.getFriends(user.id)</span><br><span class="line">  const photo = await api.getPhoto(user.id)</span><br><span class="line">  console.log(&#x27;asyncAwaitIsYourNewBestFriend&#x27;, &#123; user, friends, photo &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="需求2：获得朋友的朋友"><a href="#需求2：获得朋友的朋友" class="headerlink" title="需求2：获得朋友的朋友"></a>需求2：获得朋友的朋友</h4><p> promise链写法:这里使用的是迭代循环<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function promiseLoops () &#123;  </span><br><span class="line">  const api = new Api()</span><br><span class="line">  api.getUser()</span><br><span class="line">    .then((user) =&gt; &#123;</span><br><span class="line">      return api.getFriends(user.id)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then((returnedFriends) =&gt; &#123;</span><br><span class="line">      const getFriendsOfFriends = (friends) =&gt; &#123;</span><br><span class="line">        if (friends.length &gt; 0) &#123;</span><br><span class="line">          let friend = friends.pop()</span><br><span class="line">          return api.getFriends(friend.id)</span><br><span class="line">            .then((moreFriends) =&gt; &#123;</span><br><span class="line">              console.log(&#x27;promiseLoops&#x27;, moreFriends)</span><br><span class="line">              return getFriendsOfFriends(friends)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return getFriendsOfFriends(returnedFriends)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> Async&#x2F;Await写法:<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> async function asyncAwaitLoops () &#123;</span><br><span class="line">  const api = new Api()</span><br><span class="line">  const user = await api.getUser()</span><br><span class="line">  const friends = await api.getFriends(user.id)</span><br><span class="line">  for (let friend of friends) &#123;</span><br><span class="line">    let moreFriends = await api.getFriends(friend.id)</span><br><span class="line">    console.log(&#x27;asyncAwaitLoops&#x27;, moreFriends)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  Async&#x2F;Await写法简化并发<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  async function asyncAwaitLoopsParallel () &#123;</span><br><span class="line">  const api = new Api()</span><br><span class="line">  const user = await api.getUser()</span><br><span class="line">  const friends = await api.getFriends(user.id)</span><br><span class="line">  const friendPromises = friends.map(friend =&gt; api.getFriends(friend.id))</span><br><span class="line">  const moreFriends = await Promise.all(friendPromises)</span><br><span class="line">  console.log(&#x27;asyncAwaitLoopsParallel&#x27;, moreFriends)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  参考：</p>
<ul>
<li><a href="https://promisesaplus.com/">Promises&#x2F;A+</a></li>
<li><a href="https://blog.patricktriest.com/what-is-async-await-why-should-you-care/">ASYNC&#x2F;AWAIT WILL MAKE YOUR CODE SIMPLER</a></li>
</ul>
]]></content>
      <categories>
        <category>javscript</category>
      </categories>
  </entry>
  <entry>
    <title>SSL/TLS</title>
    <url>/2020/03/06/SSL_TLS/</url>
    <content><![CDATA[<p>因为要给服务器的一些域名添加https借此机会了解下SSL&#x2F;TLS</p>
<span id="more"></span>

<h2 id="原始加密"><a href="#原始加密" class="headerlink" title="原始加密"></a>原始加密</h2><p>假设A向B通信没有任何的加密，中间一个C拦截掉A的消息后，那么A与B之间的通信毫无隐私可言。那么就出现了第一种加密方式。  </p>
<p><code>对称加密</code>：加密和解密使用同一个密钥。<br>接下来的A向B通信方式是：</p>
<ul>
<li>1 协商一个两者都有的密钥  </li>
<li>2 A用密钥将消息加密后传输  </li>
<li>3 B得到加密后的消息，用同一个密钥解密得到原始消息</li>
</ul>
<p>优点：<br>就算C拦截掉了A发给B加密的信息，没有密钥那么C也没办法获取到原始信息</p>
<p>缺点:  </p>
<ul>
<li>1 协商密钥只能线下获取，否则密钥被C拿到到了一样C就可以得到A和B之间通信的消息</li>
<li>2 通过暴力破解的方式可以破解56bit的DES加密信息，为了应对这样的情况只好提出新的协议如 triple-DES(最长168bit)、AES(最长256bit)，在目前的计算机计算来看无法短期内被暴力破解</li>
</ul>
<h2 id="升级加密"><a href="#升级加密" class="headerlink" title="升级加密"></a>升级加密</h2><p>由于A可能和很多人通信，不可能每次通信前必须线下交换密钥。接下来出现了可以将自己的 pulic key（公钥）在网上传播的加密方式。 </p>
<p><code>非对称加密</code>： 每个用户有两个密钥一个public key(公钥)另一个private key（私钥），加密用其中的一个key解密必须用另一个key。（比如使用pulick key加密的信息就只能用private key来解密，抑或加密用private key解密就只能用public key）双方各执持有对方的public key，各执保留自己的private key。  </p>
<p>这样C拿到一方的public key没有private key也是没办法破解消息。</p>
<p>接下来的A向B通信方式是：</p>
<ul>
<li>1 A和B在网上交换各自的public key，各自保留自己的private key</li>
<li>2 A将要发送的数据进行hash计算出一段hash值，用自己private key对这段hash值进行加密。A将要发送的数据使用B的public key进行加密。最后将加密后的hash以及加密后的数据加上一些其他东西发送给B</li>
<li>3 B收到加密后的hash以及加密的数据。B用A的public key将加密后hash解密得到原始hash。B用自己的private key解密加密后的数据得到原始数据，在将原始数据进行hash计算得到hash值，与前面解密得到的hash对比。如果一致那么数据可以使用。</li>
</ul>
<p>优点：  </p>
<ul>
<li>1 就算知道public key也没办法解密消息</li>
</ul>
<p>缺点：</p>
<ul>
<li>1 非对称加密由于数学原因相对于对称加密要消耗更多（指数级别）的CPU资源</li>
<li>2 非对称加密情况下，如果C分别获取了A和B的public key并且用自己的public key分别发给A和B,就可能出现以下情况。 <ul>
<li>2.1 A将用自己的private key加密数据的hash值，用C的public key加密数据</li>
<li>2.2 C拦截到加密后的hash值，以及加密后的数据。C用自己的private key解密加密后的数据（这样就得到原始数据），并且C将篡改后的原始数据计算hash值，并且用C自己的private key计算出加密后hash值，再用先前拦截到B的public key加密篡改后的数得到加密后的数据。将篡改后的加密hash值、加密数据发送给B</li>
<li>2.3 B收到以后两个数据后，先用自己的private key解密数据之后计算hash值，再用C传来的假public key解密hash值，发现匹配。</li>
</ul>
</li>
</ul>
<h2 id="现代加密"><a href="#现代加密" class="headerlink" title="现代加密"></a>现代加密</h2><p>  上面非对称加密的第二个缺陷的关键问题：public key无法保证是对方的。  </p>
<p>  CA（Certificate Authority）证书认证就是解决这个问题的，CA的工作方式如下<br>  1： B先将自己的public key和其他一些信息交给CA<br>  2： CA用自己的private key加密这些信息生产B的数字证书，返回给B<br>  3： 当B向A传递自己的pulic key时，B传递数字证书给A<br>  4： A拿到数字证书通过CA证书（包含CA的public key）解密B的数字证书获取到B的public key  </p>
<p>  这里有一个关键的地方怎么保证CA不被劫持，原因是CA将自己的证书集成到浏览器和操作系统中，只有在浏览器或者操作系统被劫持的情况CA才有可能被劫持。这样只要操作系统和浏览器不被劫持就能保证交换public key</p>
<p>非对称加密处理缓慢的问题在实际SSL&#x2F;TLS使用场景中是大体上是如下解决的（细节有差别）：</p>
<ul>
<li>1 先通过CA保证交换public key</li>
<li>2 再通过非对称算法交换对称加密密钥（一部分）</li>
<li>3 最后通过对称加密，加密通信</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p> 最常见的SSL&#x2F;TLS使用场景为HTTPS（HTTP over SSL）, CA作为公证机构一般是要收费的，用户（普通人）是不会去申请的，而服务端一般会去申请，所有实际的HTTPS如下：</p>
<ul>
<li>1 用户向服务端发起一个安全连接请求  </li>
<li>2 服务端返回一个经过CA认证的数字证书，客户通过浏览器内置的CA解密证书得到服务端public key  </li>
<li>3 用户使用public key加密一个对称加密算法的密钥，并且发送给服务端</li>
<li>4 服务端使用自己的private key解密得到原始的对称算法密钥</li>
<li>5 双方通信使用对称算法密钥加密和解密</li>
</ul>
]]></content>
      <tags>
        <tag>https SSL/TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>RFC 7234</title>
    <url>/2017/10/23/RFC/</url>
    <content><![CDATA[<h2 id="1-导言"><a href="#1-导言" class="headerlink" title="1 导言"></a>1 导言</h2><p>  HTTP通常用于分配信息的系统，在这里性能可以通过利用响应存储得到提升，这份文档定义 HTTP&#x2F;1.1关于缓存和再利用响应消息的部分.  </p>
<p>  一个HTTP缓存除了包括响应消息的本地存储控制还包括检索，删除，控制存储消息本身.一个缓存了可缓存的响应和等效的普通响应相比使用更少的响应时间和带宽消耗.任何的用户(client)和服务(server)都可以使用缓存，但是被当做隧道(tunnel)的服务不能使用.  </p>
<p>  共享缓存(shared cache)的响应存储可以被多用户再次利用，通常共享缓存被部署为中介的一部分.相反的私有缓存(private cache)只能被一个用户检查到，通常私有缓存被部署为用户代理的一部分.  </p>
<p>  在HTTP&#x2F;1.1中缓存通过再利用先前的响应满足现有请求而达到明显提高效率的目标.一个已存储的缓存被认为”新鲜”(fresh)必须先满足4.2定义部分，那么这个响应可以再利用并且不用”检验”(validation：向源服务器检查看缓存响应是否对于这个请求仍然有效).一个新鲜的响应可以每次重利用因此可以有效的减少延迟的网络管理.当缓存响应不再新鲜是，它也许还可以利用比如通过检验再更新新鲜度(4.3)或者服务源unavailable(4.2.4).<br>  <span id="more"></span></p>
<h3 id="1-1-一致性和错误处理"><a href="#1-1-一致性和错误处理" class="headerlink" title="1.1 一致性和错误处理"></a>1.1 一致性和错误处理</h3><p>  关键字如”必须”，”必须不”，”必要的”，”将会”，”将不会”,”应该”，”应该不”，”建议”，”也许”，”选择性的”这些在文档中出现的都将在[RFC2119]得到解释.    </p>
<p>  一致性准则和常规错误处理都在[RFC7230]中得到定义.</p>
<h2 id="2-缓存系统概览"><a href="#2-缓存系统概览" class="headerlink" title="2 缓存系统概览"></a>2 缓存系统概览</h2><p>  正确的缓存系统应该保持HTTP传输中的语法，同时应该消除已经存在于缓存中的传输信息.虽然缓存行为在HTTP中完全是一个可选项.但是你可以将再利用缓存响应当做可取的并且这种再利用是不需要要求或者本地配置来强制的默认行为.因此HTTP的缓存配置是用来强制性规定缓存行为来满足一些我们想要的特性，而不是像托管一样总是缓存再利用一些特定的响应.    </p>
<p>  每个缓存记录包含一个缓存键和一个或者多个http响应，这些响应对应着先前使用同一个键值的请求.一个最常见形式的缓存记录为成功的检索请求： ie,200(OK).然而，它也可能缓存一个永久性重定向301，否认结果404，不完全结果206，或者缓存一个除了GET以外的方法.  </p>
<p>  基本的缓存键值包含请求方法和目标URI，因为HTTP缓存通常只缓存GET方法返回的请求，许多缓存简单的去掉其他方法并只用URI当做基本的缓存键值.  </p>
<p>  如果一个请求的目标为内容协商，它的缓存体也许会包含多种响应，每种不同响应通过第二键值做区分(4.1)</p>
<h2 id="3-在缓存中存储响应的过程"><a href="#3-在缓存中存储响应的过程" class="headerlink" title="3 在缓存中存储响应的过程"></a>3 在缓存中存储响应的过程</h2><p>  缓存前提条件：</p>
<ul>
<li>请求方法必须能被缓存所理解并且被定义为可缓存类型</li>
<li>响应状态码必须能被缓存理解</li>
<li>缓存指令”no-store”(5.2)不能出现在请求或者响应头中</li>
<li>共享缓存在响应中缓存指令不能出现”private”(5.2.2.6)否则共享缓存不生效</li>
<li>共享缓存中权限认证头信息(4.2 of[RFC7235])不能出现响应头，除非响应中有明确允许其可以缓存(3.2)</li>
<li>其中之一的响应：<ul>
<li>包含一个Expires头信息(5.3)</li>
<li>包含一个max-age 的缓存指令(5.2.2.8)</li>
<li>在共享缓存缓存中，包含一个 s-maxage缓存指令(5.2.2.9)</li>
<li>包含一个Cache Control 扩展(5.2.3)允许其可以被缓存</li>
<li>包含一个被定义为可缓存的状态码(4.2.2)</li>
<li>包含一个public的缓存指令(5.2.2.5)<br>  注意以上的满足条件都可以被cache-control扩展所重写(5.2.3)</li>
</ul>
</li>
</ul>
<p>  在这段内容中，如果表现出与缓存相关的行为时，这时缓存已经”理解”一个请求方法或响应状态码.  </p>
<p>  注意，通常系统中，一些缓存将不会存储一个既没有明确的过期时间也没有缓存验证器的响应.但是缓存也没禁止缓存这样的响应.  </p>
<h3 id="3-1-存储不完全响应"><a href="#3-1-存储不完全响应" class="headerlink" title="3.1 存储不完全响应"></a>3.1 存储不完全响应</h3><h3 id="3-2-存储权限认证请求的响应"><a href="#3-2-存储权限认证请求的响应" class="headerlink" title="3.2 存储权限认证请求的响应"></a>3.2 存储权限认证请求的响应</h3><pre><code>除非缓存指令指定，否则共享缓存不能用于缓存拥有权限认证请求返回的响应.(4.2 of [RFC7235]).
在这份规格中，下面的Cache-Control的响应指令中有这些指令： must-revalidate， public， s-maxage.  

注意在缓存响应中包含&quot;must-revalidate&quot; 和/或&quot;s-maxage&quot;的响应指令则不允许过期存储被共享存储(4.2.4). 特别是在响应中要么包含&quot;max-age=0, must-revalidate&quot;或者&quot;s-maxage=0&quot;则表明后续请求都必须通过源服务器否认验证才能使用.
</code></pre>
<h3 id="3-3-混合部分内容"><a href="#3-3-混合部分内容" class="headerlink" title="3.3 混合部分内容"></a>3.3 混合部分内容</h3><h2 id="4-从缓存到响应的构成"><a href="#4-从缓存到响应的构成" class="headerlink" title="4 从缓存到响应的构成"></a>4 从缓存到响应的构成</h2><p>   当发起请求时，利用缓存必须满足以下条件：</p>
<ul>
<li>请求为有效请求URI，并且在缓存中能匹配到</li>
<li>请求方法和所匹配的缓存允许其用来展现请求</li>
<li>所选择的请求头被匹配的缓存所命中(nomiated：4.1)</li>
<li>请求头中不能包含pragma &#x3D; no-cache的请求头(5.4),或者请求头中有缓存指令包含no-cache,除非存储的缓存已经成功的验证.</li>
<li>存储的响应没有包含no-cache缓存指令，除非已经验证成功</li>
<li>存储的响应时一下之一： <ul>
<li>新鲜(fresh:4.2)</li>
<li>允许其过期响应(4.2.4)</li>
<li>验证成功(4.3)</li>
</ul>
</li>
</ul>
<pre><code>注意上面的条件都有可能被cache-contral扩展所重写(4.2.3)
当一个存储好的响应被用来满足一个没有验证的请求时，这个缓存必须产生一个Age头(5.1),并且替换在响应中任何等价于current_age的值(4.2.3)
</code></pre>
<h3 id="4-1-使用Vary当做第二存储键值"><a href="#4-1-使用Vary当做第二存储键值" class="headerlink" title="4.1 使用Vary当做第二存储键值"></a>4.1 使用Vary当做第二存储键值</h3><h3 id="4-2-新鲜度"><a href="#4-2-新鲜度" class="headerlink" title="4.2 新鲜度"></a>4.2 新鲜度</h3><p>   一个新鲜响应代表着它的生命周期还没过期，相反的是过期响应.    </p>
<p>   一个响应的新鲜度生命周期是从其源服务器产生到过期的时间，明确过期时间：当存储的响应过了期明确的过期时间这就意味着响应必须通过源服务器验证后才能使用。当一个缓存没有明确的过期时间时启发式过期时间就会被缓存赋予.  </p>
<p>   一个响应的年龄(age)表示其从源服务器所产生到当前的时间差，或者从源服务器验证成功到目前的时间差.  </p>
<p>   当一个响应在缓存中新鲜时，它可以满足其后的相同请求并不需要访问源服务器，因此相当高效.  </p>
<p>   决定新鲜度的最主要机制通常为源服务器提供一个明确在未来过期的时间(5.3)，或者响应提供一个max-age指令(5.2.2.8).</p>
<p>   因为源服务器不总是提供一个明确的过期时间，缓存也可以允许其使用启发式过期时间(4.2.4)  </p>
<p>   具体的计算规则：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response_is_fresh = (freshness_lifetime &gt; current_age)</span><br></pre></td></tr></table></figure><br>   freshness_lifetime定义在4.2.1;current_age定义在4.2.3  </p>
<p>   客户端可以在请求中使用max-age或者min-fresh的响应指令来放松或加固信所对应响应新鲜度的计算<br>(5.2.1)   </p>
<p>  注意新鲜度只能应用与缓存系统;它不能用户强迫客户端刷新其展示或者重新加载资源，第6部分将会解释缓存和历史机制的区别.  </p>
<h4 id="4-2-1-计算新鲜度生命周期"><a href="#4-2-1-计算新鲜度生命周期" class="headerlink" title="4.2.1 计算新鲜度生命周期"></a>4.2.1 计算新鲜度生命周期</h4><p>  一个缓存可以通过如下最先匹配的规则来计算器生命周期(称:freshness_lifetime):</p>
<ul>
<li>如果缓存被共享并且响应中有s-maxage缓存指令</li>
<li>如果响应中有缓存指令max-age</li>
<li>如果头信息中存在Exoires，用它的值减去响应头的Date值</li>
<li>使用启发式生命周期(4.2.2)  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下面是 http权威指南 服务端新鲜度计算伪代码比较易懂</span><br><span class="line">sub server_freshness_limit</span><br><span class="line">&#123;</span><br><span class="line">  local($heuristic,$server_freshness_limit,$time_since_last_modify);</span><br><span class="line">  $heuristic = 0;</span><br><span class="line">  if ($Max_Age_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $server_freshness_limit = $Max_Age_value;</span><br><span class="line">  &#125;</span><br><span class="line">  elseif ($Expires_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $server_freshness_limit = $Expires_value - $Date_value;</span><br><span class="line">  &#125;</span><br><span class="line">  elseif ($Last_Modified_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $time_since_last_modify = max(0, $Date_value -</span><br><span class="line">  　　　　　　　　 $Last_Modified_value);</span><br><span class="line">    $server_freshness_limit = int($time_since_last_modify *</span><br><span class="line">  　　　　　　　　 $lm_factor);</span><br><span class="line">    $heuristic = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    $server_freshness_limit = $default_cache_min_lifetime;</span><br><span class="line">    $heuristic = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if ($heuristic)</span><br><span class="line">  &#123;</span><br><span class="line">    if ($server_freshness_limit &gt; $default_cache_max_lifetime)</span><br><span class="line">    &#123; $server_freshness_limit = $default_cache_max_lifetime; &#125;</span><br><span class="line">    if ($server_freshness_limit &lt; $default_cache_min_lifetime)</span><br><span class="line">    &#123; $server_freshness_limit = $default_cache_min_lifetime; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return($server_freshness_limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub client_modified_freshness_limit</span><br><span class="line">&#123;</span><br><span class="line">  $age_limit = server_freshness_limit( ); ## From Example 7-2</span><br><span class="line">  if ($Max_Stale_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    if ($Max_Stale_value == $INT_MAX)</span><br><span class="line">    &#123; $age_limit = $INT_MAX; &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123; $age_limit = server_freshness_limit( ) + $Max_Stale_value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  if ($Min_Fresh_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $age_limit = min($age_limit, server_freshness_limit( ) -</span><br><span class="line">  　　　　　　　$Min_Fresh_value_set);</span><br><span class="line">  &#125;</span><br><span class="line">  if ($Max_Age_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $age_limit = min($age_limit, $Max_Age_value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  注意计算过程并不会时钟抖动，因为所有的信息都来自源服务器.  </p>
<p>  当响应头有多余一个值的指令信息(e.g. 两个过期响应头，多个Cache-Contorl: max-age指令)，这些值都会被当做无效值.缓存鼓励其响应拥有无效生命新鲜度来让它过期.  </p>
<h4 id="4-2-2-启发式-Heuristic-新鲜度计算"><a href="#4-2-2-启发式-Heuristic-新鲜度计算" class="headerlink" title="4.2.2 启发式(Heuristic)新鲜度计算"></a>4.2.2 启发式(Heuristic)新鲜度计算</h4><p>   如果源服务器没有提供一个明确的过期时间，缓存也许可以使用一定算法来利用其他头信息来(如Last-Modified)来推算一个合理的过期时间，这份文档并不会提供具体算法，但是可以为一些边界情况加一些限制。  </p>
<p>   缓存只有在没有一个明确的过期时间时才可以使用启发式新鲜度时间，根据在第3部分的缓存的前置条件。只有两种可能，一是响应状态码位可缓存的(6.1 of[RFC7231])且没有明确过期时间，二是被标记为可以缓存(e.g. 有”public”缓存指令)且没有明确过期时间.  </p>
<p>   如果存储响应有头信息Last-Modified(2.2 of [RFC7232]),缓存鼓励这个启发式过期时间为从现在到Last-Modified值之间差的某一比例.通常这个比例也许为10%.<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freshness_lefetime = (date - Last-Modified)*10% </span><br></pre></td></tr></table></figure></p>
<p>   当启发式过期时间用于新鲜度生命周期，其中current_age的值已经超过24小时时缓存应该产生一个113 warn-code的头信息(5.5.4).  </p>
<h4 id="4-2-3-计算年龄-age"><a href="#4-2-3-计算年龄-age" class="headerlink" title="4.2.3 计算年龄(age)"></a>4.2.3 计算年龄(age)</h4><p>   头信息的Age通常用来表示从缓存获取响应的年龄时间.age的值通常由响应被产生时或被重新验证过起来估算.本质上来说Age的值由两部分之和，一是响应在缓存中驻存时间，二是响应在网络中转换的时间.   </p>
<p>   如下值用来age值的计算:  </p>
<ul>
<li><p>“age_value”这个条目指的是头信息Age的值(5.1),这个值是以一种合适的算法系统计算而出，或者当它不存在的时候则为0</p>
</li>
<li><p>date_value这个条目的值为头信息Date的值  </p>
</li>
<li><p>now这个条目值指的是执行计算时的时间点  </p>
</li>
<li><p>request_time这个时间指的是请求从缓存中返回的时间点</p>
</li>
<li><p>response_time主机接受响应的时间点</p>
</li>
</ul>
<p>   响应age可以通过两种完全独立的方法计算  </p>
<ul>
<li><p>1.”apprent_age”:如果在本地时钟和源服务器时钟合理同步时 结果&#x3D;response_time - date_value. 如果解构等于负数，结果被零替换.  </p>
</li>
<li><p>2.”corrected_age_value”,如果所有的缓存都遵循HTTP&#x2F;1.1,缓存必须就必须将这个值理为与请求初始化成功相关，而不是与响应接受相关  </p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apparent_age = max(0, response_time - date_value);</span><br><span class="line">response_delay = response_time = request_time;</span><br><span class="line">corrected_age_value = age_value + response_delay</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  这两者相结合就是  </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">corrent_initial_age = max(apparent_age, corrented_age_value);</span><br></pre></td></tr></table></figure>

<p>  current_age 的值：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resident_time = now -response_time;</span><br><span class="line">current_age  = corrented_initial_age + resident_time</span><br></pre></td></tr></table></figure></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这一版是http权威指南上的感觉更好理解</span><br><span class="line">$apparent_age = max(0, $time_got_response - $Date_header_value);</span><br><span class="line">$corrected_apparent_age = max($apparent_age, $Age_header_value);</span><br><span class="line">$response_delay_estimate = ($time_got_response - $time_issued_request);</span><br><span class="line">$age_when_document_arrived_at_our_cache =</span><br><span class="line">$corrected_apparent_age + $response_delay_estimate;</span><br><span class="line">$how_long_copy_has_been_in_our_cache = $current_time - $time_got_response;</span><br><span class="line">$age = $age_when_document_arrived_at_our_cache +</span><br><span class="line">$how_long_copy_has_been_in_our_cache;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-提供过期响应"><a href="#4-2-4-提供过期响应" class="headerlink" title="4.2.4 提供过期响应"></a>4.2.4 提供过期响应</h4><p>  一个”过期(stale)”响应要么有明确的过期信息或许是已经过期的通过启发式新鲜度计算的值.  </p>
<p>  如果通过缓存指令致使明确过期的响应(e.g, no-store, no-cache,must-revalidate,s-maxage, proxy-revalidate)，缓存一定不能返回过期响应.  </p>
<p>  除非失去连接一般缓存不会返回过期响应(i.e:不能连接到源服务器或者发现一个前进路径),另外明确指出可以返回过期响应也可以(e.g: 通过max-stale 请求指令)  </p>
<p>  缓存在返回过期响应时响应头应该有110 warn-code(5.5.1),同样的在失去连接情况下返回过期响应，响应头有112 warn-code  </p>
<p>  在前往一个没有Age头信息的响应如果响应已经过期缓存不应该产生一个新的warning头信息. 缓存不需要为一个仅仅因为传输而过期的响应而验证.</p>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><p>  当一个缓存拥有一个或者多个缓存响应对应一个请求URI但是却无法提供给这个请求(e.g:因为这些缓存不新鲜，或者没有被选择4.1)，这样的话可以利用条件请求机制(conditional request machanism[RFC7232])转发请求给下一个到达的服务器来选择正确的响应来使用，一般可以通过更新存储的元数据或者更新一个完全新的响应.这个过程被称为验证存储响应.  </p>
<h4 id="4-3-1-发送一个验证请求"><a href="#4-3-1-发送一个验证请求" class="headerlink" title="4.3.1 发送一个验证请求"></a>4.3.1 发送一个验证请求</h4><h4 id="5-Cache-Control"><a href="#5-Cache-Control" class="headerlink" title="5 Cache-Control"></a>5 Cache-Control</h4>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这份图表来自 RFC2616</span><br><span class="line"> Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive</span><br><span class="line">  cache-directive = cache-request-directive</span><br><span class="line">       | cache-response-directive</span><br><span class="line">  cache-request-directive =</span><br><span class="line">         &quot;no-cache&quot;                          ; Section 14.9.1</span><br><span class="line">       | &quot;no-store&quot;                          ; Section 14.9.2</span><br><span class="line">       | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; Section 14.9.3, 14.9.4</span><br><span class="line">       | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; Section 14.9.3</span><br><span class="line">       | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; Section 14.9.3</span><br><span class="line">       | &quot;no-transform&quot;                      ; Section 14.9.5</span><br><span class="line">       | &quot;only-if-cached&quot;                    ; Section 14.9.4</span><br><span class="line">       | cache-extension                     ; Section 14.9.6</span><br><span class="line">   cache-response-directive =</span><br><span class="line">         &quot;public&quot;                               ; Section 14.9.1</span><br><span class="line">       | &quot;private&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ] ; Section 14.9.1</span><br><span class="line">       | &quot;no-cache&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ]; Section 14.9.1</span><br><span class="line">       | &quot;no-store&quot;                             ; Section 14.9.2</span><br><span class="line">       | &quot;no-transform&quot;                         ; Section 14.9.5</span><br><span class="line">       | &quot;must-revalidate&quot;                      ; Section 14.9.4</span><br><span class="line">       | &quot;proxy-revalidate&quot;                     ; Section 14.9.4</span><br><span class="line">       | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; Section 14.9.3</span><br><span class="line">       | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; Section 14.9.3</span><br><span class="line">       | cache-extension                        ; Section 14.9.6</span><br><span class="line">  cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ]</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>docker网络</title>
    <url>/2020/03/13/docker%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>Docker的网络环境隔离使用的是Linux Namespace技术进行网络隔离的，每一个 network namespace都有一个独立的网络环境其中包括：网卡,路由，iptable规则等。<br> 整体架构如下图：<br> <img src="/2020/03/13/docker%E7%BD%91%E7%BB%9C/docker-network-type.png" alt="docker-network-type"><br> <span id="more"></span></p>
<h3 id="1-1-docker四种网络模式"><a href="#1-1-docker四种网络模式" class="headerlink" title="1.1 docker四种网络模式"></a>1.1 docker四种网络模式</h3><p>隔离性由强到弱如下:  </p>
<ul>
<li>none模式 指定方式：–net&#x3D;none</li>
<li>bridge模式 指定方式：–net&#x3D;bridge</li>
<li>container模式 指定方式：–net&#x3D;container:NAME_or_ID</li>
<li>host模式 指定方式：–net&#x3D;host<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认创建好三种模式，无法删除</span><br><span class="line">docker network ls </span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">99646193e5fd        bridge              bridge              local</span><br><span class="line">213621f7ea56        host                host                local</span><br><span class="line">7bbc7a38b19f        none                null                local</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-2-bridge-网桥模式"><a href="#1-2-bridge-网桥模式" class="headerlink" title="1.2 bridge 网桥模式"></a>1.2 bridge 网桥模式</h3><p>docker引擎在创建时会，创建一个docker0的虚拟网桥，在同一台宿主机上启动的docker容器的网络设备（虚拟网卡）默认会连接到这个网桥上，并且默认地址为172.17.0.0&#x2F;16中的地址。网桥工作的方式类似与物理交换机（bridge有多个端口，数据可以从任何端口进来，进来之后从哪个口出去和物理交换机的原理差不多，要看mac地址）</p>
<p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p>
]]></content>
      <categories>
        <category>docker network</category>
      </categories>
  </entry>
  <entry>
    <title>Aribnb javascript 代码规范</title>
    <url>/2017/11/10/Airbnb_JavaScript_Style_Guide/</url>
    <content><![CDATA[<h2 id="类型-Types"><a href="#类型-Types" class="headerlink" title="类型(Types)"></a>类型(Types)</h2><ul>
<li><p>1.1 原始类型：当你获取一个原始类型你应该直接在其值上操作</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const foo = 1;</span><br><span class="line">let bar = foo;</span><br><span class="line"></span><br><span class="line">bar = 9;</span><br><span class="line"></span><br><span class="line">console.log(foo, bar); // =&gt; 1, 9</span><br></pre></td></tr></table></figure></li>
<li>Symbols不能完全polyfill,所以在使用应该确定其当前使用的环境原生支持 <span id="more"></span></li>
</ul>
</li>
<li><p>1.2 复杂类型：当你获取一个复杂类型时你应该通过其引用来操作其值</p>
<ul>
<li>object</li>
<li>array</li>
<li>function <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const foo = [1, 2];</span><br><span class="line">const bar = foo;</span><br><span class="line"></span><br><span class="line">bar[0] = 9;</span><br><span class="line"></span><br><span class="line">console.log(foo[0], bar[0]); // =&gt; 9, 9</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="参数-References"><a href="#参数-References" class="headerlink" title="参数(References)"></a>参数(References)</h2><ul>
<li><p>2.1 对所有参数使用const;避免使用var  eslint：prefer-const，no-const-assign</p>
<blockquote>
<p>为什么? 这是避免你对你的参数赋值，参数赋值可以导致许多bug并且难于理解</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad </span><br><span class="line">var a = 1;</span><br><span class="line">var b = 2;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const a = 1;</span><br><span class="line">const b = 2;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>2.2 如果你一定要重新对你的参数再次赋值，可以使用let代替var eslit: no-var jscs: disallowVar</p>
<blockquote>
<p>为什么? let拥有块级作用而var拥有函数作用域</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var count = 1;</span><br><span class="line">if(true)&#123;</span><br><span class="line">    count += 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good, use the let.</span><br><span class="line">let count = 1;</span><br><span class="line">if(true)&#123;</span><br><span class="line">    count += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>2.3 值的注意的是let和const都是块级作用域</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// const和let只存在于定义的块</span><br><span class="line">&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    const b = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // ReferenceError</span><br><span class="line">console.log(b); // ReferenceError</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对象-Objects"><a href="#对象-Objects" class="headerlink" title="对象(Objects)"></a>对象(Objects)</h2><ul>
<li>3.1 使用字面量语法创建对象 eslint: no-new-object  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const item = new Object();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const item = &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3.2 当创建的对象拥有动态属性名时使用计算属性名称<br>    &gt; 为什么? 这样允许你在统一的一个地方定义对象属性<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getKey(k)&#123;</span><br><span class="line">    return `a key named $&#123;k&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const obj = &#123;</span><br><span class="line">    id: 5,</span><br><span class="line">    name: &#x27;San Francisco&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">obj[getKey(&#x27;endabled&#x27;)] = true;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const obj = &#123;</span><br><span class="line">    id: 5,</span><br><span class="line">    name: &#x27;San Francisco&#x27;,</span><br><span class="line">    [getKey(&#x27;enabled&#x27;)]: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>3.3 使用对象方法简写 eslint: object-shorthand </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const atom = &#123;</span><br><span class="line">    value: 1,</span><br><span class="line"></span><br><span class="line">    addValue： function(value)&#123;</span><br><span class="line">        return atom.value + value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const atom = &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    addValue(value)&#123;</span><br><span class="line">        return atom.value + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.4 使用属性值简写 eslint: object-shorthand</p>
<blockquote>
<p>为什么? 对于书写和描述更加短小</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const lukeSkywalker = &#x27;Luke Skywalker&#x27;;</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">const obj = &#123;</span><br><span class="line">    lukeSkywalker: lukeSkywalker</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const obj = &#123;</span><br><span class="line">    lukeSkywalker</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>3.5 将简写属性统一放在对象声明的开头</p>
<blockquote>
<p>为什么? 这样更容易区分哪些属性是使用的简写</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const anakinSkywalker = &#x27;Anakin Skywalker&#x27;;</span><br><span class="line">const lukeSkywalker = &#x27;Luke Skywalker&#x27;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const obj = &#123;</span><br><span class="line">episodeOne: 1,</span><br><span class="line">twoJediWalkIntoACantina: 2,</span><br><span class="line">lukeSkywalker,</span><br><span class="line">episodeThree: 3,</span><br><span class="line">mayTheFourth: 4,</span><br><span class="line">anakinSkywalker,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const obj = &#123;</span><br><span class="line">lukeSkywalker,</span><br><span class="line">anakinSkywalker,</span><br><span class="line">episodeOne: 1,</span><br><span class="line">twoJediWalkIntoACantina: 2,</span><br><span class="line">episodeThree: 3,</span><br><span class="line">mayTheFourth: 4,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>3.6 只有当非法标识符做属性时才使用引号 eslint: quote-props</p>
<blockquote>
<p>为什么? 通常这样主观上更易阅读,它改进了语法突显,并且也更加容易被许多js引擎优化</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const bad = &#123;</span><br><span class="line">&#x27;foo&#x27;: 3,</span><br><span class="line">&#x27;bar&#x27;: 4,</span><br><span class="line">&#x27;data-blah&#x27;: 5,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const good = &#123;</span><br><span class="line">foo: 3,</span><br><span class="line">bar: 4,</span><br><span class="line">&#x27;data-blah&#x27;: 5,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>3.7 不要直接使用Object.prototype上的方法,如hasOwnProperty,propertyIsEnumerable,isPrototypeOf  </p>
<blockquote>
<p>为什么? 这些方法有可能被对象实例上的属性给覆盖掉 如问题中的{hasOwnProperty: false}或者这个对象也许是个null对象(Object.create(null))</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">console.log(object.hasOwnProperty(key));</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">console.log(Object.prototype.hasOwnProperty.call(object, key));</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">const has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope.</span><br><span class="line">/* or */</span><br><span class="line">import has from &#x27;has&#x27;;</span><br><span class="line">// ...</span><br><span class="line">console.log(has.call(object, key));</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>3.8 在覆盖-拷贝对象时应该利用展开运算符(…)而不是Object.assign 为了得到一个已删减属性的新对象应该使用对象解构运算符</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// very bad</span><br><span class="line">const original = &#123;a:1, b: 2&#125;;</span><br><span class="line">const copy = Object.assign(origin,&#123;c:3&#125;);// 这个改变了 `original` ಠ_ಠ</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">const original = &#123;a:1, b: 2&#125;;</span><br><span class="line">const copy = Object.assign(&#123;&#125;, original, &#123;c:3&#125;); // copy =&gt;&#123;a:1,b:2,c:3&#125;</span><br><span class="line"></span><br><span class="line">//good</span><br><span class="line">const original = &#123;a:1, b:2&#125;;</span><br><span class="line">const copy = &#123;...original,c:3&#125;; // copy =&gt;&#123;a:1, b:2, c:3&#125;</span><br><span class="line"></span><br><span class="line">const &#123;a,...noA&#125; = copy; // noA =&gt; &#123;b:2, c:3&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h2><ul>
<li><p>4.1 使用字面量语法创建数组. eslint: no-array-constuctor</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const items = new Array();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const items = [];</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.2 使用数组的push方法添加项而不是直接添加</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const someStack = [];</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">someStack[someStack.length] = &#x27;abc&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">someStack.push(&#x27;abc&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.3 使用数组的扩展运算符…来复制数组</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const len = items.length;</span><br><span class="line">const itemsCopy = [];</span><br><span class="line">let i;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; len; i += 1) &#123;</span><br><span class="line">itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const itemsCopy = [...items];</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.4 使用…将类数组转换为数组而不是Array.form</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const foo = document.querySelectorAll(&#x27;.foo&#x27;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const nodes = Array.from(foo);</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">const nodes = [...foo];</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.5 Array.from 而不是展开运算符…来遍历执行方法 ,因为它避免了创建一个中间数组(这里是因为使用map时从来没被赋过值或者使用 delete 删除的索引则不会调用函数。)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad </span><br><span class="line">const baz = [...foo].map(bar);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const baz = Array.form(foo, bar);</span><br><span class="line"></span><br><span class="line">//译者添加</span><br><span class="line">Array.from([1,,2],(i)=&gt;&#123;return i*2;&#125;) // =&gt; [2, NaN, 4]</span><br><span class="line"></span><br><span class="line">[1,,2].map((i)=&gt;&#123;return i*2;&#125;) // =&gt; [2, empty × 1, 4]</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.6 在数组的回调函数中返回声明.当函数体只包含一个声明语句且是没有副作用的表达式是可以省略return语句的。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// good</span><br><span class="line">[1, 2, 3].map((x) =&gt; &#123;</span><br><span class="line">const y = x + 1;</span><br><span class="line">return x * y;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">[1, 2, 3].map(x =&gt; x + 1);</span><br><span class="line"></span><br><span class="line">// bad - no returned value means `memo` becomes undefined after the first iteration</span><br><span class="line">[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123;</span><br><span class="line">const flatten = memo.concat(item);</span><br><span class="line">memo[index] = flatten;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123;</span><br><span class="line">const flatten = memo.concat(item);</span><br><span class="line">memo[index] = flatten;</span><br><span class="line">return flatten;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">inbox.filter((msg) =&gt; &#123;</span><br><span class="line">const &#123; subject, author &#125; = msg;</span><br><span class="line">if (subject === &#x27;Mockingbird&#x27;) &#123;</span><br><span class="line">    return author === &#x27;Harper Lee&#x27;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">inbox.filter((msg) =&gt; &#123;</span><br><span class="line">const &#123; subject, author &#125; = msg;</span><br><span class="line">if (subject === &#x27;Mockingbird&#x27;) &#123;</span><br><span class="line">    return author === &#x27;Harper Lee&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.7 如果一个数组拥有多行，在数组的开始括弧后和在结束括弧前加换行符。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad </span><br><span class="line">const arr = [</span><br><span class="line">    [0, 1], [2, 3], [4, 5]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const objectInArray = [&#123;</span><br><span class="line">    id: 2,</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    id:2</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">const numberInArray = [</span><br><span class="line">    1,2</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const arr = [[0, 1], [2, 3], [4, 5]];</span><br><span class="line"></span><br><span class="line">const ObjectInArray = [</span><br><span class="line">    &#123;</span><br><span class="line">        id: 1,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解构-Destructuring"><a href="#解构-Destructuring" class="headerlink" title="解构(Destructuring)"></a>解构(Destructuring)</h2><ul>
<li><p>5.1 当使用多属性对象赋值时应该使用对象解构</p>
<blockquote>
<p>为什么? 解构可以让你节约掉为那些属性创建临时变量</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function getFullName(user)&#123;</span><br><span class="line">    const firstName = user.firstName;</span><br><span class="line">    const lastName = user.lastName;</span><br><span class="line"></span><br><span class="line">    return `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function getFullName(user)&#123;</span><br><span class="line">    const &#123; firstName, lastName&#125; = user;</span><br><span class="line">    return `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">function getFullName(&#123;firstName, lastName&#125;)&#123;</span><br><span class="line">    return `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>5.2 使用数组解构. eslint: prefer-destrcuturing</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const first = arr[0];</span><br><span class="line">const second = arr[1];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const [first, second] = arr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.3 当多个值返回时使用对象解构而不是数组解构</p>
<blockquote>
<p>为什么? 你可以随着时间添加一个属性或者改变参数顺序而不用改变原来的调用</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function processInput(input)&#123;</span><br><span class="line">     // then a miracle occurs</span><br><span class="line">    return [left, right, top, bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者需要知道返回数据的顺序</span><br><span class="line">const [left, __, top] = pocessInput(input);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function precessInput(input)&#123;</span><br><span class="line">    // then a miracle occurs</span><br><span class="line">    return &#123;left, right, top, bottom&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者只需要选择他需要的数据</span><br><span class="line">const &#123; left, top &#125; = processInput(input);</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="字符串-Stirngs"><a href="#字符串-Stirngs" class="headerlink" title="字符串(Stirngs)"></a>字符串(Stirngs)</h2><ul>
<li><p>6.1 使用单引号’’ eslint: quotes</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const name = &quot;Capt. Janeway&quot;;</span><br><span class="line"></span><br><span class="line">// bad - template literals should contain interpolation or newlines</span><br><span class="line">const name = `Capt. Janeway`;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const name = &#x27;Capt. Janeway&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.2 当字符超过100字符不应该换行连接字符</p>
<blockquote>
<p>为什么?换行字符对于代码搜索性不有利</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const errorMessage = &#x27;This is a super long error that was thrown because \</span><br><span class="line">of Batman. When you stop to think about how Batman had anything to do \</span><br><span class="line">with this, you would get nowhere \</span><br><span class="line">fast.&#x27;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const errorMessage = &#x27;This is a super long error that was thrown because &#x27; +</span><br><span class="line">&#x27;of Batman. When you stop to think about how Batman had anything to do &#x27; +</span><br><span class="line">&#x27;with this, you would get nowhere fast.&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const errorMessage = &#x27;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&#x27;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>6.3 当编程式的构建字符串时使用字符串模板而不是使用连接 eslint: prefer-template template-curly-spacing</p>
<blockquote>
<p>为什么? 字符串模板可读性高，同时对于换行字符串以及插入特性语法简洁</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">    return &#x27;How are you, &#x27; + name + &#x27;?&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">    return [&#x27;How are you, &#x27;, name, &#x27;?&#x27;].join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">    return `How are you, $&#123; name &#125;?`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">    return `How are you, $&#123;name&#125;?`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>6.4 对字符串永远不要用eval(),这里面太多不稳定性 eslint: no-eval</p>
</li>
<li><p>6.5 不要添加多余的字符串转义 eslint:no-useless-escape</p>
<blockquote>
<p>为什么? 反斜杠破坏可读性，因此不要使用多余的转义</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const foo = &#x27;\&#x27;this\&#x27; \i\s \&quot;quoted\&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const foo = &#x27;\&#x27;this\&#x27; is &quot;quoted&quot;&#x27;;</span><br><span class="line">const foo = `my name is &#x27;$&#123;name&#125;&#x27;`;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数(Functions)"></a>函数(Functions)</h2><ul>
<li><p>7.1 使用命名函数表达式而不是函数声明. eslint: func-style</p>
<blockquote>
<p>为什么? 函数声明是要提升的，这就意味着函数相当容易在其定义前引用.这对可读性和可维护性是有害的.如果你发现函数的定义庞大或复杂到理解剩余文件内容时,或许这时是时候将定义提取到自己的模块中(module).不要忘记这个函数表达式明确的名字，不管这个名字是否可以从表达式包含变量中推断.这样会消除任何对于错误调用栈的猜想.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function foo()&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">const foo = function()&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">// 词法名字和变量引用相互区分</span><br><span class="line">const short = function longUniqueMoreDescriptivelLexicalFoo(</span><br><span class="line">    \\ ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>7.2 用圆括号将立即执行函数表达式包含. eslint: wrap-iife  </p>
<blockquote>
<p>为什么? 一个立即执行函数表达式是一个单独的单元加上执行双括号都用空号包裹起来，干净的表达. 值的注意的是在一个拥有module的世界里，你几乎不需要立即执行表达式</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// immediately-invoked function expression (IIFE)</span><br><span class="line">(function () &#123;</span><br><span class="line">console.log(&#x27;Welcome to the Internet. Please follow me.&#x27;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>7.3 永远不要在非函数块级(if,while等)声明一个函数,而是将函数赋值给一个变量.浏览器允许你这样做,但是它们表现并不一致,这是很难接受的. eslint: no-loop-func</p>
</li>
<li><p>7.4 注意：ECMA-262将块定义为一些列的声明(satetments).一个函数声明(declaration)不是这种声明(statement)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if(currentUser)&#123;</span><br><span class="line">    function test()&#123;</span><br><span class="line">        console.log(&#x27;Nope.&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">let test;</span><br><span class="line">if(currentUser)&#123;</span><br><span class="line">    test = ()=&gt;&#123;</span><br><span class="line">        console.log(&#x27;Yup.&#x27;)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.5 不要声明一个arguments函数参数,这样会覆盖函数中原有的arguments对象</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function foo(name, options, arguments) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function foo(name, options, args) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.6 不要使用arguments,最好使用… eslint:prefer-rest-params</p>
<blockquote>
<p>为什么? …是明确指明你想要传入的参数.其次剩余参数是一个真正数组，而不像arguments是一个类数组.</p>
</blockquote>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function concatenateAll()&#123;</span><br><span class="line">    const args = Array.prototype.slice.call(arguments);</span><br><span class="line">    return args.join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function concatenateAll(...args)&#123;</span><br><span class="line">    return args.join(&#x27;&#x27;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.7 使用默认参数语法而不是改变函数的参数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 真正的糟糕</span><br><span class="line">function hanleThings(opts)&#123;</span><br><span class="line">    // 不要改变函数的参数</span><br><span class="line">    // 更加糟糕: 如果opts是falsy这里将会引入一个微妙的bug</span><br><span class="line">    opts = opts || &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// still bad</span><br><span class="line">function hanldeThings(opts)&#123;</span><br><span class="line">    if(opts === void 0)&#123;</span><br><span class="line">        opts = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">function handleThings(opts = &#123;&#125;)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.8 避免默认参数有副作用</p>
<blockquote>
<p>为什么? 这看起来很疑惑</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var b = 1;</span><br><span class="line">// bad</span><br><span class="line">function count(a = b++) &#123;</span><br><span class="line">console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">count();  // 1</span><br><span class="line">count();  // 2</span><br><span class="line">count(3); // 3</span><br><span class="line">count();  // 3</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>7.9 一直讲默认参数放在最后</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function hanleThings(opts = &#123;&#125;, name)&#123;</span><br><span class="line">    // ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function hanleThings(name, opts = &#123;&#125;)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.10 不要使用函数构造函数创建新函数 eslint:no-new-func</p>
<blockquote>
<p>为什么?用这种方式创建函数和使用eval()对字符串求值一样，同样的风险很大.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var add = new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a + b&#x27;);</span><br><span class="line"></span><br><span class="line">// still bad</span><br><span class="line">var subtract = Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a - b&#x27;);</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>7.11 在函数签名间加空格. eslint:sapce-before-function-parent</p>
<blockquote>
<p>为什么? 一致性总是好的,并且在添加或者去掉函数名时不应该去掉空格</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const f = function()&#123;&#125;;</span><br><span class="line">const g = function ()&#123;&#125;;</span><br><span class="line">const h = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const x = function () &#123;&#125;;</span><br><span class="line">const y = function a() &#123;&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>7.13 不要改变(mutate)参数. eslint:no-param-reassign</p>
<blockquote>
<p>为什么? 改变传入参数对象会对原调用者造成意想不到的变量副作用</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad </span><br><span class="line">function f1(obj)&#123;</span><br><span class="line">    obj.key = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">function f2(obj)&#123;</span><br><span class="line">    const key = Object.prototype.hasOwnProperty.call(obj, &#x27;key&#x27;) ? obj.key : 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>7.13 不要对参数再次赋值 eslint: no-param-reassign</p>
<blockquote>
<p>为什么? </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad </span><br><span class="line">function f1(a)&#123;</span><br><span class="line">    a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f2(a)&#123;</span><br><span class="line">    if(!a) &#123; a = 1; &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good f3(a)&#123;</span><br><span class="line">    const b = a || 1;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f4(a = 1)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>7.14 对于可变参数函数使用扩展操作符…</p>
<blockquote>
<p>为什么? 因为简洁,你不需要绑定内容上下文(context),并且你将new和apply结合使用也不容易</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const x = [1, 2, 3, 4, 5];</span><br><span class="line">console.log.apply(console, x);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const x = [1, 2, 3, 4, 5];</span><br><span class="line">console.log(...x);</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">new Date(...[2016, 8, 5]);</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>7.15 对于多行函数签名，和本文档中保持一致</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function foo(bar,</span><br><span class="line">            baz,</span><br><span class="line">            quux) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function foo(</span><br><span class="line">    bar,</span><br><span class="line">    baz,</span><br><span class="line">    quux,</span><br><span class="line">) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">console.log(foo,</span><br><span class="line">    bar,</span><br><span class="line">    baz);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">console.log(</span><br><span class="line">    foo,</span><br><span class="line">    bar,</span><br><span class="line">    baz,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li><p>8.1 当使用匿名函数时(同样传入行内回调函数时)使用箭头函数 eslint: prefer-arrow-callback</p>
<blockquote>
<p>为什么? 箭头函数创建的执行上下文(this)通常是你想要的,并且语法更加简洁</p>
</blockquote>
<blockquote>
<p>什么时候不? 当你有一个足够复杂函数时,你也许该将逻辑移到一个具名函数表达式中.<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad </span><br><span class="line">[1, 2, 3].map(function(x)&#123;</span><br><span class="line">    const y = x + 1;</span><br><span class="line">    return x * y;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">[1, 2, 3].map((x) =&gt; &#123;</span><br><span class="line">    const y = x + 1;</span><br><span class="line">    return x * y;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
<li><p>8.2 如果函数体是一个单行表达式且返回值为一个没有副作用的表达式,这时省略掉括号同时使用隐式返回</p>
<blockquote>
<p>为什么? 语法糖.当多个函数链式调用时可读性高.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad </span><br><span class="line">[1, 2, 3].map(number =&gt;&#123;</span><br><span class="line">    const nextNumber = number + 1;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">[1, 2, 3].map(number =&gt; `A string containing the $&#123;nextNumber&#125;`);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">[1, 2, 3].map((number, index) =&gt; (&#123;</span><br><span class="line">    [index]: number,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">// No implicit return with side effects</span><br><span class="line">function foo(callback) &#123;</span><br><span class="line">    const val = callback();</span><br><span class="line">    if (val === true) &#123;</span><br><span class="line">        // Do something if callback returns true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let bool = false;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">foo(() =&gt; bool = true);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">foo(() =&gt; &#123;</span><br><span class="line">    bool = true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>8.3 当表达式为多行是,使用圆括号包裹起来可读性更好</p>
<blockquote>
<p>为什么? 这样可以明显看出函数从哪里开始和结束</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">[&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call(</span><br><span class="line">        httpMagicObjectWithAVeryLongName,</span><br><span class="line">        httpMethod,</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">[&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;].map(httpMethod =&gt; (</span><br><span class="line">    Object.prototype.hasOwnProperty.call(</span><br><span class="line">        httpMagicObjectWithAVeryLongName,</span><br><span class="line">        httpMethod,</span><br><span class="line">    )</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>8.4 如果箭头函数只有一个参数并且没有大括号就可以不要是有圆括号，将括号省略掉,否则为了清晰和一致性一直将参数放在括号里. 注意:也可以一直将参数放在括号里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">[1, 2, 3].map((x) =&gt; x * x);</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">[1, 2, 3].map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">[1, 2, 3].map(number =&gt; (</span><br><span class="line">  `A long string with the $&#123;number&#125;. It’s so long that we don’t want it to take up space on the .map line!`</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">[1, 2, 3].map( x =&gt; &#123;</span><br><span class="line">    const y = x + 1;</span><br><span class="line">    return x * y;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">[1, 2, 3].map((x) =&gt;&#123;</span><br><span class="line">    const y = x + 1;</span><br><span class="line">    return x * y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>8.5 避免箭头函数(&#x3D;&gt;)和比较符号(&lt;&#x3D;,&gt;&#x3D;)的混淆. eslint: no-confusing-arrow</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const itemHeight = item =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const itemHeight = (item) =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const itemHeight = (item) =&gt; &#123;</span><br><span class="line">  const &#123; height, largeSize, smallSize &#125; = item;</span><br><span class="line">  return height &gt; 256 ? largeSize : smallSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类和构造函数-Classes-amp-Constructors"><a href="#类和构造函数-Classes-amp-Constructors" class="headerlink" title="类和构造函数(Classes &amp; Constructors)"></a>类和构造函数(Classes &amp; Constructors)</h2><ul>
<li><p>9.1 避免直接操作prototype而应该使用class语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//bad </span><br><span class="line">function Queue( contents = [] )&#123;</span><br><span class="line">    this.queue = [...contents];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue.prototype.pop = function()&#123;</span><br><span class="line">    onst value = this.queue[0];</span><br><span class="line">    this.queue.splice(0, 1);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class Queue &#123;</span><br><span class="line">  constructor(contents = []) &#123;</span><br><span class="line">    this.queue = [...contents];</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    const value = this.queue[0];</span><br><span class="line">    this.queue.splice(0, 1);</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>9.2 使用extends来继承</p>
<blockquote>
<p>为什么? 内置的继承方法原型链没有打断instanceof使用</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const inherits = require(&#x27;inherits&#x27;);</span><br><span class="line">function PeekableQueue(contents) &#123;</span><br><span class="line">    Queue.apply(this, contents);</span><br><span class="line">&#125;</span><br><span class="line">inherits(PeekableQueue, Queue);</span><br><span class="line">    PeekableQueue.prototype.peek = function () &#123;</span><br><span class="line">     return this.queue[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class PeekableQueue extends Queue &#123;</span><br><span class="line">    peek() &#123;</span><br><span class="line">        return this.queue[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>9.3 方法返回this来帮助构造方法调用链</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">Jedi.prototype.jump = function () &#123;</span><br><span class="line">    this.jumping = true;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.setHeight = function (height) &#123;</span><br><span class="line">    this.height = height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const luke = new Jedi();</span><br><span class="line">luke.jump(); // =&gt; true</span><br><span class="line">luke.setHeight(20); // =&gt; undefined</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class Jedi &#123;</span><br><span class="line">jump() &#123;</span><br><span class="line">    this.jumping = true;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setHeight(height) &#123;</span><br><span class="line">    this.height = height;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const luke = new Jedi();</span><br><span class="line"></span><br><span class="line">luke.jump()</span><br><span class="line">.setHeight(20);</span><br></pre></td></tr></table></figure></li>
<li><p>9.4 可以写自定义的toString方法，只要保证它能正常工作并且没有副作用.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Jedi &#123;</span><br><span class="line">    constructor(options = &#123;&#125;) &#123;</span><br><span class="line">        this.name = options.name || &#x27;no name&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        return `Jedi - $&#123;this.getName()&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>9.5 如果没有指定构造函数类都有一个默认的构造函数，一个空构造函数或者这个构造函数只是委托父级构造函数，这些都是不必要的。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">class Jedi&#123;</span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">class Reg extends Jedi&#123;</span><br><span class="line">    constructor(...args)&#123;</span><br><span class="line">        super(...args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // good </span><br><span class="line">    class Reg extends Jedi&#123;</span><br><span class="line">        constructor(...args)&#123;</span><br><span class="line">            super(...args);</span><br><span class="line">            this.name = &#x27;Rey&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>9.6 避免使用重复方法名. eslint: bo-dupe-class-members</p>
<blockquote>
<p>为什么? 重复的类方法名，会导致先前声明的类名失效</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">class Foo &#123;</span><br><span class="line">    bar() &#123; return 1; &#125;</span><br><span class="line">    bar() &#123; return 2; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class Foo &#123;</span><br><span class="line">    bar() &#123; return 1; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class Foo &#123;</span><br><span class="line">    bar() &#123; return 2; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块(Modules)"></a>模块(Modules)</h2><ul>
<li><p>10.1 总是使用modules(import&#x2F;export)而不是非标准模块系统</p>
<blockquote>
<p>为什么? moduels是未来，不如现在就使用</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const AirbnbStyleGuide = require(&#x27;./AirbnbStyleGuide&#x27;);</span><br><span class="line">module.exports = AirbnbStyleGuide.es6;</span><br><span class="line"></span><br><span class="line">// ok</span><br><span class="line">import AirbnbStyleGuide from &#x27;./AirbnbStyleGuide&#x27;;</span><br><span class="line">export default AirbnbStyleGuide.es6;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">import &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;;</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>10.2 不要使用通配符imports</p>
<blockquote>
<p>为什么?这可以保证你只有一个default exports(不太理解<del>(≧▽≦)&#x2F;</del>)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import * as AirbnbStyleGuide from &#x27;./AirbnbStyleGuide&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import AirbnbStyleGuide from &#x27;./AirbnbStyleGuide&#x27;;</span><br><span class="line"></span><br><span class="line">10.3 And do not export directly from an import.</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>10.3 不要直接从一个引入导出</p>
<blockquote>
<p>为什么? 保持一致</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">// filename es6.js</span><br><span class="line">export &#123; es6 as default &#125; from &#x27;./AirbnbStyleGuide&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">// filename es6.js</span><br><span class="line">import &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;;</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>10.4 从一个地方引入的都放在同一个地方. eslint：no-duplicate-imports</p>
<blockquote>
<p>为什么? 保存可维护性</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import foo from &#x27;foo&#x27;;</span><br><span class="line">// … some other imports … //</span><br><span class="line">import &#123; named1, named2 &#125; from &#x27;foo&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import foo, &#123; named1, named2 &#125; from &#x27;foo&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import foo, &#123;</span><br><span class="line">named1,</span><br><span class="line">named2,</span><br><span class="line">&#125; from &#x27;foo&#x27;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>10.5 不要导出可以改变的绑定. eslint: import&#x2F;no-mutable-exports</p>
<blockquote>
<p>为什么? 异变(mutation)一般都是要避免的，除非在特殊的情况需要，通常只有constant引用才能被导出.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// let foo = 3;</span><br><span class="line">export &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">const foo = 3;</span><br><span class="line">export &#123; foo &#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>10.6 如果modles里只有一个导出，推荐使用default导出而不是具名导出. eslint:import&#x2F;prefer-default-export.</p>
<blockquote>
<p>为什么? 为了鼓励更多的文件值导出一个模块，这样便于阅读和维护.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad </span><br><span class="line">export function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">export default function foo() &#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>10.7 将所有的import语句放在非import语句前. eslint: import&#x2F;first</p>
<blockquote>
<p>为什么? 既然imports都是会提升的(hosited),就都将他们放在顶部避免一些意外的表现行为.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import foo from &#x27;foo&#x27;;</span><br><span class="line">foo.init();</span><br><span class="line"></span><br><span class="line">import bar from &#x27;bar&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import foo from &#x27;foo&#x27;;</span><br><span class="line">import bar from &#x27;bar&#x27;;</span><br><span class="line"></span><br><span class="line">foo.init();</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>10.8 跨行imports应该缩进，这和跨行数组与对象字面量一样.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import &#123;longNameA, longNameB, longNameC, longNameD, longNameE&#125; from &#x27;path&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import &#123;</span><br><span class="line">longNameA,</span><br><span class="line">longNameB,</span><br><span class="line">longNameC,</span><br><span class="line">longNameD,</span><br><span class="line">longNameE,</span><br><span class="line">&#125; from &#x27;path&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>10.9 不允许webpack的loader语法也在模块的import语句里. eslint: import&#x2F;no-wabpack-loader-syntax</p>
<blockquote>
<p>为什么?为什么不讲这些语法写在webpack.config.js.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import fooSass from &#x27;css!sass!foo.scss&#x27;;</span><br><span class="line">import barCss from &#x27;style!css!bar.css&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import fooSass from &#x27;foo.scss&#x27;;</span><br><span class="line">import barCss from &#x27;bar.css&#x27;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="迭代器和生成器-Iterators-and-Generators"><a href="#迭代器和生成器-Iterators-and-Generators" class="headerlink" title="迭代器和生成器(Iterators and Generators)"></a>迭代器和生成器(Iterators and Generators)</h2><ul>
<li><p>11.1 不要使用迭代器.应该使用高阶函数来代替循环(for-in或者for-of). eslint:no-iterator no-restricted-stntax</p>
<blockquote>
<p>为什么? 这可以强迫我们使用不异变原则(immutable).处理纯函数返回的值相对于有副作用的更容易解释.</p>
</blockquote>
<blockquote>
<p>使用 map()&#x2F; every()&#x2F; filter()&#x2F; find()&#x2F; findIndex()&#x2F; reduce()&#x2F; some()&#x2F;… 来遍历数组,同时使用Object.keys()&#x2F; Object.value()&#x2F; Object.entries()来产生数组让你可以遍历对象.<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">let (let num of numbers)&#123;</span><br><span class="line">    sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum === 15;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">let sum = 0;</span><br><span class="line">numbers.forEach((num) =&gt;&#123;</span><br><span class="line">    sum += num</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum === 15;</span><br><span class="line"></span><br><span class="line">// best(使用函数式强制)</span><br><span class="line">const sum = numbers.reduce((total, num) =&gt; tatal + num, 0);</span><br><span class="line"></span><br><span class="line">sum === 15;</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">const increaseByOne = [];</span><br><span class="line">for(let i = 0; i &lt; numbers.length; i++)&#123;</span><br><span class="line">    increaseByOne.push(numbers[i] + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const increasedByOne = [];</span><br><span class="line">numbers.forEach((num) =&gt;&#123;</span><br><span class="line">    increasedByOne.push(num + 1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// best (保持函数式)</span><br><span class="line">const increasdByOne = numbers.map(num =&gt; num + 1);</span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
<li><p>11.2 目前不要使用迭代器(generators)</p>
<blockquote>
<p>为什么? 它们目前还不能很好的转义到ES5</p>
</blockquote>
</li>
<li><p>11.3 如果你一定要使用迭代器,或者你不赞成我们的建议，请确定函数标识符正确的空格化. eslint: generator-star-spacing</p>
<blockquote>
<p>为什么? function和*两者是同一个概念的关键字, <em>不是来修饰function, function</em>是一个独一无二的构造器，这个构造器和普通的functtion不同.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function * foo() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const bar = function * () &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const baz = function *() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const quux = function*() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function*foo() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function *foo() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// very bad</span><br><span class="line">function</span><br><span class="line">*</span><br><span class="line">foo() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// very bad</span><br><span class="line">const wat = function</span><br><span class="line">*</span><br><span class="line">() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function* foo() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const foo = function* () &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="属性-Properties"><a href="#属性-Properties" class="headerlink" title="属性(Properties)"></a>属性(Properties)</h2><ul>
<li><p>12.1 使用点标记符来获取属性, eslint: dot-notation</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const luke = &#123;</span><br><span class="line">    jedi: true,</span><br><span class="line">    age: 28,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const isJedi = luke[&#x27;jedi&#x27;];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const isJedi = luke.jedi;</span><br></pre></td></tr></table></figure>
</li>
<li><p>12.2 当使用一个变量来访问属性时使用[]</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const luke = &#123;</span><br><span class="line">    jedi: true,</span><br><span class="line">    age: 28,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function getProp(prop) &#123;</span><br><span class="line">    return luke[prop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isJedi = getProp(&#x27;jedi&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>12.3 幂计算使用**, eslint: no-restricted-properties</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const binary = Math.pow(2, 10);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const binary = 2 ** 10;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量(Variables)"></a>变量(Variables)</h2><ul>
<li><p>13.1 声明变量时使用const或let，如果不这样做将可能导致全局变量,一般我们都避免污染全局作用域空间, eslint: no-undef prefer-const</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">superPower = new SuperPower();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const superPower = new SuperPower();</span><br></pre></td></tr></table></figure>
</li>
<li><p>13.2 为每个声明的变量单独使用const或let. eslit: one-var</p>
<blockquote>
<p>为什么? 这样更加容易添加新声明变量,同时你也不用担心;和,的位置写反了,在打断点debugger时更方便分别检查每个变量.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const items = getItems(),</span><br><span class="line">    goSportsTeam = true,</span><br><span class="line">    dragonball = &#x27;z&#x27;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">// (compare to above, and try to spot the mistake)</span><br><span class="line">const items = getItems(),</span><br><span class="line">    goSportsTeam = true;</span><br><span class="line">    dragonball = &#x27;z&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const items = getItems();</span><br><span class="line">const goSportsTeam = true;</span><br><span class="line">const dragonball = &#x27;z&#x27;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>13.3 将你所有的const声明集合在一起写，同样let也是一样</p>
<blockquote>
<p>为什么? 当你想再次赋值时可能更加方便</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">let i, len, dragonball,</span><br><span class="line">    items = getItems(),</span><br><span class="line">    goSportsTeam = true;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">let i;</span><br><span class="line">const items = getItems();</span><br><span class="line">let dragonball;</span><br><span class="line">const goSportsTeam = true;</span><br><span class="line">let len;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const goSportsTeam = true;</span><br><span class="line">const items = getItems();</span><br><span class="line">let dragonball;</span><br><span class="line">let i;</span><br><span class="line">let length;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>13.4 变量在你需要的时候对它们赋值，但是要把它们放在合理的地方</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad 不必要的函数调用</span><br><span class="line">function checkName(hasName)&#123;</span><br><span class="line">    const name = getName();</span><br><span class="line"></span><br><span class="line">    if(hasName === &#x27;test&#x27;)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(name === &#x27;test&#x27;)&#123;</span><br><span class="line">        this.setName(&#x27;&#x27;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">function checkName(hasName) &#123;</span><br><span class="line">    if (hasName === &#x27;test&#x27;)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const name = getName();</span><br><span class="line">    if(name === &#x27;test&#x27;)&#123;</span><br><span class="line">        this.setName(&#x27;&#x27;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>13.5 不要将变量链式赋值. eslint: no-multi-assign</p>
<blockquote>
<p>为什么? 变量链式赋值会造成隐式全局变量</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">(function example()&#123;</span><br><span class="line">    //js 这样解析</span><br><span class="line">    // let a = ( b = ( c = 1 ) );</span><br><span class="line">    //let关键字只用到了a上其余都成为了全局变量</span><br><span class="line">    let a = b = c = 1;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(a); // throws ReferenceError</span><br><span class="line">console.log(b); // 1</span><br><span class="line">console.log(c); // 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">(function example() &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    let b = a;</span><br><span class="line">    let c = a;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(a); // throws ReferenceError</span><br><span class="line">console.log(b); // throws ReferenceError</span><br><span class="line">console.log(c); // throws ReferenceError</span><br><span class="line"></span><br><span class="line">//都是 `const`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>13.6 避免使用一元运算符 eslint: no-plusplus</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line"></span><br><span class="line">const array = [1, 2, 3];</span><br><span class="line">let num = 1;</span><br><span class="line">num++;</span><br><span class="line">--num;</span><br><span class="line"></span><br><span class="line">let sum = 0;</span><br><span class="line">let truthyCount = 0;</span><br><span class="line">for (let i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    let value = array[i];</span><br><span class="line">    sum += value;</span><br><span class="line">    if (value) &#123;</span><br><span class="line">        truthyCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"></span><br><span class="line">const array = [1, 2, 3];</span><br><span class="line">let num = 1;</span><br><span class="line">num += 1;</span><br><span class="line">num -= 1;</span><br><span class="line"></span><br><span class="line">const sum = array.reduce((a, b) =&gt; a + b, 0);</span><br><span class="line">const truthyCount = array.filter(Boolean).length;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="提升-Hoising"><a href="#提升-Hoising" class="headerlink" title="提升(Hoising)"></a>提升(Hoising)</h2><pre><code>* 14.1 var声明变量时在其未赋值就已经提升到当前作用域顶部.但是const和let有一个新的概念暂时性死区(Temporal Dead Zones).同样这就意味着使用typeof不再安全.
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// we know this wouldn’t work (assuming there</span><br><span class="line">// is no notDefined global variable)</span><br><span class="line">function example() &#123;</span><br><span class="line">    console.log(notDefined); // =&gt; throws a ReferenceError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// creating a variable declaration after you</span><br><span class="line">// reference the variable will work due to</span><br><span class="line">// variable hoisting. Note: the assignment</span><br><span class="line">// value of `true` is not hoisted.</span><br><span class="line">function example() &#123;</span><br><span class="line">    console.log(declaredButNotAssigned); // =&gt; undefined</span><br><span class="line">    var declaredButNotAssigned = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// the interpreter is hoisting the variable</span><br><span class="line">// declaration to the top of the scope,</span><br><span class="line">// which means our example could be rewritten as:</span><br><span class="line">function example() &#123;</span><br><span class="line">    let declaredButNotAssigned;</span><br><span class="line">    console.log(declaredButNotAssigned); // =&gt; undefined</span><br><span class="line">    declaredButNotAssigned = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// using const and let</span><br><span class="line">function example() &#123;</span><br><span class="line">    console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError</span><br><span class="line">    console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError</span><br><span class="line">    const declaredButNotAssigned = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><p>14.2 匿名函数表达式只是提升了它们的变量名，但是函数并没有赋值.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function example() &#123;</span><br><span class="line">    console.log(anonymous); // =&gt; undefined</span><br><span class="line"></span><br><span class="line">    anonymous(); // =&gt; TypeError anonymous is not a function</span><br><span class="line"></span><br><span class="line">    var anonymous = function () &#123;</span><br><span class="line">        console.log(&#x27;anonymous function expression&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>14.3 具名函数表达式提升了它们的变量名，童谣函数名和函数也没有提升</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function example() &#123;</span><br><span class="line">    console.log(named); // =&gt; undefined</span><br><span class="line"></span><br><span class="line">    named(); // =&gt; TypeError named is not a function</span><br><span class="line"></span><br><span class="line">    superPower(); // =&gt; ReferenceError superPower is not defined</span><br><span class="line"></span><br><span class="line">    var named = function superPower() &#123;</span><br><span class="line">            console.log(&#x27;Flying&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// the same is true when the function name</span><br><span class="line">// is the same as the variable name.</span><br><span class="line">function example() &#123;</span><br><span class="line">    console.log(named); // =&gt; undefined</span><br><span class="line"></span><br><span class="line">    named(); // =&gt; TypeError named is not a function</span><br><span class="line"></span><br><span class="line">    var named = function named() &#123;</span><br><span class="line">        console.log(&#x27;named&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>14.4 函数声明提升它们名字和函数体</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function example() &#123;</span><br><span class="line">    superPower(); // =&gt; Flying</span><br><span class="line"></span><br><span class="line">    function superPower() &#123;</span><br><span class="line">        console.log(&#x27;Flying&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更多关于这部分的信息 <a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting/">javascript Scoping &amp; Hositing</a> by <a href="http://www.adequatelygood.com/">Ben Cherry</a></p>
</li>
</ul>
<h2 id="比较操作符和相等性-Comparison-Operators-amp-Equality"><a href="#比较操作符和相等性-Comparison-Operators-amp-Equality" class="headerlink" title="比较操作符和相等性(Comparison Operators &amp; Equality)"></a>比较操作符和相等性(Comparison Operators &amp; Equality)</h2><ul>
<li><p>15.1 使用&#x3D;&#x3D;&#x3D;和 !&#x3D;&#x3D; 来代替 &#x3D;&#x3D; 和 ！&#x3D; eslint: eqeqeq</p>
</li>
<li><p>15.2 在条件语句中如if语句对表达式求值时都是用强制类型转换，转换都遵循如下规则:</p>
<ul>
<li>对象类型(Objects)求值为true</li>
<li>Undefiend求值为 false</li>
<li>Null求值为 false</li>
<li>布尔类型(Booleans)求值为布尔的值</li>
<li>数字类型(Numbers)当为+0，-0或NaN求值为false其余都为true</li>
<li>字符串类型(Strings)只有字符串为空字符串’’为false,其余都为true  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ([0] &amp;&amp; []) &#123;</span><br><span class="line">    // true</span><br><span class="line">    // an array (even an empty one) is an object, objects will evaluate to true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>15.3 布尔类型使用简写，其余如strings和numbers必须明确其比较</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if(isValid === true)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if(isValid)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">if(name)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// if(name !== &#x27;&#x27;)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">if(collection.length)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">if(collection.length &gt; 0)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>15.4 更多信息看 <a href="https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108">Truth Equality and javascript</a> by Angus Croll</p>
</li>
<li><p>15.5 对于case和default从句它们如果包含词法声明(eg: let const function calss)使用大括号创建块</p>
<blockquote>
<p>为什么? 词法声明在整个是switch块可见但是只有在赋值的时候初始化(只有当case到达时).这样可能带着多个case从句都尝试定义相当的东西</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">switch (foo) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        let x = 1;</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        const y = 2;</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        function f() &#123;</span><br><span class="line">        // ...</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        class C &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">switch (foo) &#123;</span><br><span class="line">    case 1: &#123;</span><br><span class="line">        let x = 1;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case 2: &#123;</span><br><span class="line">        const y = 2;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case 3: &#123;</span><br><span class="line">        function f() &#123;</span><br><span class="line">        // ...</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case 4:</span><br><span class="line">        bar();</span><br><span class="line">        break;</span><br><span class="line">    default: &#123;</span><br><span class="line">        class C &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>15.6 三元运算符应该保持在一行，不应有使用很混乱 eslint: no-nested-ternary</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const foo = maybe1 &gt; maybe2</span><br><span class="line">    ? &quot;bar&quot;</span><br><span class="line">    : value1 &gt; value2 ? &quot;baz&quot; : null;</span><br><span class="line"></span><br><span class="line">// split into 2 separated ternary expressions</span><br><span class="line">const maybeNull = value1 &gt; value2 ? &#x27;baz&#x27; : null;</span><br><span class="line"></span><br><span class="line">// better</span><br><span class="line">const foo = maybe1 &gt; maybe2</span><br><span class="line">    ? &#x27;bar&#x27;</span><br><span class="line">    : maybeNull;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">const foo = maybe1 &gt; maybe2 ? &#x27;bar&#x27; : maybeNull;</span><br></pre></td></tr></table></figure>
</li>
<li><p>15.7 避免不必要的三元语句. eslint: no-unneeded-ternary</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const foo = a ? a : b;</span><br><span class="line">const bar = c ? true : false;</span><br><span class="line">const baz = c ? false : true;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const foo = a || b;</span><br><span class="line">const bar = !!c;</span><br><span class="line">const baz = !c</span><br></pre></td></tr></table></figure>
</li>
<li><p>15.8 当多个操作符混合在一个语句中使用圆括号将包裹起来，当有混合数学操作符不要将*<em>与%或者+-</em>&amp;&#x2F;之间混合 eslint: no-mixed-operators</p>
<blockquote>
<p>为什么?这样改善了可读性并且澄清了开发者的意图</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const bar = a ** b - 5 % d;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">if (a || b &amp;&amp; c) &#123;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const bar = (a ** b) - (5 % d);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if ((a || b) &amp;&amp; c) &#123;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const bar = a + b / c * d;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>块(Blocks)</p>
</li>
<li><p>16.1 对所用的多行块使用大括号 eslint: nonblock-statement-body-position</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (test)</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (test) return false;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (test) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function foo() &#123; return false; &#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function bar() &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>16.2 在多行if-else中else放在if结束括号后 eslint:brace-style</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (test) &#123;</span><br><span class="line">    thing1();</span><br><span class="line">    thing2();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    thing3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (test) &#123;</span><br><span class="line">    thing1();</span><br><span class="line">    thing2();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    thing3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>16.3 如果if语句里有return语句,接下来的else块是不必要的. eslint: no-else-return</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function foo() &#123;</span><br><span class="line">    if (x) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function cats() &#123;</span><br><span class="line">    if (x) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else if (y) &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function dogs() &#123;</span><br><span class="line">    if (x) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (y) &#123;</span><br><span class="line">        return y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function foo() &#123;</span><br><span class="line">    if (x) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function cats() &#123;</span><br><span class="line">    if (x) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (y) &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//good</span><br><span class="line">function dogs(x) &#123;</span><br><span class="line">    if (x) &#123;</span><br><span class="line">        if (z) &#123;</span><br><span class="line">        return y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="控制语句-Control-Statements"><a href="#控制语句-Control-Statements" class="headerlink" title="控制语句(Control Statements)"></a>控制语句(Control Statements)</h2><ul>
<li>17.1 在控制语句中如果太长或者超过了一行的最大长度，将每个（汇合）条件放在一个新行.逻辑运算符应该在行的开头(译者注：这个我自己放在行尾)<blockquote>
<p>为什么?要求操作符放在每行的开始，这是为了和方法链调用方式保持一致和对齐.同样这也提高了可读性</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if ((foo === 123 || bar === &#x27;abc&#x27;) &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123;</span><br><span class="line">    thing1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">if (foo === 123 &amp;&amp;</span><br><span class="line">bar === &#x27;abc&#x27;) &#123;</span><br><span class="line">    thing1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">if (foo === 123</span><br><span class="line">&amp;&amp; bar === &#x27;abc&#x27;) &#123;</span><br><span class="line">    thing1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">if (</span><br><span class="line">foo === 123 &amp;&amp;</span><br><span class="line">bar === &#x27;abc&#x27;</span><br><span class="line">) &#123;</span><br><span class="line">    thing1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (</span><br><span class="line">foo === 123</span><br><span class="line">&amp;&amp; bar === &#x27;abc&#x27;</span><br><span class="line">) &#123;</span><br><span class="line">    thing1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (</span><br><span class="line">(foo === 123 || bar === &quot;abc&quot;)</span><br><span class="line">&amp;&amp; doesItLookGoodWhenItBecomesThatLong()</span><br><span class="line">&amp;&amp; isThisReallyHappening()</span><br><span class="line">) &#123;</span><br><span class="line">    thing1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (foo === 123 &amp;&amp; bar === &#x27;abc&#x27;) &#123;</span><br><span class="line">    thing1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释(Comments)"></a>注释(Comments)</h2><ul>
<li><p>18.1 对于多行注释使用 &#x2F;** … *&#x2F;</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">// make() returns a new element</span><br><span class="line">// based on the passed in tag name</span><br><span class="line">//</span><br><span class="line">// @param &#123;String&#125; tag</span><br><span class="line">// @return &#123;Element&#125; element</span><br><span class="line">function make(tag) &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">/**</span><br><span class="line">* make() returns a new element</span><br><span class="line">* based on the passed-in tag name</span><br><span class="line">*/</span><br><span class="line">function make(tag) &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>18.2 对于单行注释使用&#x2F;&#x2F;,将单行注释放在新一行的上面，并且在单行注释前加一个空行除非这个注释在块级的头部</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const active = true; // is current tab</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">// is current tab</span><br><span class="line">const active = true</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function getType() &#123;</span><br><span class="line">    console.log(&#x27;fetching type...&#x27;);</span><br><span class="line">    // set the default type to &#x27;no type&#x27;</span><br><span class="line">    const type = this.type || &#x27;no type&#x27;;</span><br><span class="line"></span><br><span class="line">    return type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function getType() &#123;</span><br><span class="line">    console.log(&#x27;fetching type...&#x27;);</span><br><span class="line"></span><br><span class="line">    // set the default type to &#x27;no type&#x27;</span><br><span class="line">    const type = this.type || &#x27;no type&#x27;;</span><br><span class="line"></span><br><span class="line">    return type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// also good</span><br><span class="line">function getType() &#123;</span><br><span class="line">    // set the default type to &#x27;no type&#x27;</span><br><span class="line">    const type = this.type || &#x27;no type&#x27;;</span><br><span class="line"></span><br><span class="line">    return type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>18.3 在所有的注释前都加一个空格这样更易阅读. eslint: spaced-comment</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">//is current tab</span><br><span class="line">const active = true;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">// is current tab</span><br><span class="line">const active = true;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">/**</span><br><span class="line">*make() returns a new element</span><br><span class="line">*based on the passed-in tag name</span><br><span class="line">*/</span><br><span class="line">function make(tag) &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">/**</span><br><span class="line">* make() returns a new element</span><br><span class="line">* based on the passed-in tag name</span><br><span class="line">*/</span><br><span class="line">function make(tag) &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>18.4 在注释前加一个FIXME 或者 TODO 来帮助其他开发者迅速的定位问题，或者你建议一个解决方案将要实施. 它们都不同于普通的注释因为它们是可实施的. FIXME：这个动作需要理清，TODOL：需要实施</p>
</li>
<li><p>18.5 用 &#x2F;&#x2F; FIXME: 来标明问题</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Calculator extends Abacus &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line"></span><br><span class="line">        // FIXME: 这里不应该有全局变量</span><br><span class="line">        total = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>18.6 使用&#x2F;&#x2F; TODO: 来标明解决问的方案</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Calculator extends Abacus &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line"></span><br><span class="line">        // TODO: total应该通过一个选项参数配置</span><br><span class="line">        this.total = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h2><ul>
<li><p>19.1 使用软tabs(空格键)来设置2个空格 eslint: indent</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function foo() &#123;</span><br><span class="line">....let name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function foo() &#123;</span><br><span class="line">.let name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">function baz() &#123;</span><br><span class="line">..let name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.2 在大括号之前使用一个空格 eslint: space-before-blocks</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function test()&#123;</span><br><span class="line">    console.log(&#x27;test&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">funtcion test() &#123;</span><br><span class="line">    console.log(&#x27;test&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">dog.set(&#x27;attr&#x27;,&#123;</span><br><span class="line">    age: &#x27;1 year&#x27;,</span><br><span class="line">    breed: &#x27;Bernese Mountain Dog&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">dog.set(&#x27;attr&#x27;, &#123;</span><br><span class="line">    age: &#x27;1 year&#x27;,</span><br><span class="line">    breed: &#x27;Bernese Mountain Dog&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.3 在控制语句中(if,while)的开始圆括号前加一个空格，而在参数列和函数声明与调用不加空格. eslint: keyword-spaceing</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if(isJedi) &#123;</span><br><span class="line">    fight ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (isJedi) &#123;</span><br><span class="line">    fight();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function fight () &#123;</span><br><span class="line">    console.log (&#x27;Swoosh!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function fight() &#123;</span><br><span class="line">    console.log(&#x27;Swoosh!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.4 在操作符前加空格. eslint: space-infix-ops</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const x=y+4;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const x = x + 5;</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.5 在文件结束处加一个换行符. eslint:eol-last</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;;</span><br><span class="line">// ...</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;;</span><br><span class="line">// ...</span><br><span class="line">export default es6;↵</span><br><span class="line">↵</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// good</span><br><span class="line">import &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;;</span><br><span class="line">// ...</span><br><span class="line">export default es6;↵</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.6 当方法调用很长时(超过两个方法调用链)使用缩减.开头出使用点调用，这意味着这行是方法调用，相反的是新的语句不用 eslint: newline-per-chained-call no-whitespace-before-property</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">$(&#x27;#items&#x27;).find(&#x27;.selected&#x27;).highlight().end().find(&#x27;.open&#x27;).updateCount();</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">$(&#x27;#items&#x27;).</span><br><span class="line">    find(&#x27;.selected&#x27;).</span><br><span class="line">        highlight().</span><br><span class="line">        end().</span><br><span class="line">    find(&#x27;.open&#x27;).</span><br><span class="line">        updateCount();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">$(&#x27;#items&#x27;)</span><br><span class="line">    .find(&#x27;.selected&#x27;)</span><br><span class="line">        .heighLight()</span><br><span class="line">        .end()</span><br><span class="line">    .find(&#x27;.open&#x27;)</span><br><span class="line">        .undateCount();</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const leds = stage.selectAll(&#x27;.led&#x27;).data(data).enter().append(&#x27;svg:svg&#x27;).classed(&#x27;led&#x27;, true)</span><br><span class="line">    .attr(&#x27;width&#x27;, (radius + margin) * 2).append(&#x27;svg:g&#x27;)</span><br><span class="line">    .attr(&#x27;transform&#x27;, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)</span><br><span class="line">    .call(tron.led);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const leds = stage.selectAll(&#x27;.led&#x27;)</span><br><span class="line">    .data(data)</span><br><span class="line">.enter().append(&#x27;svg:svg&#x27;)</span><br><span class="line">    .classed(&#x27;led&#x27;, true)</span><br><span class="line">    .attr(&#x27;width&#x27;, (radius + margin) * 2)</span><br><span class="line">.append(&#x27;svg:g&#x27;)</span><br><span class="line">    .attr(&#x27;transform&#x27;, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)</span><br><span class="line">    .call(tron.led);    </span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const leds = stage.selectAll(&#x27;.led&#x27;).data(data);    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>19.7 在每个块级结束之后新语句开始之前留一个空包行</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (foo) &#123;</span><br><span class="line">    return bar;</span><br><span class="line">&#125;</span><br><span class="line">return baz;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (foo) &#123;</span><br><span class="line">    return bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return baz;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const obj = &#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    bar() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">return obj;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const obj = &#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    bar() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">return obj;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const arr = [</span><br><span class="line">    function foo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    function foo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line">return arr;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">const arr = [</span><br><span class="line">    function foo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    function bar() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">return arr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.8 不要在新的块头部加空白行</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function bar() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(foo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">if (baz) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(qux);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">class Foo &#123;</span><br><span class="line"></span><br><span class="line">    constructor(bar) &#123;</span><br><span class="line">        this.bar = bar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (baz) &#123;</span><br><span class="line">    console.log(qux);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.9 不要在圆括号里加额外的空格 eslint: space-in-parens</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function bar( foo ) &#123;</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function bar(foo) &#123;</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">if ( foo ) &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (foo) &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>19.10 不要在方括号里加空格 eslint:array-bracket-spacing</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const foo = [ 1, 2, 3 ];</span><br><span class="line">console.log(foo[ 0 ]);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const foo = [1, 2, 3];</span><br><span class="line">console.log(foo[0]);</span><br></pre></td></tr></table></figure></li>
<li><p>19.11 在大括号里加空格 eslint: object-curly-spacing</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const foo = &#123;clark: &#x27;kent&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const foo = &#123; clark: &#x27;kent&#x27; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>19.12 避免每一行的代码超过100个字符(包括空格). 注意: 上面的长字符串(6.2)是这个规则的例外,其余的都不应该破坏这条规则. eslint： max-len</p>
<blockquote>
<p>为什么? 这样确保可读性和可维护性</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">$.ajax(&#123; method: &#x27;POST&#x27;, url: &#x27;https://airbnb.com/&#x27;, data: &#123; name: &#x27;John&#x27; &#125; &#125;).done(() =&gt; console.log(&#x27;Congratulations!&#x27;)).fail(() =&gt; console.log(&#x27;You have failed this city.&#x27;));</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const foo = jsonData</span><br><span class="line">    &amp;&amp; jsonData.foo</span><br><span class="line">    &amp;&amp; jsonData.foo.bar</span><br><span class="line">    &amp;&amp; jsonData.foo.bar.baz</span><br><span class="line">    &amp;&amp; jsonData.foo.bar.baz.quux</span><br><span class="line">    &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    method: &#x27;POST&#x27;,</span><br><span class="line">    url: &#x27;https://airbnb.com/&#x27;,</span><br><span class="line">    data: &#123; name: &#x27;John&#x27; &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">    .done(() =&gt; console.log(&#x27;Congratulations!&#x27;))</span><br><span class="line">    .fail(() =&gt; console.log(&#x27;You have failed this city.&#x27;));</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="逗号-Commas"><a href="#逗号-Commas" class="headerlink" title="逗号(Commas)"></a>逗号(Commas)</h2><ul>
<li><p>20.1 不可以以逗号开头. eslint: comma-style</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const story = [</span><br><span class="line">    once</span><br><span class="line">    , upon</span><br><span class="line">    , aTime</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const story = [</span><br><span class="line">    once,</span><br><span class="line">    upon,</span><br><span class="line">    aTime,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const hero = &#123;</span><br><span class="line">    firstName: &#x27;Ada&#x27;</span><br><span class="line">    , lastName: &#x27;Lovelace&#x27;</span><br><span class="line">    , birthYear: 1815</span><br><span class="line">    , superPower: &#x27;computers&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const hero = &#123;</span><br><span class="line">    firstName: &#x27;Ada&#x27;,</span><br><span class="line">    lastName: &#x27;Lovelace&#x27;,</span><br><span class="line">    birthYear: 1815,</span><br><span class="line">    superPower: &#x27;computers&#x27;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>20.2 添加尾逗号. eslint: comma-dangle</p>
<blockquote>
<p>为什么?(译者：个人不太稀饭) 这对于git diffs更加整洁,同时向Babel这个样的编译器会在编译的时候去掉尾逗号，这就意味着在合法的浏览器中你不用担心<a href="https://github.com/airbnb/javascript/blob/es5-deprecated/es5/README.md#commas">尾逗号问题</a></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad - git diff without trailing comma</span><br><span class="line">const hero = &#123;</span><br><span class="line">    firstName: &#x27;Florence&#x27;,</span><br><span class="line">-    lastName: &#x27;Nightingale&#x27;</span><br><span class="line">+    lastName: &#x27;Nightingale&#x27;,</span><br><span class="line">+    inventorOf: [&#x27;coxcomb chart&#x27;, &#x27;modern nursing&#x27;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good - git diff with trailing comma</span><br><span class="line">const hero = &#123;</span><br><span class="line">    firstName: &#x27;Florence&#x27;,</span><br><span class="line">    lastName: &#x27;Nightingale&#x27;,</span><br><span class="line">+    inventorOf: [&#x27;coxcomb chart&#x27;, &#x27;modern nursing&#x27;],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const hero = &#123;</span><br><span class="line">    firstName: &#x27;Dana&#x27;,</span><br><span class="line">    lastName: &#x27;Scully&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const heroes = [</span><br><span class="line">    &#x27;Batman&#x27;,</span><br><span class="line">    &#x27;Superman&#x27;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const hero = &#123;</span><br><span class="line">    firstName: &#x27;Dana&#x27;,</span><br><span class="line">    lastName: &#x27;Scully&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const heroes = [</span><br><span class="line">    &#x27;Batman&#x27;,</span><br><span class="line">    &#x27;Superman&#x27;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function createHero(</span><br><span class="line">    firstName,</span><br><span class="line">    lastName,</span><br><span class="line">    inventorOf</span><br><span class="line">) &#123;</span><br><span class="line">// does nothing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function createHero(</span><br><span class="line">    firstName,</span><br><span class="line">    lastName,</span><br><span class="line">    inventorOf,</span><br><span class="line">) &#123;</span><br><span class="line">    // does nothing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good (注意逗号不能在&quot;rest&quot;元素后)</span><br><span class="line">function createHear(</span><br><span class="line">    frstName,</span><br><span class="line">    lastName.</span><br><span class="line">    inventorOf,</span><br><span class="line">    ...heroArs</span><br><span class="line">) &#123;</span><br><span class="line">    // does nothing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">createHero(</span><br><span class="line">    firstName,</span><br><span class="line">    lastName,</span><br><span class="line">    inventorOf</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">createHero(</span><br><span class="line">    firstName,</span><br><span class="line">    lastName,</span><br><span class="line">    inventorOf,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// good (note that a comma must not appear after a &quot;rest&quot; element)</span><br><span class="line">createHero(</span><br><span class="line">    firstName,</span><br><span class="line">    lastName,</span><br><span class="line">    inventorOf,</span><br><span class="line">    ...heroArgs</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分号-Semicolons"><a href="#分号-Semicolons" class="headerlink" title="分号(Semicolons)"></a>分号(Semicolons)</h2><ul>
<li>21.1 是滴 eslint: semi  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">(function () &#123;</span><br><span class="line">    const name = &#x27;Skywalker&#x27;</span><br><span class="line">    return name</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">(function () &#123;</span><br><span class="line">    const name = &#x27;Skywalker&#x27;;</span><br><span class="line">    return name;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// good, but legacy (guards against the function becoming an argument when two files with IIFEs are concatenated)</span><br><span class="line">;((() =&gt; &#123;</span><br><span class="line">    const name = &#x27;Skywalker&#x27;;</span><br><span class="line">    return name;</span><br><span class="line">&#125;)());</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类型转换和强制类型转换-Type-Casting-amp-Coercion"><a href="#类型转换和强制类型转换-Type-Casting-amp-Coercion" class="headerlink" title="类型转换和强制类型转换(Type Casting &amp; Coercion)"></a>类型转换和强制类型转换(Type Casting &amp; Coercion)</h2><ul>
<li><p>22.1 在语句的开头执行强制类型转化</p>
</li>
<li><p>22.2 字符串：eslint: no-new-wrappers</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// =&gt; this.reviewScore = 9;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const totalScore = new String(this.reviewScore); // typeof totalScore 是&quot;object&quot;而不是&quot;string&quot;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const totalScore = this.reviewSore + &#x27;&#x27;; // 会触发this.reviewScore.valueOf()</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">const totalScore = this.reviewScore.toStirng();// 不能保证是返回一个字符串,这个方法有可能被覆盖掉</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const totalScore = String(this.reviewScore)</span><br></pre></td></tr></table></figure>
</li>
<li><p>22.3 数字：使用Number来类型转换，使用parseInt总是需要一个基数(radix) eslint: redix no-new-wrappers</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const inputValue = &#x27;4&#x27;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const val = new Number(inputValue);</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const val = inputValue &gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">// bad </span><br><span class="line">const val = parseInt(inputValue);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const val = Number(inputValue);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const val = parseInt(inputValue, 10);</span><br></pre></td></tr></table></figure>
</li>
<li><p>22.4 如果你因为某种原因而做一些疯狂事parseInt不能满足你的性能要求你需要使用位运算，写一些注释来解释为什么你这样做.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// good</span><br><span class="line">/**</span><br><span class="line">* parseInt是我这段代码慢的原因</span><br><span class="line">* 位运算可以解决这个问题</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const val = inputValue &gt;&gt; 0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>22.5 注意：使用位运算操作符时，运算前数字代表的是64位的值，但是位运算后返回的是一个32位的整数(<a href="https://es5.github.io/#x11.7">source</a>),位运算对于超过32位的整数可以引起不可预料的表现行为.最大的32位整数2,147,483,647:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2147483647 &gt;&gt; 0; // =&gt; 2147483647</span><br><span class="line">2147483648 &gt;&gt; 0; // =&gt; -2147483648</span><br><span class="line">2147483649 &gt;&gt; 0; // =&gt; -2147483647</span><br></pre></td></tr></table></figure>
</li>
<li><p>22.6 布尔： eslint: no-new-wrappers</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const age = 0;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const hasAge = new Boolean(age);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const hasAge = Boolean(age);</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">const hasAge = !!age;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="命名习俗-Naming-Conventions"><a href="#命名习俗-Naming-Conventions" class="headerlink" title="命名习俗 (Naming Conventions)"></a>命名习俗 (Naming Conventions)</h2><ul>
<li><p>23.1 避免单个字母命名，使用描述性命名. eslint: id-length</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function q() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function query() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>23.2 使用驼峰命名：对象,函数,实例. eslint: camelcase</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const OBJEcttsssss = &#123;&#125;;</span><br><span class="line">const this_is_my_object = &#123;&#125;;</span><br><span class="line">function c() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const thisIsMyObject = &#123;&#125;;</span><br><span class="line">function thisIsMyFunction() &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>23.3 在命名构造函数或者类时使用 首字母大写  eslint: new-cap</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function user(options) &#123;</span><br><span class="line">    this.name = options.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bad = new user(&#123;</span><br><span class="line">    name: &#x27;nope&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class User &#123;</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this.name = options.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const good = new User(&#123;</span><br><span class="line">    name: &#x27;yup&#x27;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>23.4 不要在头尾使用下划线. eslint: no-underscore-dangle</p>
<blockquote>
<p>为什么? js对于属性或者方法都没有私有的概念，虽然前置下划线按习俗来讲是一个私有的(private).事实上,这些带下划线的属性是完全公开的,并且存在于你的公共API接口中，这个习俗让开发者错误的认为一点改变不会是破坏，或者不需要测试，如果你想要某些东西真的私有(“private”),你必须让他不可以观察的呈现.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">this.__firstName__ = &#x27;Panda&#x27;;</span><br><span class="line">this.firstName_ = &#x27;Panda&#x27;;</span><br><span class="line">this._firstName = &#x27;Panda&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">this.firstName = &#x27;Panda&#x27;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>23.5 希望不要保存this引用.与之代替的是使用箭头函数或者函数绑定</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function foo() &#123;</span><br><span class="line">    const self = this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        console.log(self);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function foo() &#123;</span><br><span class="line">    const that = this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        console.log(that);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function foo() &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>23.6 一个基本文件名应该和默认导出(default export)相匹配</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // file 1 contents</span><br><span class="line">class CheckBox &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">export default CheckBox;</span><br><span class="line"></span><br><span class="line">// file 2 contents</span><br><span class="line">export default function fortyTwo() &#123; return 42; &#125;</span><br><span class="line"></span><br><span class="line">// file 3 contents</span><br><span class="line">export default function insideDirectory() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// in some other file</span><br><span class="line">// bad</span><br><span class="line">import CheckBox from &#x27;./checkBox&#x27;; // PascalCase import/export, camelCase filename</span><br><span class="line">import FortyTwo from &#x27;./FortyTwo&#x27;; // PascalCase import/filename, camelCase export</span><br><span class="line">import InsideDirectory from &#x27;./InsideDirectory&#x27;; // PascalCase import/filename, camelCase export</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">import CheckBox from &#x27;./check_box&#x27;; // PascalCase import/export, snake_case filename</span><br><span class="line">import forty_two from &#x27;./forty_two&#x27;; // snake_case import/filename, camelCase export</span><br><span class="line">import inside_directory from &#x27;./inside_directory&#x27;; // snake_case import, camelCase export</span><br><span class="line">import index from &#x27;./inside_directory/index&#x27;; // requiring the index file explicitly</span><br><span class="line">import insideDirectory from &#x27;./insideDirectory/index&#x27;; // requiring the index file explicitly</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import CheckBox from &#x27;./CheckBox&#x27;; // PascalCase export/import/filename</span><br><span class="line">import fortyTwo from &#x27;./fortyTwo&#x27;; // camelCase export/import/filename</span><br><span class="line">import insideDirectory from &#x27;./insideDirectory&#x27;; // camelCase export/import/directory name/implicit &quot;index&quot;</span><br><span class="line">// ^ supports both insideDirectory.js and insideDirectory/index.js   </span><br></pre></td></tr></table></figure>
</li>
<li><p>23.7 当默认导出一个函数使用驼峰法命名,你文件名称应该和你函数名保存一致</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function makeStyleGuide() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default makeStyleGuide;</span><br></pre></td></tr></table></figure>
</li>
<li><p>23.8 当你导出一个contructor&#x2F; class&#x2F;函数库&#x2F;单独的对象 使用首PascalCase</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const AirbnbStyleGuide = &#123;</span><br><span class="line">    es6: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default AirbnbStyleGuide;</span><br></pre></td></tr></table></figure></li>
<li><p>23.9 缩写是也应该首字母大写，其余全为小写</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">import SmsContainer from &#x27;./containers/SmsContainer&#x27;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const HttpRequests = [</span><br><span class="line">    // ...</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import SMSContainer from &#x27;./containers/SMSContainer&#x27;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const HTTPRequests = [</span><br><span class="line">    // ...</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// also good</span><br><span class="line">const httpRequests = [</span><br><span class="line">// ...</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">import TextMessageContainer from &#x27;./containers/TextMessageContainer&#x27;;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">const requests = [</span><br><span class="line">    // ...</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="存取器-存取器"><a href="#存取器-存取器" class="headerlink" title="存取器(存取器)"></a>存取器(存取器)</h2><ul>
<li><p>24.1 对于属性存取器函数不是必要的</p>
</li>
<li><p>24.2 不要使用js的getters&#x2F;setters因为它们会引起不可预期的副作用并且难于测试和维护，和推理. 如果你一定要使用存取函数使用getVal()和setVal(‘hello’)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">class Dragon &#123;</span><br><span class="line">    get age() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set age(value) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class Dragon &#123;</span><br><span class="line">    getAge() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setAge(value)&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>24.3 如果属性或方法是boolean,使用isVal()或者hasVal()</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">if(!dragon.age()) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if(!dragon.hasAge())&#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>24.4 可以创建get()和set()函数，但是得保持一致</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Jedi &#123;</span><br><span class="line">    constructor(options = &#123;&#125;) &#123;</span><br><span class="line">        const lightsaber = options.lightsaber || &#x27;blue&#x27;;</span><br><span class="line">        this.set(&#x27;lightsaber&#x27;, lightsaber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set(key, val) &#123;</span><br><span class="line">        this[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get(key) &#123;</span><br><span class="line">        return this[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="事件-Events"><a href="#事件-Events" class="headerlink" title="事件(Events)"></a>事件(Events)</h2><ul>
<li>25.1 当添加数据加载到事件中(原生或者自定义),传入一个哈希值而不是原始数据,这样可以让后来的开发者添加更多数据到事件中时不要先找到或更新每个handler,也就是让传入参数更加灵活.如下：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">$(this).trigger(&#x27;listingUpdated&#x27;, listing.id);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">$(this).on(&#x27;listingUpdated&#x27;, (e, listingId) =&gt; &#123;</span><br><span class="line">    // do something with listingId</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">$(this).trigger(&#x27;listingUpdated&#x27;, &#123; listingId: listing.id &#125;);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">$(this).on(&#x27;listingUpdated&#x27;, (e, data) =&gt; &#123;</span><br><span class="line">    // do something with data.listingId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><ul>
<li><p>26.1 对每个jQuery对象变量都加个前缀$  jscs: requireDollarBeforejQueryAssignment</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">const sidebar = $(&#x27;.sidebar&#x27;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const $sidebar = $(&#x27;.sidebar&#x27;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const $sidebarBtn = $(&#x27;.sidebar-btn&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>26.2 缓存jquery对象</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">function setSidebar() &#123;</span><br><span class="line">    $(&#x27;.sidebar&#x27;).hide();</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    $(&#x27;.sidebar&#x27;).css(&#123;</span><br><span class="line">        &#x27;background-color&#x27;: &#x27;pink&#x27;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function setSidebar() &#123;</span><br><span class="line">    const $sidebar = $(&#x27;.sidebar&#x27;);</span><br><span class="line">    $sidebar.hide();</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    $sidebar.css(&#123;</span><br><span class="line">        &#x27;background-color&#x27;: &#x27;pink&#x27;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>26.3 对于DOM查询使用垂直查询$(‘.sidebar ul’) 或者&gt;  $(‘.sidebar &gt; ul’)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">$(&#x27;ul&#x27;, &#x27;.sidebar&#x27;).hide();</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">$(&#x27;.sidebar&#x27;).find(&#x27;ul&#x27;).hide();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">$(&#x27;.sidebar ul&#x27;).hide();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">$(&#x27;.sidebar &gt; ul&#x27;).hide();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">$sidebar.find(&#x27;ul&#x27;).hide();</span><br></pre></td></tr></table></figure>
</li>
<li><p>原文<img src="https://github.com/airbnb/javascript#arrow-functions" alt="Airbnb JavaScript Style Guide"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>javscript代码规范</category>
      </categories>
  </entry>
  <entry>
    <title>es6类与继承语法要点</title>
    <url>/2017/11/08/es6%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h2 id="es6类"><a href="#es6类" class="headerlink" title="es6类"></a>es6类</h2><h3 id="es6类与es5类对比"><a href="#es6类与es5类对比" class="headerlink" title="es6类与es5类对比"></a>es6类与es5类对比</h3><p>es6和es5的类声明很相似但是也有很多区别：</p>
<ul>
<li>1 es6类声明是没有变量提升和不能重复声明和let一样，也是就说在执行没到达声明前不可以使用</li>
<li>2 es6类声明中所有代码自动在严格模式下执行</li>
<li>3 es6类声明中的所用的方法都是不可枚举的，在es5中可以使用Object.defineProperty实现</li>
<li>4 es6类声明中的所有的方法都缺失内部[[Construct]]属性，也就是说不能当做构造函数使用</li>
<li>5 es6类必须使用new调用，否则报错</li>
<li>6 不能在es6类声明中修改类名</li>
<li>7 es6明确声明class内部只能有静态方法，没有静态属性<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//es6 class</span><br><span class="line">class PersonType &#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static sayClassName()&#123;</span><br><span class="line">        console.log(this.name);// PersonType</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PersonType.family = &quot;chen&quot;;</span><br><span class="line"></span><br><span class="line">// es5 calss(大部分是es5)</span><br><span class="line">let personType = (function()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">    // 确保函数是使用new调用的</span><br><span class="line">    const PersonType = function(name)&#123;</span><br><span class="line">        if(typeof new.target === &quot;undefined&quot;)&#123;</span><br><span class="line">            throw new Error(&quot;构造函数必须使用new调用&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Object.defineProperty(PersonType,&quot;sayClassName&quot;,&#123;</span><br><span class="line">        value: function()&#123;</span><br><span class="line">            // 确保原型上的方法不是被new调用</span><br><span class="line">            if(typeof new.target !== &quot;undefined&quot;)&#123;</span><br><span class="line">                throw new Error(&quot;Method cannot be called with new.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            console.log(this.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    PersonType.family = &quot;chen&quot;;</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(PersonType.prototype,&quot;sayName&quot;,&#123;</span><br><span class="line">        value: function()&#123;</span><br><span class="line">            // 确保原型上的方法不是被new调用</span><br><span class="line">            if(typeof new.target !== &quot;undefined&quot;)&#123;</span><br><span class="line">                throw new Error(&quot;Method cannot be called with new.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            console.log(this.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return PersonType</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="es6的一些新应用"><a href="#es6的一些新应用" class="headerlink" title="es6的一些新应用"></a>es6的一些新应用</h3><p>私有方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const sayName = Symbol(&#x27;sayName&#x27;);</span><br><span class="line"></span><br><span class="line">export default class personType&#123;</span><br><span class="line">    // 共有方法</span><br><span class="line">    sayAge()&#123;</span><br><span class="line">        console.log(&#x27;18岁&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 私有方法</span><br><span class="line">    [sayName]()&#123;</span><br><span class="line">        console.log(&#x27;tianyu&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存取函数：实现拦截该属性的存取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// es5</span><br><span class="line">let CustomHTMLElement = (function() &#123;</span><br><span class="line"></span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">    const CustomHTMLElement = function(element) &#123;</span><br><span class="line"></span><br><span class="line">        // 确保函数是被new调用</span><br><span class="line">        if (typeof new.target === &quot;undefined&quot;) &#123;</span><br><span class="line">            throw new Error(&quot;Constructor must be called with new.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.element = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(CustomHTMLElement.prototype, &quot;html&quot;, &#123;</span><br><span class="line">        enumerable: false,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            return this.element.innerHTML;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(value) &#123;</span><br><span class="line">            this.element.innerHTML = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return CustomHTMLElement;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// es6</span><br><span class="line">class CustomHTMLElement &#123;</span><br><span class="line"></span><br><span class="line">    constructor(element) &#123;</span><br><span class="line">        this.element = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get html() &#123;</span><br><span class="line">        return this.element.innerHTML;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set html(value) &#123;</span><br><span class="line">        this.element.innerHTML = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, &quot;html&quot;);</span><br><span class="line">console.log(&quot;get&quot; in descriptor);   // true</span><br><span class="line">console.log(&quot;set&quot; in descriptor);   // true</span><br><span class="line">console.log(descriptor.enumerable); // false</span><br></pre></td></tr></table></figure>
<p>这里实现了对原型上html属性的拦截，且这个属性不可枚举,get和set里强制执行严格模式 </p>
<h2 id="es6继承"><a href="#es6继承" class="headerlink" title="es6继承"></a>es6继承</h2><h3 id="es5和es6继承对比"><a href="#es5和es6继承对比" class="headerlink" title="es5和es6继承对比"></a>es5和es6继承对比</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ES5</span><br><span class="line">function Rectanle(length, width)&#123;</span><br><span class="line">    this.length = length;</span><br><span class="line">    this.width = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle.prototype.getArea = function()&#123;</span><br><span class="line">    return this.length*this.width;</span><br><span class="line">&#125;</span><br><span class="line">function Square(length)&#123;</span><br><span class="line">    Rectangle.call(this,length,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Square.prototype = Object.create(Rectangle.prototype,&#123;</span><br><span class="line">    constructor: &#123;</span><br><span class="line">        value: Square,</span><br><span class="line">        enumerable: true,</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var sqare = new Square(3);</span><br><span class="line"></span><br><span class="line">console.log(square.getArea());            // 9</span><br><span class="line">console.log(square instanceof Square);    // true</span><br><span class="line">console.log(square instanceof Rectangle); // true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">class Rectangle&#123;</span><br><span class="line">    constructor(length, width)&#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">        this.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getArea()&#123;</span><br><span class="line">        return this.length * this.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square extends Rectangle&#123;</span><br><span class="line">    constructor(lenth)&#123;</span><br><span class="line">        //和调用 Ractangle.call(this, length, length)相似</span><br><span class="line">        super(length, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var square = new Square(3);</span><br><span class="line">console.log(square.getArea());              // 9</span><br><span class="line">console.log(square instanceof Square);      // true</span><br><span class="line">console.log(square instanceof Rectangle);   // true</span><br></pre></td></tr></table></figure>
<p>这里的es6通过关键字extends来实现继承，通过在contructor里的super()来调用父类的构造函数。<br>表名上es5和es6继承很相似但实际上大有不同：</p>
<ul>
<li>es5中的this是先创造子类的实例对象this，然后再将父类的方法和属性添加到this上。而es6则刚好相反。</li>
<li>es5中一般只实现了子类原型对父类构造函数原型的继承也就是单链继承，es6中不但实现了es5中继承还实现了子类构造函数对父类构造函数的继承，这就是说子类构造函数可以使用父类构造函数上的静态方法，结果上来说是双链继承。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log( Square.__proto__ === Rectangle); // true</span><br><span class="line">console.log( Square.prototype.__proto__ === Rectangle.prototype ); // true</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="es6继承注意项"><a href="#es6继承注意项" class="headerlink" title="es6继承注意项"></a>es6继承注意项</h3><h4 id="constuctor"><a href="#constuctor" class="headerlink" title="constuctor"></a>constuctor</h4><p>constructor可以省略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Square extends Rectangle&#123;</span><br><span class="line">    // no contructor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square extends Rectangle&#123;</span><br><span class="line">    constructor(...agrs)&#123;</span><br><span class="line">        super(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>constructor不省略时：</p>
<ul>
<li>super()只能在继承子类constructor里使用</li>
<li>super()必须调用来创造this，除非直接从constructor中返回一个对象</li>
<li>因为super()是用来初始化this的，在super()调用之前不能使用this</li>
</ul>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>super关键字既可以当做函数使用也可以当做对象使用，这两种情况完全不一样，且在出现关键字super时必须明确super是对象或者函数否则会报错。</p>
<p>super函数：</p>
<ul>
<li>作为父类的构造函数，子类构造函数中一般必须执行一次super函数，具体使用如上</li>
<li>在super()执行时内部的this默认指向子类<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		console.log(new.target.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">new A(); // A</span><br><span class="line">new B(); // B</span><br></pre></td></tr></table></figure></li>
</ul>
<p>super对象：</p>
<ul>
<li>在普通方法中，指向父类原型对象；在静态方法中指向父类<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.p()); // 2</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  p()&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure></li>
<li>同样super当做对象时this默认指向子类</li>
<li>super.x &#x3D; 3 相当于this.x &#x3D; 3</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul>
<li><a href="https://github.com/nzakas/understandinges6/tree/master/manuscript">understanding es6</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a></li>
</ul>
]]></content>
      <categories>
        <category>javscript</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器异步之macrotask与microtask</title>
    <url>/2017/08/09/event-loop/</url>
    <content><![CDATA[<p>本文主要是基于浏览器标准(html5)介绍macrotask和microtask. 由于事件循环和执行环境相关所以在node中执行结果稍有不同。  </p>
<p><code>首先了解我们知道js的特性是单线程、非阻塞I/O，不用考虑并发,死锁等问题。但是js的执行会导致多个线程同时在跑，如我们同时触发了异步http请求线程,以及定时器线程，如何管理他们之间的关系就需要even-loop。</code></p>
<p>1：首先我们的js线程在调用栈中触发了各种异步线程<br>2：异步线程执行完毕后放到异步任务对应源的队列中（Queue）<br>3：最后由event-loop将队列中（Queue）需要执行的任务按照一定策略取到js调用栈中执行</p>
<p><img src="/2017/08/09/event-loop/event-loop.jpg" alt="event-loop"></p>
<p>接下来就是<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">event-loop的执行的一些细节(html标准)</a>，大概分三步</p>
<p>1: 执行最旧的task（一次）<br>2：检查是否存在microtask，然后不停执行，直到清空队列（有可能多次）<br>3：检测是否执行render，如果可以就执行<br><img src="/2017/08/09/event-loop/flow" alt="flow"></p>
<ul>
<li><p>一个线程中，事件循环(event-loop)是唯一的，但是根据任务源(tasks source)做区分的任务队列(tasks queued)可以拥有多个。</p>
</li>
<li><p>任务队列又分为macrostask(宏任务)与microtask(微任务)，在最新标准中，它们被分别称为task与jobs。</p>
</li>
<li><p>macrotask大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering, networking(如ajax，fetch)。</p>
</li>
<li><p>microtasks大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)</p>
</li>
<li><p>在每个macrotask(宏任务)也就是task执行之间浏览器也许会更新渲染：原因是60fps（60 frame per second），这意味着约16.7ms进行一次render,如果task间隔没超过这个时间也就不会更新。</p>
</li>
<li><p>在执行macrotask(宏任务)的时候遇到一个新的macrotasks(宏任务)会将任务分发到对应队列中等待下一次事件循环执行</p>
</li>
<li><p>mircrotask在两种情况会执行<br> 1在回调函数中函数栈没有正在执行中的其他js<br> 2在每个task的后面</p>
</li>
<li><p>处理 microtask 队列期间，新添加的 microtask 添加到队列的末尾并且也被执行</p>
</li>
<li><p>来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。</p>
</li>
<li><p>在每一次事件循环(event-loop)中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microtask 队列清空。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;glob1&#x27;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line">		console.log(&#x27;test1&#x27;);</span><br><span class="line">		Promise.resolve().then(function()&#123;</span><br><span class="line">            console.log(&#x27;test1_promise&#x27;)</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">    console.log(&#x27;timeout1&#x27;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;timeout1_promise&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;timeout1_then&#x27;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#x27;glob1_promise&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(&#x27;glob2_promise&#x27;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#x27;glob1_then&#x27;)</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">	Promise.resolve().then(function()&#123;</span><br><span class="line">		console.log(&#x27;glob1_then_test&#x27;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// glob1</span><br><span class="line">// glob1_promise</span><br><span class="line">// glob2_promise</span><br><span class="line">// glob1_then</span><br><span class="line">// glob1_then_test</span><br><span class="line">// timeout1</span><br><span class="line">// timeout1_promise</span><br><span class="line">// timeout1_then</span><br><span class="line">// test1</span><br><span class="line">// test1_promise</span><br></pre></td></tr></table></figure>
<p>分析下上面执行的结果：<br>1： golb1 第一个task（js script）中执行的同步console<br>2： glob1_promise 第一个task（js script）中执行promise构造函数的同步console<br>3： glob2_promise 第一个task（js script）中执行promise构造函数的同步console<br>4:  glob1_then 第一个task执行完毕后检测先microtask队列中有一个Promise<br>5： glob1_then_test 第4步Promise执行过程中插入的microtask，也会继续执行<br>6： timeout1 执行第二个task（setTimeout）里面的同步console<br>7： timeout1_promise 第二个task中执行Promose构造函数的console<br>8： timeout1_then 第二个task执行完毕后检测microtask队列中有一个Promise<br>9： test1 第三个task（setTimeout）中同步执行的console<br>10： test1_promise 第三个task执行完毕后检测microtask队列中的Promise</p>
]]></content>
  </entry>
  <entry>
    <title>font-size with line-height</title>
    <url>/2017/10/09/font-size%20with%20line-height/</url>
    <content><![CDATA[<h2 id="1-字号与行高"><a href="#1-字号与行高" class="headerlink" title="1.字号与行高"></a>1.字号与行高</h2><p>  字号大小就是字体的高度，如字号为50px,那么他的高度如下图：<br><img src="/2017/10/09/font-size%20with%20line-height/1.png" alt="font-size">  </p>
<p>  行距为行高减去字号大小，如下图：<br><img src="/2017/10/09/font-size%20with%20line-height/2.png" alt="fontSizeAndLineHeight"><br>所以 半行距 &#x3D; (lineHeight-fontSize) &#x2F; 2; </p>
<span id="more"></span>

<h2 id="2-字体设计"><a href="#2-字体设计" class="headerlink" title="2.字体设计"></a>2.字体设计</h2><p>  正常的字体都要如下图的刻度和度量线：<br><img src="/2017/10/09/font-size%20with%20line-height/3.png" alt="font-size"><br>  这其中的值一般如下，也可以自己设置<br><img src="/2017/10/09/font-size%20with%20line-height/4.png" alt="length"><br>  Units Per Em表示一个字的高度有1000个单位，baseline的坐标为0，其它线的坐标相对于baseline，如下图所示：<br><img src="/2017/10/09/font-size%20with%20line-height/5.png" alt="length"></p>
<h2 id="3-图片底部的空白"><a href="#3-图片底部的空白" class="headerlink" title="3.图片底部的空白"></a>3.图片底部的空白</h2><p>  设置div的font-size为40px，line-height为60px，底部有一点空白：<br><img src="/2017/10/09/font-size%20with%20line-height/6.png" alt="img"><br>  在画上辅助线后就清楚许多了：<br><img src="/2017/10/09/font-size%20with%20line-height/7.png" alt="length"><br>  底部的空白高度 &#x3D; (baseline - descender) + 半行距；<br>  基线到底线的距离为：<br>  250 &#x2F; 1000 * 40 &#x3D; 10px<br>  半行距为：<br>  (60 - 40) &#x2F; 2 &#x3D; 10px<br>  空白距离：<br>  10px + 10px &#x3D; 20px<br>  如何将这个空白去掉，可以将div的行高设置为0就可以。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>http</title>
    <url>/2017/10/19/http/</url>
    <content><![CDATA[<h2 id="第3章-HTTP报文内的HTTP信息"><a href="#第3章-HTTP报文内的HTTP信息" class="headerlink" title="第3章 HTTP报文内的HTTP信息"></a>第3章 HTTP报文内的HTTP信息</h2><p>一般报文和响应报文的解构如下图所示：  </p>
<p><img src="/2017/10/19/http/message.png" alt="message"></p>
<span id="more"></span>


<h4 id="报文和实体的差异"><a href="#报文和实体的差异" class="headerlink" title="报文和实体的差异"></a>报文和实体的差异</h4><ul>
<li>报文(message): HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输  </li>
<li>实体(entity):作为报文的一部分，被当做请求和响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。</li>
</ul>
<h2 id="第4章-返回结构的HTTP状态码"><a href="#第4章-返回结构的HTTP状态码" class="headerlink" title="第4章 返回结构的HTTP状态码"></a>第4章 返回结构的HTTP状态码</h2><p>状态码类别：  </p>
<table>
<thead>
<tr>
<th>状态</th>
<th>类别</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>1XX Informatinal</td>
<td>信息性状态码</td>
<td>接收的请求处理中</td>
</tr>
<tr>
<td>2XX Success</td>
<td>成功状态码</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX Redirection</td>
<td>重定向状态码</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX Client Error</td>
<td>客服端错误状态码</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX Server Error</td>
<td>服务器错误状态码</td>
<td>服务器处理请求错误</td>
</tr>
</tbody></table>
<p>常用状态码：</p>
<ul>
<li>200 OK    表示从客户端发来的请求在服务器端正常处理了</li>
<li>204 No Content   表示服务器接受请求已成功处理，但是返回的响应保温中不含实体的主体部分。</li>
<li>206 Partail Content 表示客户点进行范围请求，服务器成功执行这部分的GET请求。响应报文中的Content-Range 指定实体内容的范围。</li>
<li>301 Moved Permanently   表示资源已经永久性重新分配URI，这是应该按照响应头的Location首部字段的URI重定向。</li>
<li>302 Found 表示资源暂时重新分配URI</li>
<li>303 See Other 表示资源存在另一个URI，应该使用GET方法定向获取请求的资源。</li>
<li>304 Not Modified 表示客户端发送附带条件(If-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since)请求时，服务器端允许请求访问资源，但是为满足条件，返回不包含任何相应主体部分。</li>
<li>400 Bad Request 表示报文中存在语法错误。</li>
<li>401 Unauthorized 表示未授权，或授权验证失败</li>
<li>403 Forbidden 拒绝访问</li>
<li>404 Not Found 无法通过指定的URI找到对应的资源</li>
<li>500 Internal Server Error 服务器执行时发生错误。</li>
<li>503 Service Unavailable 服务器暂时超负荷或停机维护中，最好写入在响应头中写入RetryAfter首部字段给客户端</li>
</ul>
<h2 id="第5章-与HTTP协作的web服务器"><a href="#第5章-与HTTP协作的web服务器" class="headerlink" title="第5章 与HTTP协作的web服务器"></a>第5章 与HTTP协作的web服务器</h2><h4 id="5-2-1-代理"><a href="#5-2-1-代理" class="headerlink" title="5.2.1 代理"></a>5.2.1 代理</h4><p>代理：接受客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。<br>一般具体过程如下：  </p>
<p><img src="/2017/10/19/http/proxy.png" alt="proxy"></p>
<p>按照使用分类。一种是否使用缓存，另一种是否修改报文。</p>
<ul>
<li>缓存代理： 代理转发响应时，缓存代理(Caching Proxy)会预先将资源副本保存在代理服务器上，当代理再次接收到相同资源请求时，就不可以从源服务器获取资源，而是将之前缓存作为响应返回。</li>
<li>透明代理： 转发请求或响应时，不对报文做任何加工称为透明代理。</li>
</ul>
<h4 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2 网关"></a>5.2.2 网关</h4><p>网关：利用网关可以由HTTP请求转化为其他协议通信。  </p>
<p><img src="/2017/10/19/http/gateway.png" alt="gateway"></p>
<h4 id="5-2-3-隧道"><a href="#5-2-3-隧道" class="headerlink" title="5.2.3 隧道"></a>5.2.3 隧道</h4><p>隧道： 按照要求建立器与其他服务器通信的路线，如利用SSL等加密手段。隧道的目的在保障客户端与服务器进行安全通信。</p>
<h3 id="5-3-缓存"><a href="#5-3-缓存" class="headerlink" title="5.3 缓存"></a>5.3 缓存</h3><p>缓存分为客户端缓存和代理缓存。</p>
<p><img src="/2017/10/19/http/tunnel.png" alt="tunnel"></p>
<h2 id="第6章-HTTP首部"><a href="#第6章-HTTP首部" class="headerlink" title="第6章 HTTP首部"></a>第6章 HTTP首部</h2><p>根据首部字段实际用途被分为以下4中类型</p>
<ul>
<li>通用首部字段(General Header Fileds): 请求报文和响应报文都会使用的首部。</li>
<li>请求首部字段(Request Header Fileds): 客户端项服务器端请求使用的首部。 补充了请求附加内容，客户端信息，响应内容相关优先级等信息。</li>
<li>响应首部字段(Response Header Fields): 服务器向客户福安响应时使用的首部。补充了响应附加内容，也会要求客户端附加额外内容信息。</li>
<li>实体首部字段(Entity Header Fields): 请求报文和响应报文实体部分使用的首部。补充资源内容更新时间等与实体有关的信息。</li>
</ul>
<p>HTTP&#x2F;1.1 规范定义如下47中首部字段<br>通用首部子段：<br><img src="/2017/10/19/http/GeneralHeader.png" alt="子段1">  </p>
<p>请求首部子段：<br><img src="/2017/10/19/http/RequestHeader.png" alt="子段2">  </p>
<p>响应首部子段：<br><img src="/2017/10/19/http/ResponseHeader.png" alt="子段3">  </p>
<p>实体首部子段：<br><img src="/2017/10/19/http/EntityHeader.png" alt="子段4">  </p>
<p>除了RFC2616中定义的47种首部子段。还有Cookie, Set-Cookie和Content-Disposition等。</p>
<h4 id="6-3-2-Connection"><a href="#6-3-2-Connection" class="headerlink" title="6.3.2 Connection"></a>6.3.2 Connection</h4><ul>
<li>控制代理不再转发给源服务器的首部字段  Connection: 不再转发的首部字段名</li>
</ul>
<h4 id="6-3-3-Date"><a href="#6-3-3-Date" class="headerlink" title="6.3.3 Date"></a>6.3.3 Date</h4><ul>
<li>创建HTTP报文的日期和时间 Date:Fri, 20 Oct 2017 06:33:42 GMT</li>
</ul>
<h4 id="6-3-4-Pragma"><a href="#6-3-4-Pragma" class="headerlink" title="6.3.4 Pragma"></a>6.3.4 Pragma</h4><ul>
<li>HTTP&#x2F;1.1 遗留字段，虽然为通用首部字段，但是只在客户端发送请求时使用。 为了保证全部中间服务器行为保存一般都会含以下两个字段<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-catch</span><br><span class="line">Paragma: no-cache</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Tralier"><a href="#Tralier" class="headerlink" title="Tralier"></a>Tralier</h4><ul>
<li>允许发生方在分块发送消息后面添加额外的元信息 Trailer: header-names</li>
</ul>
<h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><ul>
<li>Transfer-Encoding 是一个逐跳传输消息首部，即仅应用于两个节点之间的消息传递，而不是所请求的资源本身。</li>
</ul>
<h2 id="6-4-请求首部"><a href="#6-4-请求首部" class="headerlink" title="6.4 请求首部"></a>6.4 请求首部</h2><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><ul>
<li>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级，使用q来表示权重(0-1)默认为1.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br></pre></td></tr></table></figure>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4></li>
<li>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5, unicode-1-1;q=0.8</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><ul>
<li>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding:gzip, deflate, br</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Accept-Languag"><a href="#Accept-Languag" class="headerlink" title="Accept-Languag"></a>Accept-Languag</h4><ul>
<li>Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Language:zh-CN,zh;q=0.8</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p><img src="/2017/10/19/http/Authorization.png" alt="Authorization">;</p>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><ul>
<li>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号Host 首部字段在 HTTP&#x2F;1.1 规范内是唯一一个必须被包含在请求内的首部字段<br><img src="/2017/10/19/http/Host.png" alt="Host"></li>
</ul>
<h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><ul>
<li>如If-xxx这种首部字段称为条件请求，只有服务器接受附加条件后判定为真才会执行请求。 需要注意的是所有的条件都同时满足时才会处理请求。If-Match字段必须和ETag匹配时，服务器才会接受请求。<br><img src="/2017/10/19/http/If-Match.png" alt="If-Match"></li>
</ul>
<h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p><img src="/2017/10/19/http/If-Modified-Since.png" alt="If-Modified-Since"></p>
<h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><ul>
<li>在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。<br><img src="/2017/10/19/http/If-None-Match.png" alt="If-None-Match"></li>
</ul>
<h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><ul>
<li><p>它告知服务器若指定的 If-Range 字段值（ETag 值或者时间但是二者不能同时使用）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。<br><img src="/2017/10/19/http/If-Range.png" alt="If-Range"></p>
</li>
<li><p>若不使用If-Range请求失败则需要两次请求<br><img src="/2017/10/19/http/If-Range-without.png" alt="If-Range-without"></p>
</li>
</ul>
<h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><ul>
<li>的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。</li>
</ul>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><ul>
<li>首部字段 Referer 会告知服务器请求的原始资源的 URI。原始资源的 URI 中的查询字符串可能有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。</li>
</ul>
<h2 id="6-5-响应首部字段"><a href="#6-5-响应首部字段" class="headerlink" title="6.5 响应首部字段"></a>6.5 响应首部字段</h2><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><ul>
<li>Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。一种时bytes能处理一种为none不能处理</li>
</ul>
<h4 id="age"><a href="#age" class="headerlink" title="age"></a>age</h4><ul>
<li>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</li>
</ul>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><ul>
<li>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//强 ETag 值 不论实体发生多么细微的变化都会改变其值</span><br><span class="line">ETag: &quot;usagi-1234&quot;</span><br><span class="line"></span><br><span class="line">//弱 ETag 值 弱 ETag 值只用于提示资源是否相同会在字段值最开始处附加 W/。</span><br><span class="line">ETag: W/&quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><ul>
<li>该字段会配合 3xx ：Redirection 的响应，提供重定向的<br>URI。</li>
</ul>
<h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><ul>
<li>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端</li>
</ul>
<h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h4><ul>
<li>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。</li>
</ul>
<h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><ul>
<li>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。<br><img src="/2017/10/19/http/Vary.png" alt="Vary"></li>
</ul>
<h2 id="6-6-实体首部字段"><a href="#6-6-实体首部字段" class="headerlink" title="6.6 实体首部字段"></a>6.6 实体首部字段</h2>]]></content>
  </entry>
  <entry>
    <title>Javscript.The Core：2nd Edition</title>
    <url>/2017/12/04/javascript%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<p>这是’javascript核心’概览第二版，文章内容主要是ECMAScript程序语言以及运行时系统核心部分.</p>
<p>面向阅读对象：专业开发者</p>
<ol>
<li><a href="#object">对象(Object)</a></li>
<li><a href="#prototype">原型(Prototype)</a></li>
<li><a href="#class">类(Class)</a></li>
<li><a href="#executionContext">执行上下文(Execution context)</a></li>
<li><a href="#environment">环境(Environment)</a></li>
<li><a href="#closure">闭包(Closure)</a></li>
<li><a href="#this">This</a></li>
<li><a href="#realm">范围(Realm)</a></li>
<li><a href="#Job">Job</a></li>
<li><a href="#agent">代理(Agent)</a></li>
</ol>
<span id="more"></span>
<p>第一版的文章主要覆盖了js语言以下这些方面，从es3中抽象的概念，以及一些在es5或es6中合适的改变。</p>
<p>自从es2015开始，这些核心的概念已经发生了改变并且引入了新的模块，在这一版的文章中我们将聚焦一些新概念和新技术，但是同时也会兼顾那些不同文档间保持不变的js基础结构。  </p>
<p>这篇文章将覆盖 ES2017+运行时系统</p>
<ul>
<li>注意： 最新版的ECMAScript文档可以在TC-39网站找到</li>
</ul>
<p>我们从讨论对象概念开始，它是整个ECMAScript的根基.</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a><span id="object">Object</span></h2><p>ECMAScript 是一门基于原型的面向对象编程语言，对象是它的核心概念。</p>
<ul>
<li>Def.1 :对象：对象是属性的集合，且拥有一个原型对象，这个原型要么是个object要么是null值.</li>
</ul>
<p>让我们创造一个基本的对象，对象的原型是通过一个内部属性[[Prototype]]引用,在用户层面这个属性同过__proto__来引用.  </p>
<p>看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let point = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    y: 20</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构中有两个我们的显性属性很一个隐式属性__proto__,这个属性它指向point的原型:  </p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/js-object.png" alt="js-object"></p>
<p>注意：对象也可以存储symbols,你可以从<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">这份文档</a>得到更多的信息.  </p>
<p>原型对象通常用于实现继承来动态分发,让我们来看看原型链细节.  </p>
<h2 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型(Prototype)"></a><span id="prototype">原型(Prototype)</span></h2><p>每个对象在其创建的时候接受一个原型.如果这个原型没有显式设置,那么这个对象会接受一个默认原型当做它的继承对象.  </p>
<ul>
<li>Def.2:原型:prototype是一个委托对象，这个对象通常用于实现基于原型的继承.</li>
</ul>
<p>原型可以通过__prot__属性或者Object.create方法进行显式设置:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Base object.</span><br><span class="line">let point = &#123;</span><br><span class="line">  x: 10,</span><br><span class="line">  y: 20,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// Inherit from `point` object.</span><br><span class="line">let point3D = &#123;</span><br><span class="line">  z: 30,</span><br><span class="line">  __proto__: point,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  point3D.x, // 10, inherited</span><br><span class="line">  point3D.y, // 20, inherited</span><br><span class="line">  point3D.z  // 30, own</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>注意： 默认的原型继承自Object.prototype.  </p>
<p>任何一个对象可以被当做另一个对象的原型,并且原型本身也可以有自己的原型.如果原型的原型指向一个非空(no-null)引用,以此类推，这样就形参了原型链.  </p>
<ul>
<li>Def.3: 原型链： 原型链是一个有限的对象链，这个对象链通常用于实现继承的属性共享.</li>
</ul>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/prototype-chain.png" alt="prototype-chain"></p>
<p>原型链的规则也是相当简单: 如果一个属性在对象上没有找到,那么就从它的原型上找,然后再原型的原型上找,以此类推直到原型链都被遍历为止.  </p>
<p>技术上来说这个机制通常以动态分发(dynamic dispatch)或者委托(delegation)而著称.  </p>
<p>Def.4: 委托：一个用来在继承链上找寻属性的机制,它通常发生在运行时,因此也被称作动态分发(dynamic dispatch)</p>
<ul>
<li>注意：与动态分发在运行时求值相反的是,静态分发(static dispatch)在编译时确定引用值.</li>
</ul>
<p>如果属性在原型链上并没有找到，那么undefined将作为值返回.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// An &quot;empty&quot; object.</span><br><span class="line">let empty = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line"> </span><br><span class="line">  // function, from default prototype</span><br><span class="line">  empty.toString,</span><br><span class="line">   </span><br><span class="line">  // undefined</span><br><span class="line">  empty.x,</span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>正如我所看到的，一个默认对象实际上永远都不是空的,它总是从Object.prototype继承一些东西.如果想继承一个空对象,我们可以显式的设置它的原型为null：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Doesn&#x27;t inherit from anything.</span><br><span class="line">let dict = Object.create(null);</span><br><span class="line"> </span><br><span class="line">console.log(dict.toString); // undefined</span><br></pre></td></tr></table></figure>

<p>动态分发机制允许其修改原型链上委托对象:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let protoA = &#123;x: 10&#125;;</span><br><span class="line">let protoB = &#123;x: 20&#125;;</span><br><span class="line"></span><br><span class="line">// Same as &#x27;let objectC = &#123;__proto__: protoA&#125;;&#x27;</span><br><span class="line">let objectC = Object,create(protoA);</span><br><span class="line">console.log(objectC.x); // 10</span><br><span class="line"></span><br><span class="line">// change the delegate</span><br><span class="line">Object.setPrototypeOf(objctC, protoB);</span><br><span class="line">console.log(objectC.X); // 20</span><br></pre></td></tr></table></figure>

<ul>
<li>注意： 经过在今天__proto__属性已经标准化了,但是实践和举例中人们更加愿意使用如Object.create,Object.getPrototypeOf,Object.setPrototypeOf 这样的API方法来操作原型.</li>
</ul>
<p>在上面的例子中我们看到Obejct.prototyep,被不同的对象共享为原型,这是ECMAScript以基于类继承的实现方式.让我们在看看JS中的类的概念.  </p>
<h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类(Class)"></a><span id="class">类(Class)</span></h2><p>当不同的对象拥有相同的初始状态和行为,这时它们共同的形成了一个类.  </p>
<ul>
<li>Def.5: 类： 类是一组拥有特定初始状态和行为的对象.</li>
</ul>
<p>当我们需要对多个对象继承自相同原型时,我们可以创建一个原型，然后显式的从这个创建的原型继承.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Generic prototype for all letters.</span><br><span class="line">let letter = &#123;</span><br><span class="line">  getNumber() &#123;</span><br><span class="line">    return this.number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">let a = &#123;number: 1, __proto__: letter&#125;;</span><br><span class="line">let b = &#123;number: 2, __proto__: letter&#125;;</span><br><span class="line">// ...</span><br><span class="line">let z = &#123;number: 26, __proto__: letter&#125;;</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  a.getNumber(), // 1</span><br><span class="line">  b.getNumber(), // 2</span><br><span class="line">  z.getNumber(), // 26</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们可以从下图中看他们之间的关系:  </p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/shared-prototype.png" alt="shared-prototype"></p>
<p>然而这看起来相当笨重.并且类抽象刚好充当了句法糖的作用(i.e这个结构在语义上是相同的，但是是以一种更加词法化的形式),它让我们以一种方便的模式创建这样的对象.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Letter &#123;</span><br><span class="line">  constructor(number) &#123;</span><br><span class="line">    this.number = number;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  getNumber() &#123;</span><br><span class="line">    return this.number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let a = new Letter(1);</span><br><span class="line">let b = new Letter(2);</span><br><span class="line">// ...</span><br><span class="line">let z = new Letter(26);</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  a.getNumber(), // 1</span><br><span class="line">  b.getNumber(), // 2</span><br><span class="line">  z.getNumber(), // 26</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：基于类的继承在ES中是通过原型委托来实现的.  </p>
</li>
<li><p>注意：类只是一种理论上的抽象.理论上来说它既可以通过静态分发来实现,如在java或者c++,也可以通过动态分发(委托)来实现,如javascript,Python,Ruby.等等.</p>
</li>
</ul>
<p>理论上类可以由”构造函数+原型”来表示.构造函数在创建对象的同时自动的将为新创建的实例设置原型.它的原型被存储在ConstructorFunction.prototype(构造函数的原型)上.  </p>
<ul>
<li>Def.6: 构造器: 构造器是一个用于创建实例并且自动为实例设置原型的函数.</li>
</ul>
<p> 可以显示的使用一个构造器函数，而且在类抽象被引进之前,JS开发者并没有更好的选择(我们可以在因特网上看到许多这样遗留代码):</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function Letter(number) &#123;</span><br><span class="line">  this.number = number;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Letter.prototype.getNumber = function() &#123;</span><br><span class="line">  return this.number;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">let a = new Letter(1);</span><br><span class="line">let b = new Letter(2);</span><br><span class="line">// ...</span><br><span class="line">let z = new Letter(26);</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  a.getNumber(), // 1</span><br><span class="line">  b.getNumber(), // 2</span><br><span class="line">  z.getNumber(), // 26</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当创建一个单一层级的构造器是一件相当容易的事,从父类继承的模型需要更多的模板.当前这种模板的实现细节在我们创建JS类时已经被隐藏起来了.  </p>
<ul>
<li>注意：构造器函数只是基于类继承的实现细节.</li>
</ul>
<p>让我们看一下对象和类的关系:  </p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/js-constructor.png" alt="jsConstructor"></p>
<p>这张图展示了每个对象都和一个原型相关联,甚至构造器函数(class)Letter也有自己的原型,这个函数的原型指向Function.prototype. 注意Letter.prototype是Letter实例的原型也就是a,b,z.  </p>
<ul>
<li>注意:对于任何对象的实际原型都是指__proto__.同时在构造函数的显示属性prototype只是指向实例的原型的引用.其实实例的原型仍然是__proto__.可以从<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/#explicit-codeprototypecode-and-implicit-codeprototypecode-properties">这里</a>查看更多细节.</li>
</ul>
<p>你可以从<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/">ES3. 7.1 OOP: The general theory</a>文章中找到更多关于一般面向对象编程(OPP)的概念(包括基于类,基于原型的描述,等等)  </p>
<p>现在我们对ECMAScript对象有了基本的了解,让我们再看一下JS的运行系统,我们将看到,在那儿任何东西都将以对象呈现.  </p>
<h2 id="执行上下文-Execution-context"><a href="#执行上下文-Execution-context" class="headerlink" title="执行上下文(Execution context)"></a><span id="executionContext">执行上下文(Execution context)</span></h2><p>为了执行JS代码的同时跟踪代码运行时的求值,ECMAScript 规范定义了执行上下文的概念.逻辑上来说执行上下文坚持使用栈(stack:执行上下文栈我们将很快看到),它对应的更广为人知的概念为调用栈.  </p>
<ul>
<li>Def.7: 执行上下文：执行上下文是一个用于跟踪运行时对代码求值的东西</li>
</ul>
<p>在ESCMScript中有几种类型的代码：全局代码, 函数代码,eval代码,模块代码.每一种代码都是在执行上下文中求值.不同的代码，在一定类型对象下会影响执行上下文的结构：如generator function在上下文中保存它们的genarator对象时.  </p>
<p>让我们看一看下面的函数递归调用:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function recursive(flag) &#123;</span><br><span class="line"> </span><br><span class="line">  // Exit condition.</span><br><span class="line">  if (flag === 2) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // Call recursively.</span><br><span class="line">  recursive(++flag);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Go.</span><br><span class="line">recursive(0);</span><br></pre></td></tr></table></figure>

<p>一旦一个函数被调用时,一个新的执行上下文将被创建,同时将它推进栈中–这时就变成一个活动执行上下文(active execution context),当一个函数返回时,这个上下文就从栈中吐(poped)出来.  </p>
<p>一个上下文调用另一个上下文时，前一个上下文被称做调用者(caller),当一个上下文被调用对应的被称作被调用者(callee).在上面的例子中recursive函数扮演着两个角色：调用者和被调用者.  </p>
<ul>
<li>Def.8: 执行上下文栈：执行上下文栈是一个后进先出(LIFO)的结构,这种结构被用来控制执行顺序和流.</li>
</ul>
<p>对于上面的例子我们遵循栈的”push-pop”限制：  </p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/execution-stack.png" alt="executionStack"> </p>
<p>我们可以看到,全局上下文总是栈底部,它在执行所有其他上下文前就已经创建.  </p>
<p>你可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/">合适的章节</a>找到更多的细节.   </p>
<p>通常,上下文中代码将会运行完成，但是正如我所上面提到的–如generators也许会破坏后栈的进先出顺序.一个generator函数也许会暂停它的运行上下文,同时在它执行完之前将它从栈中移除.一旦generator被再次激活,它的上下文会再次回复并且将再次被推进栈中:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function *gen() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let g = gen();</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  g.next().value, // 1</span><br><span class="line">  g.next().value, // 2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里的yield语句将对调用者返回value值,同时上下文将被吐出.当第二个next调用时,相同的上下文将被推进栈中恢复.这样上下文将会在创建它的调用者之外存活,因此它破坏了后进先出的结构.  </p>
<ul>
<li>注意：你可以从这个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">文档</a>阅读更多关于generators和iterators的细节.</li>
</ul>
<p>我们将现在讨论一个执行上下文的重要组成部分,特别是ECMACript运行中在嵌套代码块中如何管理变量存储和作用域.一般它们被称做词法环境：它们在JS中用来存储数据以及解决”函数作为参数问题(Funarg problem)”–和闭包机制.  </p>
<h2 id="环境-Environment"><a href="#环境-Environment" class="headerlink" title="环境(Environment)"></a><span id="environment">环境(Environment)</span></h2><p>每个执行上下文都有一个与之相关联的词法环境.  </p>
<ul>
<li>Def.9: 词法环境： 词法环境是一个用于定义出现在上下文标识符和值之间关系.每个环境都一个指向可选父级环境的引用.</li>
</ul>
<p>所以一个环境就是存储在一个作用域定义的变量,函数,类.  </p>
<p>理论上来说,环境是由环境记录(一个实际上存储表,表的内容为标识符和值之间的映射),与可以指向父级环境(可能为null)的引用组成.  </p>
<p>代码如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 10;</span><br><span class="line">let y = 20;</span><br><span class="line"> </span><br><span class="line">function foo(z) &#123;</span><br><span class="line">  let x = 100;</span><br><span class="line">  return x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(30); // 150</span><br></pre></td></tr></table></figure>

<p>全局上下文和foo函数上下文的环境解构关系如下：  </p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/environment-chain.png" alt="environmentChain">  </p>
<p>这让我们想起先前提到原型链.并且标识符求值规则与之相当相似: 如果一个变量在当前环监局没有找到,那么就向父级环境寻找,然后父级的父级,以此类推,直到整个环境链被遍历完了.  </p>
<ul>
<li>Def.10:标识符求值：它是一个在环境链求值的过程,如果没有找到相应的绑定就会抛出一个ReferenceError错误.</li>
</ul>
<p>这就解释了为什么变量x求值为100,而不是10–它被在自己的环境foo中找到;为什么我们可以访问参数z–它也是时被存储在激活环境中;同时也能解释我们可以获取y的值–这是因为它在父级环境中可以找到.  </p>
<p>与原型相似的是,相同的父级环境可以被多个子级环境共享：如连个全局函数共享一个全局环境.  </p>
<ul>
<li>注意：你可以从<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/">这篇文章</a>得到关于词法环境实现的细节.</li>
</ul>
<p>环境记录根据类型被分为两种.一种是对象环境记录另一种是声明环境记录,在声明记录的上面也有函数环境记录，module环境记录.每一种记录都有对于自己属性的特征.但是对于标识符求值的一般机制它们是不分环境的,并且也不依赖记录的类型.  </p>
<p>下面是一个关于对象环境记录可以是全局环境.这个记录与一个绑定对象相关联.绑定对象可以从这个记录存储一些属性,但是不可以从其他地方,反之亦然.这个绑定对象可以从this值中获取.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Legacy variables using `var`.</span><br><span class="line">var x = 10;</span><br><span class="line"> </span><br><span class="line">// Modern variables using `let`.</span><br><span class="line">let y = 20;</span><br><span class="line"> </span><br><span class="line">// Both are added to the environment record:</span><br><span class="line">console.log(</span><br><span class="line">  x, // 10</span><br><span class="line">  y, // 20</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">// But only `x` is added to the &quot;binding object&quot;.</span><br><span class="line">// The binding object of the global environment</span><br><span class="line">// is the global object, and equals to `this`:</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  this.x, // 10</span><br><span class="line">  this.y, // undefined!</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">// Binding object can store a name which is not</span><br><span class="line">// added to the environment record, since it&#x27;s</span><br><span class="line">// not a valid identifier:</span><br><span class="line"> </span><br><span class="line">this[&#x27;not valid ID&#x27;] = 30;</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  this[&#x27;not valid ID&#x27;], // 30</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码可以描绘成下面图: </p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/env-binding-object.png" alt="envBindingObject"></p>
<p>注意：绑定对象的存在是为可以覆盖一些遗留的解构,如var声明,with语句，它们被当做绑定对象.当环境以简单对象来呈现是有历史原因的.当前的环境模型是优化过后的，但是作为结果是我们不能通过属性来访问这些绑定了.  </p>
<p>我们已经看到了环境如何通过父级连接相关联.现在我们来看一个环境怎样可以脱离创建它的上线文继续存活.这就就是我们将要讨论的闭包原理.  </p>
<h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a><span id="closure">闭包(Closure)</span></h2><p>函数在ECMAScript中是第一公民.这是函数式编程的重要的根基概念.这就意味着函数式编程在js中得到部分的实现.  </p>
<ul>
<li>Def. 11: 第一公民函数:一个函数可以充当普通的数据:可以被存储为变量,传做参数,从另一个函数中当做值返回.</li>
</ul>
<p>第一公民函数的概念和被叫做”Funcarg problem”(函数作为参数的问题)相关.这个问题引起函数如何处理自由变量.  </p>
<ul>
<li>Def.12 : 自由变量：一个既不是当前函数参数也不是当前函数本地变量的变量.</li>
</ul>
<p>让我们看看”Funcarg problem”,然后看ECMAScript是如何解决的.  </p>
<p>看如下代码: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 10;</span><br><span class="line"> </span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function bar(funArg) &#123;</span><br><span class="line">  let x = 20;</span><br><span class="line">  funArg(); // 10, not 20!</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Pass `foo` as an argument to `bar`.</span><br><span class="line">bar(foo);</span><br></pre></td></tr></table></figure>

<p>变量x对于函数foo是自由变量. 当foo函数调用时(通过函数参数传递)–x的值是那里绑定的?是函数创建的地方,或者是调用者作用域,也就是函数调用的地方?正如我们所见x的值为20.  </p>
<p>上面用例描述了广为人知的”下放函数参数问题(downward funarg problem)”,i.e 一个关于如何决定环境绑定的问题：是应该绑定创建时的环境,或者是调用时的环境.  </p>
<p>它被一个一个使用静态作用域的共识解决了,也就是创建时的作用域.  </p>
<p>Def.13:静态作用域:一个实现静态作用域的语言,是通过其源码位置决定环境绑定.  </p>
<p>静态作用也叫词法环境,因此以词法环境命名.  </p>
<ul>
<li>注意：你可以通过<a href="https://codeburst.io/js-scope-static-dynamic-and-runtime-augmented-5abfee6223fe">这篇文章</a>了解静态和动态作用域.</li>
</ul>
<p>在我们的例子中,foo函数捕获的环境就是全局环境.  </p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/closure.png" alt="closure"></p>
<p>Def. 14: closure: 闭包就是函数对定义时环境的捕获,这个环境通常用来对标识符的求值.  </p>
<p>对于函数参数的另一种问题被称为”上升函数参数问题(upward funarg problem)”.它们唯一不同的是捕获环境在脱离创建环境时任然存活.  </p>
<p>让我们看下这个例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  let x = 10;</span><br><span class="line">   </span><br><span class="line">  // Closure, capturing environment of `foo`.</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    return x;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // Upward funarg.</span><br><span class="line">  return bar;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let x = 20;</span><br><span class="line"> </span><br><span class="line">// Call to `foo` returns `bar` closure.</span><br><span class="line">let bar = foo();</span><br><span class="line"> </span><br><span class="line">bar(); // 10, not 20!</span><br></pre></td></tr></table></figure>

<p>理论上它的捕获环境机制并没有变.只是在这种情况下,我们没闭包了吗?foo的激活环境将被销毁.但是我们捕获了它,所以它被保存起来–来支持静态作用域语义.  </p>
<p>这里常常存在对闭包不完整的理解. –通常开发者认为的闭包只是”上升函数参数问题”.但是,正如我们可以看到,理论上来说上升和下钻参数问题都是一样的–静态作用域机制.  </p>
<p>如上所述,和原型相似的是–相同的父环境可以被多个闭包所共享,这让我们获取和改变共享数据:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createCounter() &#123;</span><br><span class="line">  let count = 0;</span><br><span class="line"> </span><br><span class="line">  return &#123;</span><br><span class="line">    increment() &#123; count++; return count; &#125;,</span><br><span class="line">    decrement() &#123; count--; return count; &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let counter = createCounter();</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  counter.increment(), // 1</span><br><span class="line">  counter.decrement(), // 0</span><br><span class="line">  counter.increment(), // 1</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>因为两个闭包，increment和decrement都在同一个包含变量count的环境创建,所以它们共享同一个父级作用域,总是通过引用–意味着引用对全部的父级环境保持存储.</p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/shared-environment.png" alt="sharedEnvironment">  </p>
<p>一些语言也许只是捕获值,也就是制作一份捕获变量的副本,并且不允许其对父级作用域的改变.但是在js中,总是父级作用域总是通过引用.</p>
<p>注意：在实现上也许会对这个步骤进行优化.并且不会捕获整个环境.只会捕获’自由变量’,但是它们仍会保持对父级作用域数据改变的能力.  </p>
<p>你可以从<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/">合适的文章</a>找到闭包和函数参数问题相关细节.  </p>
<p>可以说所有的标识符都是静态绑定的.但是在ECMAScript中任然有一个是动态绑定的值this. </p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a><span id="this">this</span></h2><p> this的值是一个动态的并且是隐式传入代码上下文的.我们可以将它当做一个隐式额外参数，它可以被访问但是不能被改变.  </p>
<p> this值的目的在于相同代码给多个对象使用.  </p>
<ul>
<li>Def. 15: This: 一个用于访问执行上下文的隐式上下文对象–它的目的在于让相同代码可以被多个对象使用.</li>
</ul>
<p> 它的主要用例为基于类的面向对象编程(OOP).一个存于实例上的方法(定义在原型上),实际上要被所有基于这个类的实例使用.  </p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this._x = x;</span><br><span class="line">    this._y = y;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  getX() &#123;</span><br><span class="line">    return this._x;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  getY() &#123;</span><br><span class="line">    return this._y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let p1 = new Point(1, 2);</span><br><span class="line">let p2 = new Point(3, 4);</span><br><span class="line"> </span><br><span class="line">// Can access `getX`, and `getY` from</span><br><span class="line">// both instances (they are passed as `this`).</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  p1.getX(), // 1</span><br><span class="line">  p2.getX(), // 3</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> 当开始激活getX方法时,一个用于创建本地变量和参数的环境被创建.此外，一个[[ThisValue]]被传递到函数环境记录,这个值动态的绑定函数调用者.当调用者为p1时,this的值就是p1,第二种情况就是p2.  </p>
<p> this的另一应用,是通用接口函数的混合与覆盖.</p>
<p>在下面例子中,Movable包含一个通用接口函数move,这个函数期望使用者对_x和_y的混合(mixin).  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Generic Movable interface (mixin).</span><br><span class="line">let Movable = &#123;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * This function is generic, and works with any</span><br><span class="line">   * object, which provides `_x`, and `_y` properties,</span><br><span class="line">   * regardless of the class of this object.</span><br><span class="line">   */</span><br><span class="line">  move(x, y) &#123;</span><br><span class="line">    this._x = x;</span><br><span class="line">    this._y = y;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">let p1 = new Point(1, 2);</span><br><span class="line"> </span><br><span class="line">// Make `p1` movable.</span><br><span class="line">Object.assign(p1, Movable);</span><br><span class="line"> </span><br><span class="line">// Can access `move` method.</span><br><span class="line">p1.move(100, 200);</span><br><span class="line"> </span><br><span class="line">console.log(p1.getX()); // 100</span><br></pre></td></tr></table></figure>

<p>另一方面.混合也可以应用于原型级别而不只是实例.  </p>
<p>为了展示this值的动态属性,看下面的这个例子.我们将留给读者当做一个练习解决:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let bar = &#123;</span><br><span class="line">  foo,</span><br><span class="line"> </span><br><span class="line">  baz() &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// `foo`</span><br><span class="line">console.log(</span><br><span class="line">  foo(),       // global or undefined</span><br><span class="line"> </span><br><span class="line">  bar.foo(),   // bar</span><br><span class="line">  (bar.foo)(), // bar</span><br><span class="line"> </span><br><span class="line">  (bar.foo = bar.foo)(), // global</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">// `bar.baz`</span><br><span class="line">console.log(bar.baz()); // bar</span><br><span class="line"> </span><br><span class="line">let savedBaz = bar.baz;</span><br><span class="line">console.log(savedBaz()); // global</span><br></pre></td></tr></table></figure>

<p>因为只是看foo函数的源码是无法区分this的值的.所以我们说this值动态的.  </p>
<ul>
<li>你可以在相应的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/">章节</a>找到答案.</li>
</ul>
<p>在箭头函数里this的值很特殊:this值是词法的(静态的),而不是动态的.I.e.它们函数环境记录不提供this的值,而且它们是从父级环境获取.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line"> </span><br><span class="line">let foo = &#123;</span><br><span class="line">  x: 20,</span><br><span class="line"> </span><br><span class="line">  // Dynamic `this`.</span><br><span class="line">  bar() &#123;</span><br><span class="line">    return this.x;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  // Lexical `this`.</span><br><span class="line">  baz: () =&gt; this.x,</span><br><span class="line"> </span><br><span class="line">  qux() &#123;</span><br><span class="line">    // Lexical this within the invocation.</span><br><span class="line">    let arrow = () =&gt; this.x;</span><br><span class="line"> </span><br><span class="line">    return arrow();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">console.log(</span><br><span class="line">  foo.bar(), // 20, from `foo`</span><br><span class="line">  foo.baz(), // 10, from global</span><br><span class="line">  foo.qux(), // 20, from `foo` and arrow</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>正如我们所说,在全局上下文中this的值是全局对象(它绑定着全局环境记录的对象),先前全局对象只有一个.但是现在版本的规范里也许有多个全局对象.这些全局对象只针对部分代码范围.让我们看看这种结构.  </p>
<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><span id="realm">范围</span></h2><p>在求值之前,所有的ECMAScript代码都和一个范围相关联.理论上范围只是为一个上下文提供一个全局环境.  </p>
<p>当一个执行上下文被创建时它就和一个特别代码范围相关联.这个代码范围只是为这个上下文提供一个全局环境.这个关联是不可变的.  </p>
<ul>
<li>注意： 在浏览器环境中一个最直接的返回为iframe,她恰好体同一个全局环境,在Node.js中最接近的是沙箱的<a href="https://nodejs.org/api/vm.html">vm module</a></li>
</ul>
<p>当前版本的规范并没有提供一个realms创建的具体方法,但是它们可以由实现环境隐式实现. 这里有一个关于暴露给用户使用API的<a href="https://github.com/tc39/proposal-realms/">提议</a>  </p>
<p>理论上每个在栈中上下文都和自己的范围相关联.  </p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/context-realm.png" alt="contextRealm"></p>
<p>现在我们对运行时ECMAScript的大地图更靠近了. 但是我们任然需要看一看入口代码和初始化过程.它们都由一个叫jobs和job序列的机制管理.  </p>
<h2 id="job"><a href="#job" class="headerlink" title="job"></a><span id="job">job</span></h2><p>一些操作可以被推迟,并且只有在执行上下文栈有空的时候就可以执行.  </p>
<ul>
<li>Def.17:Job:job是一种抽象的操作,它在当前进程中没有其他ECMAScript计算时发起一个ECMAScript计算.</li>
</ul>
<p>jobs在job序列中排序,在当前规范版本中有两种job序列:ScriptJobs,和PromiseJobs.  </p>
<p>在ScriptJobs上的初始化job是我们程序的主入口–就是对我们的初始化脚本加载和求值：范围(realm)创建，全局上下文与范围相关联,推入调用栈，全局代码执行.  </p>
<ul>
<li>注意，ScriptJobs序列同时管理脚本和modules.</li>
</ul>
<p>接着这个上下文可以执行其他上下文，或者其他排队的jobs. </p>
<p>当么有运行的执行上下文同时执行上下文栈为空时，ECMAScript将在job系列的第一个等待job移除,同时创建一个执行上下开始执行这个job.  </p>
<ul>
<li>注意：job序列通常被称为”event loop”的管理.ECMAScript标准并没有明确规定这个”event loop”,它的实现都留给了实现环境了.但是你可以发现一个启发式的例子在这儿.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Enqueue a new promise on the PromiseJobs queue.</span><br><span class="line">new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 0))</span><br><span class="line">  .then(value =&gt; console.log(value));</span><br><span class="line"> </span><br><span class="line">// This log is executed earlier, since it&#x27;s still a</span><br><span class="line">// running context, and job cannot start executing first</span><br><span class="line">console.log(20);</span><br><span class="line"> </span><br><span class="line">// Output: 20, 10</span><br></pre></td></tr></table></figure>

<p>async 函数可以对promise进行await,所以它们也是排队序列: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function later() &#123;</span><br><span class="line">  return await Promise.resolve(10);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  let data = await later();</span><br><span class="line">  console.log(data); // 10</span><br><span class="line">&#125;)();</span><br><span class="line"> </span><br><span class="line">// Also happens earlier, since async execution</span><br><span class="line">// is queued on the PromiseJobs queue.</span><br><span class="line">console.log(20);</span><br></pre></td></tr></table></figure>

<p>现在我们相当接近JS的全貌了,现在我们将看这些组件的主要拥有者,代理.  </p>
<h2 id="代理-agent"><a href="#代理-agent" class="headerlink" title="代理(agent)"></a><span id="agent">代理(agent)</span></h2><p>在ECMAScript中并发和并行是通过代理模式实现. 代理模式与<a href="https://en.wikipedia.org/wiki/Actor_model">演员模式</a>相当接近–一种轻量的处理消息传递方式的过程.  </p>
<ul>
<li>Def.18: Agent: 代理是一种对执行上下文栈,一系列job队列,代码范围的抽象.</li>
</ul>
<p>实现者依赖代理究竟是可以允许在单一线程,还是多线程.如在浏览器环境中worker agent就是代理概念的例子.  </p>
<p>代理们的状态是相互独立的,它们可以通过发送消息来沟通.一些数据可以在不同代理之间共享,如sharedArrayBuffer.代理们可以组成集群.  </p>
<p>所以下面是ECMAScript运行时的全貌:  </p>
<p><img src="/2017/12/04/javascript%E6%A0%B8%E5%BF%83/agents-1.png" alt="agents"></p>
<p>这就是发生在ECMAScript引擎下全图.  </p>
<p>现在我们来到了文章结尾处.这是篇文章有很多关于js核心的信息.如我们提到的JS代码可以将它分为modules，对象属性通过proxy跟踪等等分类–这儿有很多用户级别的细节你可以从不同文档读到.  </p>
<p>但是这里我们尽力展现ECMAScript程序本身的逻辑结构,同时希望澄清它们一些的细节.如果你有任何问题,建议或者反馈–我将很乐意在评论中讨论.  </p>
]]></content>
      <categories>
        <category>javscript</category>
      </categories>
  </entry>
  <entry>
    <title>代码整洁之道</title>
    <url>/2017/10/10/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93--%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第2章-有意义的名称"><a href="#第2章-有意义的名称" class="headerlink" title="第2章  有意义的名称"></a>第2章  有意义的名称</h2><h3 id="2-2-名副其实"><a href="#2-2-名副其实" class="headerlink" title="2.2 名副其实"></a>2.2 名副其实</h3><ul>
<li>变量 函数或类的名称都应该已经回复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事，应该怎么用。如果名称需要注释来补充，那就不算是名副其实。<span id="more"></span></li>
</ul>
<h3 id="2-3-避免误导"><a href="#2-3-避免误导" class="headerlink" title="2.3 避免误导"></a>2.3 避免误导</h3><h4 id="程序员必须避免留下掩藏代码本意的错误线索。"><a href="#程序员必须避免留下掩藏代码本意的错误线索。" class="headerlink" title="程序员必须避免留下掩藏代码本意的错误线索。"></a>程序员必须避免留下掩藏代码本意的错误线索。</h4><ul>
<li>1.避免使用与本意相悖的的词： 别用accountArray来指称一组账号，除非它真的是Array类型。</li>
<li>2.提防使用差别较小的名称。</li>
<li>3.别用人眼误导性名称：小写i和大写O和常量“1”与“0”很相似。</li>
</ul>
<h3 id="2-4-做有意义的区分"><a href="#2-4-做有意义的区分" class="headerlink" title="2.4 做有意义的区分"></a>2.4 做有意义的区分</h3><ul>
<li>废话是另一种没意义的区分。如果有一个Product类。如果还有一个ProductInfo或ProductDate类，那它们的名称虽然不同，意思却无区别</li>
</ul>
<h3 id="2-5-使用读得出来的名称"><a href="#2-5-使用读得出来的名称" class="headerlink" title="2.5 使用读得出来的名称"></a>2.5 使用读得出来的名称</h3><h3 id="2-6-使用可搜索的名称"><a href="#2-6-使用可搜索的名称" class="headerlink" title="2.6 使用可搜索的名称"></a>2.6 使用可搜索的名称</h3><ul>
<li>单字母名称和数字常量有个问题，就是很难在大篇文字中找出来。单字母的名称仅用于短方法中的本地变量，名称长短应与其作用域大小相对应。</li>
</ul>
<h3 id="2-9-类名"><a href="#2-9-类名" class="headerlink" title="2.9 类名"></a>2.9 类名</h3><ul>
<li>类名和对象名应该是具体的名称或名词短语，如Customer，WikiPage，Account，AddressParser。避免使用不具体的Manager,Processor,Data,Info这样的类名。类名不应该是动词。</li>
</ul>
<h3 id="2-10-方法名"><a href="#2-10-方法名" class="headerlink" title="2.10 方法名"></a>2.10 方法名</h3><ul>
<li>方法名应当是动词或者动词短语，如postPayment,deletePage,或save</li>
</ul>
<h3 id="2-12-保持命名风格统一"><a href="#2-12-保持命名风格统一" class="headerlink" title="2.12 保持命名风格统一"></a>2.12 保持命名风格统一</h3><ul>
<li>fetch,retrieve,get意思上相当相近，如在同一个项目中只使用一个则阅读起来相当明了。</li>
</ul>
<h3 id="2-16-添加有意义的语境"><a href="#2-16-添加有意义的语境" class="headerlink" title="2.16 添加有意义的语境"></a>2.16 添加有意义的语境</h3><ul>
<li>通常添加前缀为读者提供语境，会让读者明白这些变量是某一个更大结构的一部分。</li>
</ul>
<h3 id="2-17-不要添加没用的语境"><a href="#2-17-不要添加没用的语境" class="headerlink" title="2.17 不要添加没用的语境"></a>2.17 不要添加没用的语境</h3><ul>
<li>如果短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。</li>
</ul>
<h2 id="第3章-函数"><a href="#第3章-函数" class="headerlink" title="第3章 函数"></a>第3章 函数</h2><h3 id="3-1-短小"><a href="#3-1-短小" class="headerlink" title="3.1 短小"></a>3.1 短小</h3><ul>
<li>函数第一规则就是要短小，每行都不应该有150个字符那么长。函数也不应该有100行那么长，20行封顶最佳。</li>
</ul>
<h3 id="3-2-只做一件事"><a href="#3-2-只做一件事" class="headerlink" title="3.2 只做一件事"></a>3.2 只做一件事</h3><ul>
<li>1.如果函数只是做了该函数名下同一抽象层的步骤，则函数还是做了一件事</li>
<li>2.要判断函数是否不止做了一件事，还有一个方法，就是看是否能再拆出一个函数，该函数不仅是单纯的重新诠释其实现。</li>
</ul>
<h3 id="3-3-每个函数一个抽象层级"><a href="#3-3-每个函数一个抽象层级" class="headerlink" title="3.3 每个函数一个抽象层级"></a>3.3 每个函数一个抽象层级</h3><ul>
<li>我们想让代码拥有自顶向下的阅读顺序。我们想要每个函数后面都跟着位于下一抽象层级的函数，这个样子我们查看函数列表时，就能依循抽象层级向下阅读了。</li>
</ul>
<h3 id="3-4-switch语句"><a href="#3-4-switch语句" class="headerlink" title="3.4 switch语句"></a>3.4 switch语句</h3><ul>
<li>我们无法避开switch语句，不过还是能确保每个switch都埋在较低的抽象层级，而且永远不重复</li>
</ul>
<h3 id="3-5-使用描述性的名称"><a href="#3-5-使用描述性的名称" class="headerlink" title="3.5 使用描述性的名称"></a>3.5 使用描述性的名称</h3><ul>
<li>别害怕长名称。长而具有描述性的名称，要比短而费解的名称好。</li>
</ul>
<h3 id="3-6-函数参数"><a href="#3-6-函数参数" class="headerlink" title="3.6 函数参数"></a>3.6 函数参数</h3><ul>
<li>1.对于输入参数最理想的参数数量是零，其次是一，再次是二，应当尽力避免三</li>
<li>2.不要通过参数输出（也是就通常的对象改变影响外部对象），我们惯于通过参数输入函数，通过返回值从函数中输出。我们不太期望信息通过参数输出。</li>
<li>3.标示参数丑陋不堪。向函数传入布尔值简直就是骇人听闻的做法，着意味着大声宣布本函数不止做一件事。</li>
</ul>
<h3 id="3-7-无副作用"><a href="#3-7-无副作用" class="headerlink" title="3.7 无副作用"></a>3.7 无副作用</h3><ul>
<li>有副作用的函数，都是具有破坏性的，会导致古怪的时序耦合及顺序</li>
</ul>
<h3 id="3-8-分割指令与询问"><a href="#3-8-分割指令与询问" class="headerlink" title="3.8 分割指令与询问"></a>3.8 分割指令与询问</h3><ul>
<li>函数要么做什么事，要么回答什么事，但二者不可兼得。函数应该修改某个对象的状态，或者返回该对象的有关信息。</li>
</ul>
<h3 id="3-9-使用异常代替返回错误码"><a href="#3-9-使用异常代替返回错误码" class="headerlink" title="3.9 使用异常代替返回错误码"></a>3.9 使用异常代替返回错误码</h3><ul>
<li>将指令式函数错误代码返回一反面违反了分割指令与询问，另一方面有可能导致更深层的嵌套解构。使用try&#x2F;catch将错误处理代码从主路径中分离出。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(delatePage(page)  == E_OK) &#123;</span><br><span class="line">    if(registry.deleteReference(page.name) == E_OK) &#123;</span><br><span class="line">        if(configKeys.deleteKey(page.name.makeKey()) == E_OK )&#123;</span><br><span class="line">            console.log(&quot;page deleted&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;configKey not deleted&quot;);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;deletReference from regitry failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&quot;delete failed&quot;);</span><br><span class="line">    return E_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReerence(page.name);</span><br><span class="line">    configKegs.deleteKey(page.name.makeKey());</span><br><span class="line">&#125; catch(e)&#123;</span><br><span class="line">    console.log(e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-1-抽离try-x2F-catch代码块"><a href="#3-9-1-抽离try-x2F-catch代码块" class="headerlink" title="3.9.1 抽离try&#x2F;catch代码块"></a>3.9.1 抽离try&#x2F;catch代码块</h4><ul>
<li>将try&#x2F;catch代码块从主体中抽离出来，形成单独的函数。代码更整洁</li>
</ul>
<h3 id="3-10-别重复自己"><a href="#3-10-别重复自己" class="headerlink" title="3.10 别重复自己"></a>3.10 别重复自己</h3><ul>
<li>重复可能是软件中一切的邪恶根源</li>
</ul>
<h3 id="3-12-如何写出这样的函数"><a href="#3-12-如何写出这样的函数" class="headerlink" title="3.12 如何写出这样的函数"></a>3.12 如何写出这样的函数</h3><ul>
<li>写代码和写文章一样都是需要打磨的，一开始的混乱需要一点点的改变</li>
</ul>
<h2 id="第五章-格式"><a href="#第五章-格式" class="headerlink" title="第五章 格式"></a>第五章 格式</h2><h3 id="5-2-垂直格式"><a href="#5-2-垂直格式" class="headerlink" title="5.2 垂直格式"></a>5.2 垂直格式</h3><ul>
<li>单个文件代码行数在500行以下平均在100左右是一个很好的建议。</li>
</ul>
<h4 id="5-2-2-概念间垂直方向上的区隔"><a href="#5-2-2-概念间垂直方向上的区隔" class="headerlink" title="5.2.2 概念间垂直方向上的区隔"></a>5.2.2 概念间垂直方向上的区隔</h4><ul>
<li>几乎说有代码都是从上往下读，从左往右读。每行展示一个表达式或一个子句，每组代码行展示一条完整的思路。这些思路用空白行区隔开来。</li>
</ul>
<h4 id="5-2-3-垂直方向上的靠近"><a href="#5-2-3-垂直方向上的靠近" class="headerlink" title="5.2.3 垂直方向上的靠近"></a>5.2.3 垂直方向上的靠近</h4><ul>
<li>如果说空白行隔离概念。靠近的代码行则暗示它们之间紧密关系。所以，紧密相关的代码应该相互靠近。</li>
</ul>
<h4 id="5-2-4-垂直距离"><a href="#5-2-4-垂直距离" class="headerlink" title="5.2.4 垂直距离"></a>5.2.4 垂直距离</h4><p>关系密切的概念应该相互靠近。  </p>
<ul>
<li>如变量声明应尽可能靠近其使用位置</li>
<li>相关函数：若某个函数调用了另一个，就应该把它们放在一起，而且调用者应该尽可能放在被调用者上面.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let request = null;</span><br><span class="line">let crawler = null;</span><br><span class="line"></span><br><span class="line">function makeResponse(context, request)&#123;</span><br><span class="line">    let pageName = getPageName(request, &quot;FrontPage&quot;);</span><br><span class="line">    loadPage(pageName, context);</span><br><span class="line">    if(page == null)&#123;</span><br><span class="line">        return notFoundResponse(context, request);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return makePageResponse(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getPageName()&#123;&#125;</span><br><span class="line">    function loadPage()&#123;&#125;</span><br><span class="line">    function notFoundResponse()&#123;&#125;</span><br><span class="line">    function makePageResponse()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>概念相关：概念相关的代码应该放在一起。相关性越强，彼此之间的距离就该越短，相关性赖在如函数间调用，或者使用某个变量，也可能来自执行相似操作的一组函数。</li>
</ul>
<h4 id="5-2-5垂直顺序"><a href="#5-2-5垂直顺序" class="headerlink" title="5.2.5垂直顺序"></a>5.2.5垂直顺序</h4><ul>
<li>一般而言，我们想自上向下展示函数调用顺序。也就是说，被调用的函数应该放在执行调用的额函数下面。 我们希望最重要的概念先出来，指望以包括最少细节的方式表述它们，我们希望底层细节最后出来，而不是一开始就沉迷于细节。</li>
</ul>
<h4 id="5-3-1-水平方向上的间隔与靠近"><a href="#5-3-1-水平方向上的间隔与靠近" class="headerlink" title="5.3.1 水平方向上的间隔与靠近"></a>5.3.1 水平方向上的间隔与靠近</h4><ul>
<li>我们使用空格字符将彼此紧密的连接到一起，也用空格字符将相关性较弱的事物隔开。</li>
</ul>
<h2 id="第6章-对象和数据结构"><a href="#第6章-对象和数据结构" class="headerlink" title="第6章 对象和数据结构"></a>第6章 对象和数据结构</h2><ul>
<li>类并不是间断的取赋值，更多是抽象接口，以便用户无需了解数据的实际就能操作数据本体<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Point()&#123;</span><br><span class="line">    let x;</span><br><span class="line">    let y;</span><br><span class="line"></span><br><span class="line">    function getX()&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    function getY()&#123;</span><br><span class="line">        return Y;</span><br><span class="line">    &#125;</span><br><span class="line">    function getArea()&#123;</span><br><span class="line">        return x*y*2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        x:getX，</span><br><span class="line">        y:getY,</span><br><span class="line">        area:getArea</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>如何写代码</category>
      </categories>
  </entry>
  <entry>
    <title>关键路径渲染</title>
    <url>/2017/08/14/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h2 id="总的来说浏览器要经过一下几个步骤才能将下载好的数据渲染到浏览器界面上"><a href="#总的来说浏览器要经过一下几个步骤才能将下载好的数据渲染到浏览器界面上" class="headerlink" title="总的来说浏览器要经过一下几个步骤才能将下载好的数据渲染到浏览器界面上"></a>总的来说浏览器要经过一下几个步骤才能将下载好的数据渲染到浏览器界面上</h2><h3 id="DOM-CSSOM-x3D-Render-Tree"><a href="#DOM-CSSOM-x3D-Render-Tree" class="headerlink" title="DOM + CSSOM &#x3D; Render Tree"></a>DOM + CSSOM &#x3D; Render Tree</h3><ul>
<li>处理 HTML 标记并解析为 DOM 树。(Parse HTNL)</li>
<li>处理 CSS 标记并解析为 CSSOM 树。(Recalculate style)</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息。(layout)</li>
<li>将各个节点绘制到屏幕上。(panit &amp; Composite Layers )<br><img src="/2017/08/14/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93/dom-css.png" alt="dom-css">  <span id="more"></span></li>
</ul>
<p>这其中将HTML文档解析为DOM与将特定样式表(stylesheet)的规则和资源解析为CSSOM是同步进行的。最终将两者(DOM CSSOM)合并为渲染树(这也意味着一般的css和html都是阻塞界面渲染的资源)此时浏览器就有了足够的信息在浏览器上执行布局(Layout)和绘制(Paint)。  </p>
<p>不幸的是这只是没有引入js的情况</p>
<ul>
<li>因为同步js脚本可以在任何时间使用document.write,因此DOM树构造将在任何时候遇到一个同步js标签时阻塞。</li>
<li>另一方面js可以获取任意节点对象计算样式，这就意味着js脚本也会被CSSOM构造阻塞。<br><img src="/2017/08/14/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93/dom-css-js.png" alt="dom-css-js"><br><img src="/2017/08/14/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93/analysis-dom-css-js.png" alt="analysis-dom-css-js"></li>
</ul>
<p>添加同步js后，在js没执行完之前DOM构造被阻塞，在执行js之前CSSOM必须构造完成</p>
<h3 id="文档-Interactive-amp-DOMContentLoaded"><a href="#文档-Interactive-amp-DOMContentLoaded" class="headerlink" title="文档 Interactive &amp; DOMContentLoaded"></a>文档 Interactive &amp; DOMContentLoaded</h3><ul>
<li>当浏览器完成对所有 HTML 的解析并且 DOM 构建完成文档标记为Interactive。</li>
<li>当 DOM 准备就绪并且没有样式表阻止 JavaScript 执行。文档标记为DOMContentLoaded。此时DOM和CSSOM均准备就绪开始合成render tree。  (这是有有阻塞解释器js的情况，包括同步和含有defer属性js)<br><strong>note</strong>:如果没有阻塞解析器的 JavaScript，则 DOMContentLoaded 将在 domInteractive 后立即触发。同时也意味着无需等待样式表完成加载和解析。</li>
</ul>
<h3 id="关于css的渲染阻塞"><a href="#关于css的渲染阻塞" class="headerlink" title="关于css的渲染阻塞"></a>关于css的渲染阻塞</h3><ul>
<li>默认情况下，CSS 被视为阻塞渲染的资源</li>
<li>我们可以通过媒体类型和媒体查询将一些 CSS 资源标记为不阻塞渲染。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;</span><br><span class="line">&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 40em)&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li>浏览器会下载所有 CSS 资源，无论阻塞还是不阻塞。</li>
</ul>
<h3 id="关于js的DOM阻塞"><a href="#关于js的DOM阻塞" class="headerlink" title="关于js的DOM阻塞"></a>关于js的DOM阻塞</h3><ul>
<li>JavaScript 可以查询和修改 DOM 与 CSSOM。</li>
<li>JavaScript 执行会被 CSSOM 的构造阻塞</li>
<li>除非将 JavaScript 显式声明为异步，否则它会阻止构建 DOM。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critical Path: Script Async&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li>执行我们的内联脚本会阻止 DOM 构建，也就延缓了首次渲染。</li>
<li>浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。</li>
</ul>
<h3 id="优化关键渲染路径"><a href="#优化关键渲染路径" class="headerlink" title="优化关键渲染路径"></a>优化关键渲染路径</h3><ul>
<li>对关键路径进行分析和特性描述：资源数、字节数、长度。</li>
<li>最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</li>
<li>优化关键字节数以缩短下载时间（往返次数）。</li>
<li>优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>初识RESTful</title>
    <url>/2017/10/29/%E5%88%9D%E8%AF%86REST/</url>
    <content><![CDATA[<p>RESTful API 是目前比较成熟和流行的互联网应用程序API设计理论，REST是表述性状态转移(REpresentational State Transfer)的简称。它是一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。</p>
<span id="more"></span>

<p>REST 关键原则</p>
<ul>
<li>为所有“事物”(资源)定义ID</li>
<li>将所有事物链接在一起</li>
<li>使用标准方法</li>
<li>资源多重表述</li>
<li>无状态通信</li>
</ul>
<h3 id="为所有“事物”-资源-定义ID"><a href="#为所有“事物”-资源-定义ID" class="headerlink" title="为所有“事物”(资源)定义ID"></a>为所有“事物”(资源)定义ID</h3><p>对事物使用一致的命名规则，将每个可标记的资源使用一个唯一的标志来标识(URI)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/customers/1234</span><br><span class="line">http://example.com/orders/2007/10/776654</span><br><span class="line">http://example.com/products/4554</span><br><span class="line">http://example.com/processes/salary-increase-234 </span><br><span class="line"></span><br><span class="line">http://example.com/orders/2007/11</span><br><span class="line">http://example.com/products?color=green </span><br></pre></td></tr></table></figure>

<h3 id="将所有事物链接在一起"><a href="#将所有事物链接在一起" class="headerlink" title="将所有事物链接在一起"></a>将所有事物链接在一起</h3><p>任何可能的情况下，使用链接指引可以被标识的事物（资源）。也正是超链接造就了现在的Web。<br>换句话说：是链接的思想。链接是我们在HTML中常见的概念，但是它的用处绝不局限于此（用于人们网络浏览）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;order self=&quot;http://example.com/customers/1234&quot;&gt; </span><br><span class="line">   &lt;amount&gt;23&lt;/amount&gt; </span><br><span class="line">   &lt;product ref=&quot;http://example.com/products/4554&quot;&gt; </span><br><span class="line">   &lt;customer ref=&quot;http://example.com/customers/1234&quot;&gt; </span><br><span class="line">&lt;/customer&gt; &lt;/product&gt;&lt;/order&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用标准方法"><a href="#使用标准方法" class="headerlink" title="使用标准方法"></a>使用标准方法</h3><p>为使客户端程序能与你的资源相互协作，资源应该正确地实现默认的应用协议（HTTP），也就是使用标准的GET、PUT、POST和DELETE方法。</p>
<h3 id="资源多重表述"><a href="#资源多重表述" class="headerlink" title="资源多重表述"></a>资源多重表述</h3><p>针对不同的需求提供资源多重表述。</p>
<h3 id="无状态通信"><a href="#无状态通信" class="headerlink" title="无状态通信"></a>无状态通信</h3><p>一个客户端从某台服务器上收到一份包含链接的文档，当它要做一些处理时，这台服务器宕掉了，可能是硬盘坏掉而被拿去修理，可能是软件需要升级重启——如果这个客户端访问了从这台服务器接收的链接，它不会察觉到后台的服务器已经改变了。</p>
<p>具体实施可以参考 <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南</a></p>
]]></content>
      <tags>
        <tag>构架</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/2017/10/12/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ul>
<li><p>1.AMD&#x2F;CMD&#x2F;CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs&#x2F;SeaJs&#x2F;nodeJs.</p>
</li>
<li><p>2.CommonJs主要针对服务端，AMD&#x2F;CMD主要针对浏览器端，所以最容易混淆的是AMD&#x2F;CMD:服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行.浏览器端要保证效率，需要采用异步加载.</p>
</li>
<li><p>3.AMD&#x2F;CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。</p>
</li>
<li><p>4.AMD&#x2F;CMD的优缺点.一个的优点就是另一个的缺点， 可以对照浏览。   </p>
<pre><code>   AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。
   AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。

  CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。
  CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。
</code></pre>
</li>
<li><p>5.如何使用？CommonJs的话，因为nodeJs就是它的实现，所以使用node就行，也不用引入其他包。AMD则是通过&lt;script&gt;标签引入RequireJs，具体语法还是去看官方文档或者百度一下吧。CMD则是引入SeaJs。</p>
</li>
<li><p>6.commonJS&#x2F;AMD&#x2F;CMD&#x2F;moudle都是动态加载的也是就在代码执行前不知道依赖的，moudle则是静态的，在代码执行之前已经确定了依赖关系。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>commonJS/AMD/CMD/moudle</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Node.js</title>
    <url>/2017/10/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js--%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第1章-Node简介"><a href="#第1章-Node简介" class="headerlink" title="第1章 Node简介"></a>第1章 Node简介</h2><p>  node的主要构架如下图所示：  </p>
<p>  <img src="/2017/10/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js--%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/node1.png" alt="nodeStrcture"><br>  <span id="more"></span></p>
<h2 id="第2章-模块机制"><a href="#第2章-模块机制" class="headerlink" title="第2章 模块机制"></a>第2章 模块机制</h2><p>  Node模块分两类：一类Node提供的核心模块，另一类文件模块  </p>
<p>  Node模块实现主要遵循的是commonJS，要引入模块要经历三个步骤：前两步交替执行，第三步最后执行</p>
<ul>
<li><p>（1）路径分析</p>
<pre><code>核心模块：优先级仅次于缓存加载的，因为已经编译为二进制代码。    
相对绝对路径模块：被当做文件模块处理，转化将路径转换为真实路径，检索，加载，编译，缓存。   
自定义：在加载过程中，node会逐个尝试父级模块路径中路径，直到找到目标文件为止
</code></pre>
</li>
<li><p>（2）文件定位</p>
<p>  有扩展名： 直接定位<br>  无扩展名： Node会按.js .json .node补充扩展名，依次尝试。若未找到相应文件，但得到一个目录Node会将目录当成包来处理，首先在当前目录package.json解析main属性看有无指定入口文件（若无扩展名也会补充扩展名），若失败则依次查找index.js index.json index.node。<br>  若文件定位失败则继续向父级进行后续的路径分析</p>
</li>
<li><p>（3）编译执行：<br> .js文件： 通过fs模块同步读取文件后编译执行<br> .node文件： 这是用C&#x2F;C++编写的扩展文件，通过dlopen()方法加载最后编译生成文件<br> .json文件： 通过fs模块同步读取文件后，用JSON.parse()解析返回结果<br> 其他扩展名文件： 都会当做.js文件载入</p>
<p>Node也会缓存不过是缓存的是编译和执行后的对象，require()方法对相同模块的二次加载都是优先采用缓存。</p>
</li>
</ul>
<h2 id="第5章-内存控制"><a href="#第5章-内存控制" class="headerlink" title="第5章 内存控制"></a>第5章 内存控制</h2>]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 块级绑定</title>
    <url>/2017/06/20/%E7%AC%AC1%E7%AB%A0%20%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="块绑定（Block-Bindings）"><a href="#块绑定（Block-Bindings）" class="headerlink" title="块绑定（Block Bindings）"></a>块绑定（Block Bindings）</h2><p>以前在javascript中变量声明是比较复杂的一部分，大多数基于c的语言中变量（或绑定）被创建于变量声明的地方，然而javascript中并不是这样，变量创建的方式取决于你如何声明它们，并且ECMAScript 6 提供的了让控制作用域(scope)更容易的方法，在这章里将会展示为什么老式 var 声明让人困惑，同时介绍SCMAScript 6中的块绑定，并提供最佳实践。</p>
<span id="more"></span>


<h3 id="变量声明和提升"><a href="#变量声明和提升" class="headerlink" title="变量声明和提升"></a>变量声明和提升</h3><p>用var声明的变量一律被当做在函数（如果在函数外部声明，则为全局变量）顶部声明的变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getValue(condition) &#123;</span><br><span class="line"></span><br><span class="line">    if (condition) &#123;</span><br><span class="line">        var value = &quot;blue&quot;;</span><br><span class="line"></span><br><span class="line">        // other code</span><br><span class="line"></span><br><span class="line">        return value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // value exists here with a value of undefined</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // value exists here with a value of undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你对javscript不熟悉，你也许会预想value这个变量只有当condition被求值为true是才被创建，但无论求condition值是什么变量value都被创建了，下面代码是javascript引擎改变getValue这个函数成这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getValue(condition) &#123;</span><br><span class="line"></span><br><span class="line">    var value;</span><br><span class="line"></span><br><span class="line">    if (condition) &#123;</span><br><span class="line">        value = &quot;blue&quot;;</span><br><span class="line"></span><br><span class="line">        // other code</span><br><span class="line"></span><br><span class="line">        return value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value 变量的声明被提升到顶部，同时它的初始化还在原来那个地方。这意味着value变量可以在else括号后面访问到，如果从那儿访问，这个变量将只是undefined，因为它还没被初始化。</p>
<h3 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h3><p>块级声明意味着那些声明的变量不能在给定块级作用外访问，块级作用域也称做词法作用域被创建于：</p>
<ul>
<li>1 函数里面</li>
<li>2 双大括号里面（{}）<br>块级作用域是许多基于c语言的工作方式，同时在ECAMScript 6 中引入块级声明意在引进相同的灵活性（并统一性）到javascript中</li>
</ul>
<h4 id="Let-声明"><a href="#Let-声明" class="headerlink" title="Let 声明"></a>Let 声明</h4><p>let 声明语法和var声明语法一样，你基本上可以用let替换var声明变量，但是le的变量作用域限制在当前代码块（这里有少量细微差别在后面讨论）。因为let声明不会提升到代码块顶部，你也许总想将let声明放在代码块顶部，这样在整个代码都可以获取到，这里是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getValue(condition) &#123;</span><br><span class="line"></span><br><span class="line">    if (condition) &#123;</span><br><span class="line">        let value = &quot;blue&quot;;</span><br><span class="line"></span><br><span class="line">        // other code</span><br><span class="line"></span><br><span class="line">        return value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // value doesn&#x27;t exist here</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // value doesn&#x27;t exist here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一版的getValue函数表现的更像你期待中的其他基于c的语言了，因为变量value是用let声明取代了var，这种声明并不会变量提升到函数声明顶部，并且变量value在执行完if块后不再能访问到，一旦if条件求值为false后value将永远不会声明或初始化。</p>
<h4 id="禁止重声明"><a href="#禁止重声明" class="headerlink" title="禁止重声明"></a>禁止重声明</h4><p>如果一个标识符已经在一个作用域定义过，然后再用let在这个作用域定义这个标识符将后造成一个错误抛出，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var count = 30;</span><br><span class="line"></span><br><span class="line">//Syntax error</span><br><span class="line">let count = 40;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，count被声明了两次：一次用var声明然后再用一次let声明。因为let不会在一个已经声明过的作用域重声明，如果重声明将抛出一个error。另一方面，如果let声明在一个包含作用域中创建同名的变量是不会抛出错误的，如下面示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var count = 30;</span><br><span class="line"></span><br><span class="line">// Does not throw an error</span><br><span class="line">if (condition) &#123;</span><br><span class="line"></span><br><span class="line">    let count = 40;</span><br><span class="line"></span><br><span class="line">    // more code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>let声明没有抛出一个异常是因为它创建了一个新的已经声明过的变量count在if语句里，而不是在一个相邻的块。在这个if块里，这个新的变量遮盖了这个全局count，防止获取到全局count直到执行过这个if块。</p>
<h4 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h4><p>在ECMAScript6中你也可以用const声明语法定义变量。用const声明的变量被当做常量，这意味着它们的值一旦给初始化后不能改变。因为这个原因，每个count变量必须在声明的同时初始化，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Valid constant</span><br><span class="line">const maxItems = 30;</span><br><span class="line"></span><br><span class="line">// Syntax error: missing initialization</span><br><span class="line">const name;</span><br></pre></td></tr></table></figure>
<p>maxItems 变量已经初始化了，所以cont声明将会起效没问题。如果试着运行包含name变量这段代码将会造成一个语法错我，因为name没有初始化。</p>
<h5 id="const声明和let声明对比"><a href="#const声明和let声明对比" class="headerlink" title="const声明和let声明对比"></a>const声明和let声明对比</h5><p>const声明和let声明一样是块级声明。这意味着常量一旦执行完所在块后将不再能访问，并且声明也不会提升，如下面示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    const maxItems = 5;</span><br><span class="line"></span><br><span class="line">    // more code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// maxItems isn&#x27;t accessible here</span><br></pre></td></tr></table></figure>
<p>在这个代码中，常量maxItems声明在if语句里，一旦这个语句执行完成后，maxItems将在这个块外不再能访问到。  </p>
<p>const与let另一个相似的地方，如果一个标识符在同一个作用域中已经定义过用const再次定义将会抛出一个错误。用var（全局或函数作用域）或者let（块级作用域）什么都没关系，如下例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var message = &quot;Hello!&quot;;</span><br><span class="line">let age = 25;</span><br><span class="line"></span><br><span class="line">// Each of these would throw an error.</span><br><span class="line">const message = &quot;Goodbye!&quot;;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure>
<p>这两个const声明单独声明都会有效，但是介于前面的var和let声明没有一个conts声明将会有效。<br>let和const尽管这么多相似的地方，但是这里有个巨大的区别点值得记住，无论在严格或者非严格模式如果尝试赋值一个原先定义过的const变量将会抛出一个错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const maxItems = 5;</span><br><span class="line"></span><br><span class="line">maxItems = 6;      // throws error</span><br></pre></td></tr></table></figure>
<p>这里的常量和其他语言很相似的是这个maxItems变量将不能重新赋值，然而不像其他语言的常量，如果这个常量是一个对象将有可能被修改。</p>
<h5 id="用const声明对象"><a href="#用const声明对象" class="headerlink" title="用const声明对象"></a>用const声明对象</h5><p>一个const声明防止其修改其绑定而非值本身。这意味着const声明一个对象将不会防止其修改这个变量的值（译者注释：属性值）。如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// works</span><br><span class="line">person.name = &quot;Greg&quot;;</span><br><span class="line"></span><br><span class="line">// throws an error</span><br><span class="line">person = &#123;</span><br><span class="line">    name: &quot;Greg&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，被绑定的person以一个属性值的对象创建，它是可能改变person.name而不引起一个错误的因为它是改变的person包含的属性值而并没改变person绑定到一个对象本身。当这里的代码尝试赋值person（因此尝试改变绑定本身）将会有一个错误抛出，这个在const中细微的差别容易引起误解。只要记住：const防止其改变绑定，而不是绑定的值。</p>
<h4 id="临时性死区（TDZ）"><a href="#临时性死区（TDZ）" class="headerlink" title="临时性死区（TDZ）"></a>临时性死区（TDZ）</h4><p>一个用let或者const声明的变量不能被访问直到声明过后。尝试着这样做将会导致一个引用类型错误（reference error）,即便用正常情况下安全操作符 typeof。如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    console.log(typeof value);  // ReferenceError!</span><br><span class="line">    let value = &quot;blue&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，变量value用let定义和初始化，但是语句将永远不会执行因为前面句抛出一个异常。这个关于value的话题存在于javascript社区被称作临时性死区（TDZ）。TDZ在ECNAScript没有明确的定义，但是TDZ这个条目常被用来形容let或const声明时不能在其声明前访问。这个部分将讲述一些关于TDZ引起的细微差别，同时这里的例子全部用let，值得注意的是这些例子同样适用于const。  </p>
<p>当javascript引擎遍历一个即将执行的代码块并找到一个变量声明是，它要么是var在全局或者函数内通过变量提升，抑或let或者const在TDZ的声明，任何尝试获取在TDZ的变量都将在执行时引起一个错误。只有将这个变量从TDZ移除，然后一旦执行过这个变量声明后才能安全的使用。<br>如上例所示let或const声明同样适用于任何尝试使用一个变量在它定义之前，尽管使用安全操作符typeof。然而当变量在声明块的外边是可以使用typeof的，尽管得到的不是你后面赋值的，看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof value);     // &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">if (condition) &#123;</span><br><span class="line">    let value = &quot;blue&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为变量value没有在TDZ所有当typeof操作符执行在变量声明块外，typeof仅仅返回一个”undefined”,这意味着没有value绑定到当前作用域。<br>TDZ只是块绑定（block blindings）一个特别的方面,另一个方面体现在使用在循环上。</p>
<h4 id="在循环中的块绑定"><a href="#在循环中的块绑定" class="headerlink" title="在循环中的块绑定"></a>在循环中的块绑定</h4><p>也许程序员最希望看到看到块级作用域出现在for循环中，循环计数变量一次性使用这意味着只能在循环中使用，但这在javascript中并不常见。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    process(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// i is still accessible here</span><br><span class="line">console.log(i);    </span><br></pre></td></tr></table></figure>
<p>在其他语言中块级作用域是默认的，在上面这个例子中只用当i变量只能在for循环中访问到时才能到达我们预期的效果，然而在这里的i任然在for循环后可以访问到，这是因为var声明被提升了，如果用let代替，将会表现我们预期的效果，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    process(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// i is not accessible here - throws an error</span><br><span class="line">console.log(i);</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，变量i只存在于for循环，一旦循环结束，变量i就不能再其他地方访问到了。</p>
<h4 id="循环中的函数"><a href="#循环中的函数" class="headerlink" title="循环中的函数"></a>循环中的函数</h4><p>var的特性为函数在循环中长期制造着问题，因为循环变量是从外层循环作用域中获取，看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var funcs = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    funcs.push(function() &#123; console.log(i); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(function(func) &#123;</span><br><span class="line">    func();     // outputs the number &quot;10&quot; ten times</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你也许通常期待这份代码会打印出数字0到9，但是结果是数字10打印了十遍，那是因为在每次循环遍历中共享相同的i，一旦循环结束i的值就为10，所以当console.log(i)被调用时，i的值就被打印出来。<br>为了修复这个问题，开发者使用一个立即执行函数在for循环内部，强迫每次循环传递一个i的复制变量，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var funcs = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    funcs.push((function(value) &#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            console.log(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(function(func) &#123;</span><br><span class="line">    func();     // outputs 0, then 1, then 2, up to 9</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这版代码中用了一个立即执行函数在循环的内部，变量i被传到立即执行函数中，这意味着创建了一份复制并储存到value中。所以每次迭代循环才能出现预期的0到9。幸运的是在EMACSript6中使用块级绑定的let和const可以轻松的做到。</p>
<h4 id="循环中的let声明"><a href="#循环中的let声明" class="headerlink" title="循环中的let声明"></a>循环中的let声明</h4><p>一个let声明可以有效的简化和替代先前的立即执行函数（IIFE）。在每个循环遍历中，循环创建了一个新的变量并用先前遍历的变量名初始化它，这意味着你可以生路掉立即执行函数，并得到相同的结构，想下面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var funcs = [];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    funcs.push(function() &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(function(func) &#123;</span><br><span class="line">    func();     // outputs 0, then 1, then 2, up to 9</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个循环和先前的用var和立即执行函数效果一样，但是清晰，整洁。let声明在每次循环时创建一个新的变量i，所以每个函数在循环内部得到属于自己的i，同理for-in和for-of循环，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var funcs = [],</span><br><span class="line">    object = &#123;</span><br><span class="line">        a: true,</span><br><span class="line">        b: true,</span><br><span class="line">        c: true</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">for (let key in object) &#123;</span><br><span class="line">    funcs.push(function() &#123;</span><br><span class="line">        console.log(key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(function(func) &#123;</span><br><span class="line">    func();     // outputs &quot;a&quot;, then &quot;b&quot;, then &quot;c&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中for-in循环与for循环展现了同样的表现行为，每次循环遍历，一个新的key绑定创建，所以每个函数拥有属于自己的拷贝变量key，结果就是每个函数输出不同的value，如果是用var声明的key，全部的函数将输出”c”。</p>
<h4 id="在循环中的常量声明"><a href="#在循环中的常量声明" class="headerlink" title="在循环中的常量声明"></a>在循环中的常量声明</h4><p>在EMASCript6中没有明确的声明不允许conts声明在循环中使用，但是这里有不同的表现行为基于你选择的for循环类型，对于普通for循环，你可以用const进行初始化，但是一旦你试着改变这个值它将抛出一个错误，如示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var funcs = [];</span><br><span class="line"></span><br><span class="line">// throws an error after one iteration</span><br><span class="line">for (const i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    funcs.push(function() &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，i变量以常量声明，第一次遍历循环，当i是0时，执行成功，但i++执行时将会抛出一个错误，因为它尝试改变一个常量，如此以后，你只能用const变量进行声明你不会改变的循环中。  </p>
<p>另一方面在for-in或for-of中使用const和let声明变量并无区别，所以下面代码将不会抛出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var funcs = [],</span><br><span class="line">    object = &#123;</span><br><span class="line">        a: true,</span><br><span class="line">        b: true,</span><br><span class="line">        c: true</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">// doesn&#x27;t cause an error</span><br><span class="line">for (const key in object) &#123;</span><br><span class="line">    funcs.push(function() &#123;</span><br><span class="line">        console.log(key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(function(func) &#123;</span><br><span class="line">    func();     // outputs &quot;a&quot;, then &quot;b&quot;, then &quot;c&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这段代码几乎和上面”循环中的let声明”一模一样，唯一不同的是kety的值在循环中不能改变，const在for-of和for-in循环起作用是因为循环初始器创建了一个新的绑定在每个遍历中而不是尝试改变已经存在的绑定。</p>
<h4 id="全局块绑定"><a href="#全局块绑定" class="headerlink" title="全局块绑定"></a>全局块绑定</h4><p>let和const另一个不同于var是在全局作用域的行为，当var在全局作用域使用时，它创建了一个新的全局变量，这意味着一个全局变量属性（在浏览器中是window）。同时也意味着你也许意外的重写了一个已经存在的全局变量，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// in a browser</span><br><span class="line">var RegExp = &quot;Hello!&quot;;</span><br><span class="line">console.log(window.RegExp);     // &quot;Hello!&quot;</span><br><span class="line"></span><br><span class="line">var ncz = &quot;Hi!&quot;;</span><br><span class="line">console.log(window.ncz);        // &quot;Hi!&quot;</span><br></pre></td></tr></table></figure>
<p>尽管RegExp已经在全局对象window上定义过了，但是被var声明重写了这是不安全的。示例代码示范了一个新的全局变量RegExp重写原有变量。同样相似的ncz被定义成一个全局变量并且立即被定义成window上的一个属性，这是javascript的工作方式。  </p>
<p>如果你换let或const在全局声明，在全局作用域产生一个新的绑定但是不会添加属性到全局对象上，这也意味着你不能通过let或者const重新全局变量，你只能屏蔽它，这里是实例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// in a browser</span><br><span class="line">let RegExp = &quot;Hello!&quot;;</span><br><span class="line">console.log(RegExp);                    // &quot;Hello!&quot;</span><br><span class="line">console.log(window.RegExp === RegExp);  // false</span><br><span class="line"></span><br><span class="line">const ncz = &quot;Hi!&quot;;</span><br><span class="line">console.log(ncz);                       // &quot;Hi!&quot;</span><br><span class="line">console.log(&quot;ncz&quot; in window);           // false</span><br></pre></td></tr></table></figure>
<p>在这段实例代码中一个使用let声明的RegExp创建绑定并屏蔽全局RegExo。这意味着window.RegExp和RegExp并不全等，所以在全局作用域中并不存在破坏，同样，conts声明为ncz创建的绑定也不会在全局对象上创建一个属性。这种能力让let和const在全局作用域上申明更加安全。</p>
<h4 id="块级绑定最佳实践进化过程"><a href="#块级绑定最佳实践进化过程" class="headerlink" title="块级绑定最佳实践进化过程"></a>块级绑定最佳实践进化过程</h4><p>当使用使用ECMAScript6开发时，这里流传着一个信任，你应该默认使用let而不是var声明变量，对于很多javascript开发者来说，let的特性刚好是我们期待中的var。所以直接替换显得很有道理，在这种情况下，当你需要修改保护是你应该使用const声明变量。<br>然而当更多的开发者赚到使用ECMAScript6开发时，一个新的理念更加流行起来：默认使用const声明变量，只有当你知道变量将会改变时使用let声明。这其中的原因是大多数变量在其初始化后不要改变其值，因为预想不到的值改变通常是bugs的源头。这个想法具有巨大的吸引力并且值得你在未来使用ECMAScript6中使用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>let和const的块级绑定将词法作用域引入了javscript。这些声明将不会提升只会存在于声明的块中。它们提供的表现行为将更加像其他语言并且更少的造成意想不到的错误，副作用是你将不能像以前声明一样访问它们，甚至不能用以前的安全操作符typeof。当你在块级绑定之前试图获取一个变量时将会引起一个因为TDZ造成的错误。<br>在许多情况下，let和const与var的表现都很相似，然而这并不适用于循环，对于for-in和for-of循环let和const都在每次循环创建一个新的绑定，而不是循环后的最后一项（像var一样）。同样的let声明也适用于for，当尝试吧const用在for循环并且改变const变量时将造成一个错误。<br>当前的最佳实践是默认使用const只当你知道变量将会改变时使用let，这样做会保证你代码一定程度的不可变形，从而达到防治一定类型的错误。</p>
]]></content>
      <categories>
        <category>javscript</category>
      </categories>
  </entry>
  <entry>
    <title>第二章 字符串与正则表达式</title>
    <url>/2017/06/24/%E7%AC%AC2%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="字符串与正则表达式"><a href="#字符串与正则表达式" class="headerlink" title="字符串与正则表达式"></a>字符串与正则表达式</h2><p>字符串无疑在编程中最重要的类型之一，它们几乎出现在每个高级程序语言中，并且能高效的运用它们是开发者创造有用程序的基础，甚至于正则表达能给开发者额外的能力使用字符串也变得非常重要。记住这些事实以后，ECMAScript6的创建者通过对字符串和正则增加新属性和长久以来缺失的方法来达到提升。这章中我们将一一浏览这两种改变。</p>
<span id="more"></span>

<h3 id="更好的Unicode支持"><a href="#更好的Unicode支持" class="headerlink" title="更好的Unicode支持"></a>更好的Unicode支持</h3><p>在ECMAScript6之前，javscript字符串以16位字符编码（UTF-16）。每连续的16位是一个编码单位代表一个字符。所有的字符串属性和方法如length属性，charAt()方法都是基于16位编码单位，16位通常是满足包含的任何字符，但是多亏字符扩展到Unicode以后就不再满足了。</p>
<h3 id="UTF-16编码字"><a href="#UTF-16编码字" class="headerlink" title="UTF-16编码字"></a>UTF-16编码字</h3><p>限制着字符长度到16位是不可能满足Uncode声明提供一个为全球每个字符提供一个独一无二的标识符的目的。那些全局独一无二的标识符被称作码字，从简单的数字0开始，码字正是你也许会想的字符编码，一个数字代表一个字符，一个字符编码必须让码字编译成内部对应关系（如UTF-16）的代码单元，一个码字可以由多个代码单元组成。 </p>
<p>在UTF-16中第一个2^16^的码字代表一个单独16位代码单元，这个区域的被称作BMP，任何不在这个范围内的码字被当做在其中一个补充平面中，在补充平面中的码字不再能单独用16字节表示。在UTF-16通过引进代理编码对来解决这个问题，代理编码对表示一个码子用两个16字节编码单元表示，这就意味着任何一个单独字符在字符串中要么用一个（16字节BMP）或者两个（32字节）编码单元表示。  </p>
<p>在ECAMScript5中，所有的字符串操作都是基于一个16位编码单元的，这意味着你会在UTF-16中包含代理编码对中得到意想不到的结果，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var text = &quot;𠮷&quot;;</span><br><span class="line"></span><br><span class="line">console.log(text.length);           // 2</span><br><span class="line">console.log(/^.$/.test(text));      // false</span><br><span class="line">console.log(text.charAt(0));        // &quot;&quot;</span><br><span class="line">console.log(text.charAt(1));        // &quot;&quot;</span><br><span class="line">console.log(text.charCodeAt(0));    // 55362</span><br><span class="line">console.log(text.charCodeAt(1));    // 57271</span><br></pre></td></tr></table></figure>
<p>这个单独的Unicode字符”𠮷”使用代理编码对表示的，并且在javascript中字符串操作都是把这个字符当做两个16位字符。这意味着：</p>
<ul>
<li>当text的长度应该为1时结果为2</li>
<li>一个正则表达式在匹配单个字符串的时候失败，这是因为js把它当做两个字符</li>
<li>字符串方法chartAt()不能返回一个正确字符串，因为没有一个与之对应的可打印16位编码。</li>
</ul>
<p>chatCodeAt()方法也不能识别对应字符属性。它只返回与编码单元对应的16位数字，但这就是你能在ECMAScript5中得到最为接近text真实值的方法。  </p>
<p>在另一方面ECMAScript6，强制性UTF-16字符串编码来解决像上面的强调的问题，一系列的基于代理编码对标准编码，其余的这个章节将示例这些标准。</p>
<h4 id="codePointAt-方法"><a href="#codePointAt-方法" class="headerlink" title="codePointAt()方法"></a>codePointAt()方法</h4><p>在ECMAScript6中添加了一个完全支持UTF-16的方法codePointAt(),这个方法将根据给定的字符串位置检索对应Unicode编码，这个方法接受的是编码单元位置而不是字符位置并且返回一个整数，如下例代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var text = &quot;𠮷a&quot;;</span><br><span class="line"></span><br><span class="line">console.log(text.charCodeAt(0));    // 55362</span><br><span class="line">console.log(text.charCodeAt(1));    // 57271</span><br><span class="line">console.log(text.charCodeAt(2));    // 97</span><br><span class="line"></span><br><span class="line">console.log(text.codePointAt(0));   // 134071</span><br><span class="line">console.log(text.codePointAt(1));   // 57271</span><br><span class="line">console.log(text.codePointAt(2));   // 97</span><br></pre></td></tr></table></figure>
<p>当为BMP字符时codePointAt()方法和charCodeAt()返回是相同的，上例中第一个在text中字符是非BMP字符这意味着这个字符由两个编码单元组成，同时长度属性为3而不是2。当参数为0时方法charCodeAt()只返回第一个编码单元，但是codePointAt()不管字码包含是不是多个编码单元都将返回一个完整的字码。两个方法在参数为1（第一个字符的第二个编码单元）和2（’a’字符）时返回的都一致。  </p>
<p>在字符上调用codePointAt()方法是最简单判定字符是否用一个或者两个编码单元（注：这里原作者写的是code points 但是应该是code units 编码单元）,如下面这个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function is32Bit(c) &#123;</span><br><span class="line">    return c.codePointAt(0) &gt; 0xFFFF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(is32Bit(&quot;𠮷&quot;));         // true</span><br><span class="line">console.log(is32Bit(&quot;a&quot;));   </span><br></pre></td></tr></table></figure>
<p>上例中用十六进制的FFFF表示16字节，所以任何超过这个数字的码字一定有两个编码单元构成的（总共32字节）</p>
<h4 id="方法String-fromCodePoint"><a href="#方法String-fromCodePoint" class="headerlink" title="方法String.fromCodePoint()"></a>方法String.fromCodePoint()</h4><p>当ECMAScript 提供一个方法将字符转换为数字，同样也会提供一个将数字转换到字符的。如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(String.fromCodePoint(134071));  // &quot;𠮷&quot;</span><br></pre></td></tr></table></figure>
<p>你把String.fromCodePoint()当做String.fromCharCode()升级版就可以了。当字符在BMP范围内时两者都返回相同的结构。只有当字符范围超出了BMP时才会有区别。</p>
<h4 id="方法normalize"><a href="#方法normalize" class="headerlink" title="方法normalize()"></a>方法normalize()</h4><p>Unicode另一个有趣的地方是，不同的字符在排序或者比较的时候被认为相等。这里有两种不同的方式定义这些关系，首先规范性的相等指的是两个序列码点在各个方面都看起来都可以相互替换。如一个由两个字符拼接起来的的字符可以规范性的相等与另一个字符。第二种关系为兼容性的相等，两个兼容性相等的序列码点看起来不同但是可以在某些情况下互换。<br>因为这些关系某些本质上相同的文本可能包含不同的码点序列，如字符”æ”和包含两个字符”ae”也许可以互换但是严格上并不相等触发用某种方式标准化。  </p>
<p> ECMAScript6 为Unicode标准化提供了normalize()方法，这个方法可以接受以下字符串参数进行Unicode标准化。</p>
<ul>
<li>“NFC” 默认</li>
<li>“NFD”</li>
<li>“NFKC”</li>
<li>“NFKD”<br> 解释这四种方式的差别超出了本书的范围了，只要记住当比较字符串时，两个字符串必须标准化为同一种格式后再比较，如下例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var normalized = values.map(function(text) &#123;</span><br><span class="line">    return text.normalize();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">normalized.sort(function(first, second) &#123;</span><br><span class="line">    if (first &lt; second) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (first === second) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 上面的代码将在value数组中的字符串同一标准化后才能进行准确的排序，你也可以在原始数组上调用normalize(),如下：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> values.sort(function(first, second) &#123;</span><br><span class="line">    var firstNormalized = first.normalize(),</span><br><span class="line">        secondNormalized = second.normalize();</span><br><span class="line"></span><br><span class="line">    if (firstNormalized &lt; secondNormalized) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (firstNormalized === secondNormalized) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p> 再次说明，用相同的方式序列号是相当重要的，上面的例子用的是默认的NFC，但是你也可以轻松指定其中一种，如下：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">values.sort(function(first, second) &#123;</span><br><span class="line">    var firstNormalized = first.normalize(&quot;NFD&quot;),</span><br><span class="line">        secondNormalized = second.normalize(&quot;NFD&quot;);</span><br><span class="line"></span><br><span class="line">    if (firstNormalized &lt; secondNormalized) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (firstNormalized === secondNormalized) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br> 你之前也许从来没有担心过Unicode标准化，那么你也许现在不会过多使用这个方法，但是如果你曾经开发过国际化应用，你绝对发现normalize()相当有用。</p>
<p> 在ECMAScript中不止这些方法对Unicode字符串进行了改进，es6还增加了两个有用的语法。</p>
<h3 id="正则表达式中u修饰符"><a href="#正则表达式中u修饰符" class="headerlink" title="正则表达式中u修饰符"></a>正则表达式中u修饰符</h3><p> 通过正则表达式你可以对字符串完成许多普通的操作，但是记住，正则表达式是以16位字节的编码单元代表一个字符作为前提的，为了解决这个问题ECMAScript6定义了表示Unicode标准的u修饰符。</p>
<h4 id="实战修饰符u"><a href="#实战修饰符u" class="headerlink" title="实战修饰符u"></a>实战修饰符u</h4><p>当一个正则表达式设置了修饰符u时，就将模式从编码单元切换到字符模式。这意味着正则表达式能正确识别字符串中代理编码对，看下面代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var text = &quot;𠮷&quot;;</span><br><span class="line"></span><br><span class="line">console.log(text.length);           // 2</span><br><span class="line">console.log(/^.$/.test(text));      // false</span><br><span class="line">console.log(/^.$/u.test(text));     // true</span><br></pre></td></tr></table></figure>
<p>正则表达式&#x2F;^.$&#x2F;将匹配一个字符串只包含一个字符，当没有设置u修饰符的时候，正则表达式基于编码单元匹配，所以日语字符（用两个编码单元表示）将不会被这个正则表达式匹配，一旦设置u修饰符后正则表达式基于字符而不是编码单元匹配所以能匹配日语字符。  </p>
<h4 id="计算码位数量"><a href="#计算码位数量" class="headerlink" title="计算码位数量"></a>计算码位数量</h4><p>不幸的是，ECMAScript6并没提供计算字符串的码点数方法，但是通过u修饰符，你可以使用正则表达式计算出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function codePointLength(text) &#123;</span><br><span class="line">    var result = text.match(/[\s\S]/gu);</span><br><span class="line">    return result ? result.length : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(codePointLength(&quot;abc&quot;));    // 3</span><br><span class="line">console.log(codePointLength(&quot;𠮷bc&quot;));   // 3</span><br></pre></td></tr></table></figure>
<p>这个例子中调用match()来匹配text，在Unicode中的字符串”abc”和”𠮷bc”都包含3个字符，所以长度也是3.  </p>
<h4 id="检查u修饰符支持程度"><a href="#检查u修饰符支持程度" class="headerlink" title="检查u修饰符支持程度"></a>检查u修饰符支持程度</h4><p>既然u修饰符时新的语法变化，在不兼容ECMAScript6的js引擎中使用将会导致一个语法错误。最安全的检查支持程度的函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hasRegExpU() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var pattern = new RegExp(&quot;.&quot;, &quot;u&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch (ex) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中在RegExp构造器总使用u修饰符参数，在支持这个语法的老js引擎中也会正确，但是在不支持的引擎中将会报错。</p>
<h3 id="其他关于字符串的改变"><a href="#其他关于字符串的改变" class="headerlink" title="其他关于字符串的改变"></a>其他关于字符串的改变</h3><p>js的字符串总是落后与其他相似特性的语言，如只有在ECMACript5中strings最终得到了trim()方法，而在ES6中将会用新的方法继续扩展解析字符串能力。</p>
<h4 id="识别子字符串的方法"><a href="#识别子字符串的方法" class="headerlink" title="识别子字符串的方法"></a>识别子字符串的方法</h4><p>在js中第一个被引进来判定字符串是否包含其他字符串的方法，但在ES6中包含如下3个方法，他们被设计成相同的作用：</p>
<ul>
<li>方法includes() 包含指定文本返回true否则返回false</li>
<li>方法startWith() 包含以指定文本开始的String返回true否则返回false</li>
<li>方法endWith() 包含以指定文本结束的String返回true否则返回false</li>
</ul>
<p>每个方法接受两个参数：一个搜索文本和一个可选的搜索起点下标，当连个参数都提供时，includes()和startWith()从下标处开始匹配同时endsWith()从匹配字符长度减去下标处开始搜索，当第二个参数省略掉后，includes()和startWith()从字符串开头开始匹配，endWith()从最后开始匹配，事实上第二个参数将减少搜寻的数量，这里是例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var msg = &quot;Hello world!&quot;;</span><br><span class="line"></span><br><span class="line">console.log(msg.startsWith(&quot;Hello&quot;));       // true</span><br><span class="line">console.log(msg.endsWith(&quot;!&quot;));             // true</span><br><span class="line">console.log(msg.includes(&quot;o&quot;));             // true</span><br><span class="line"></span><br><span class="line">console.log(msg.startsWith(&quot;o&quot;));           // false</span><br><span class="line">console.log(msg.endsWith(&quot;world!&quot;));        // true</span><br><span class="line">console.log(msg.includes(&quot;x&quot;));             // false</span><br><span class="line"></span><br><span class="line">console.log(msg.startsWith(&quot;o&quot;, 4));        // true</span><br><span class="line">console.log(msg.endsWith(&quot;o&quot;, 8));          // true</span><br><span class="line">console.log(msg.includes(&quot;o&quot;, 8));          // false</span><br></pre></td></tr></table></figure>
<p>前六个示例中都没有设置第二个参数，所以如果需要的话它们将匹配整个字符串。最后三个示例中只匹配了部分字符串。msg.startsWith(“o”, 4)从msg下标4开始匹配。msg.endsWith(“o”,8)是从字符串下标4开始，因为字符串长度12减8等于4。msg.includes(“o”, 8)是从字符串下标8开始的这正是”world”中的”r”。  </p>
<p>这几个方法最终都返回boolean值，如果你想要获取实际匹配的下标可以用indexOf()或者lastIndexOf()</p>
<h4 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h4><p>ES6对字符串新加了一个repeat()方法,这个方法接受一个数字参数表示这个字符串重复的次数，它会返回一个规定重复次数新字符串。如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;x&quot;.repeat(3));         // &quot;xxx&quot;</span><br><span class="line">console.log(&quot;hello&quot;.repeat(2));     // &quot;hellohello&quot;</span><br><span class="line">console.log(&quot;abc&quot;.repeat(4));       // &quot;abcabcabcabc&quot;</span><br></pre></td></tr></table></figure>
<p>这个方法比上面所有的方法简单，在操作文本时尤其有用，特别是在代码格式化工具中的创建缩减基本，像下面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// indent using a specified number of spaces</span><br><span class="line">var indent = &quot; &quot;.repeat(4),</span><br><span class="line">    indentLevel = 0;</span><br><span class="line"></span><br><span class="line">// whenever you increase the indent</span><br><span class="line">var newIndent = indent.repeat(++indentLevel);</span><br></pre></td></tr></table></figure>
<p>调用第一个repeat()时创建了4个空格的字符串，然后用变量indentLevel跟踪缩减基本，最后再调用repeat()加上递增变量indentLevel控制空格的个数。</p>
<h3 id="其他关于正则表达式的变化"><a href="#其他关于正则表达式的变化" class="headerlink" title="其他关于正则表达式的变化"></a>其他关于正则表达式的变化</h3><p>在javascript中正则表达式对于操作字符串是相当重要，像这门语言的其他部分，它们在最近的版本中都没有太多的变化，然而ES6也随着字符串的改变而改变更新。</p>
]]></content>
      <categories>
        <category>javscript</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 函数</title>
    <url>/2017/06/30/%E7%AC%AC3%E7%AB%A0%20%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数在任何语言中都是相当重要的一部分，在ES6之前，js的函数从这门语言被创建起就没有改变过。它留下了一些列问题和怪异行为从而直接导致了更加容易出错和实现基本的功能需要更多的代码。  </p>
<span id="more"></span>


<h3 id="函数中的默认参数值"><a href="#函数中的默认参数值" class="headerlink" title="函数中的默认参数值"></a>函数中的默认参数值</h3><p>js中函数独特之处在于不管函数声明定义了多少个参数实际调用时可以传任何数量的参数，这个特性可以让你将函数定义成可以处理不同数量参数的函数，当参数没有传时通常由默认值填充。这个章节将讲解如何通过argument对象上的一些重要信息在ES6前后使用默认参数，使用参数表达式和其他的TDZ。</p>
<h4 id="在ES5中模仿默认参数值"><a href="#在ES5中模仿默认参数值" class="headerlink" title="在ES5中模仿默认参数值"></a>在ES5中模仿默认参数值</h4><p>在ES5之前你会使用下例方式来创建一个拥有默认参数值的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function makeRequest(url, timeout, callback) &#123;</span><br><span class="line"></span><br><span class="line">    timeout = timeout || 2000;</span><br><span class="line">    callback = callback || function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // the rest of the function</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，timeout和callback时间上都是可选参数，这是因为它们在调用时没有传入时都会有一个默认值。逻辑或运算符（||）当第一个为假时总会返回第二个的值，既然形参没有提过就会被置为undefined,逻辑或运算符常常被用在提供默认参数，这里有一个漏洞，在实际调用中timeout也可能为0，因为0在boolean()求值为false所以timeout将会被替换为200.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function makeRequest(url, timeout, callback) &#123;</span><br><span class="line"></span><br><span class="line">    timeout = (typeof timeout !== &quot;undefined&quot;) ? timeout : 2000;</span><br><span class="line">    callback = (typeof callback !== &quot;undefined&quot;) ? callback : function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // the rest of the function</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要让这个方法更安全，这需要更多额外的代码，许多流行的js库使用这种方式来提供默认参数。</p>
<h4 id="在ES6中的默认参数值"><a href="#在ES6中的默认参数值" class="headerlink" title="在ES6中的默认参数值"></a>在ES6中的默认参数值</h4><p>ES6中提供默认参数值将要容易很多，当执行函数时参数没有正常传入通过初始化参数提供默认参数值。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">    // the rest of the function</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数只期待第一个参数传入，其余的两个参数拥有默认参数值，这样的结果是函数体将更加小巧这是因为你不需要添加代码来检查缺省参数。  </p>
<p>当调用makeRequest()时传入三个参数，默认参数将不起效，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// uses default timeout and callback</span><br><span class="line">makeRequest(&quot;/foo&quot;);</span><br><span class="line"></span><br><span class="line">// uses default callback</span><br><span class="line">makeRequest(&quot;/foo&quot;, 500);</span><br><span class="line"></span><br><span class="line">// doesn&#x27;t use defaults</span><br><span class="line">makeRequest(&quot;/foo&quot;, 500, function(body) &#123;</span><br><span class="line">    doSomething(body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>ES6认为url是必须的，这就是为什么”&#x2F;foo”在三次调用makeRequest()时都传入，而其余两个拥有默认参数值被当成可选项。  </p>
<p>可以为任何参数指定默认参数值，包括哪些在函数声明中前面参数没有默认参数值的，如下是可以的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function makeRequest(url, timeout = 2000, callback) &#123;</span><br><span class="line"></span><br><span class="line">    // the rest of the function</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，timeout的默认参数只有在第二个参数没有传入，或者传入undefined起效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// uses default timeout</span><br><span class="line">makeRequest(&quot;/foo&quot;, undefined, function(body) &#123;</span><br><span class="line">    doSomething(body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// uses default timeout</span><br><span class="line">makeRequest(&quot;/foo&quot;);</span><br><span class="line"></span><br><span class="line">// doesn&#x27;t use default timeout</span><br><span class="line">makeRequest(&quot;/foo&quot;, null, function(body) &#123;</span><br><span class="line">    doSomething(body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这些例子中只有传入null才会被当做有效值，其余的都将使用默认参数值。</p>
<h4 id="默认参数值是如何影响arguments对象"><a href="#默认参数值是如何影响arguments对象" class="headerlink" title="默认参数值是如何影响arguments对象"></a>默认参数值是如何影响arguments对象</h4><p>记住arguments对象在使用默认参数值时表现会有一些不一样，zaiES5非严格模式中，arguments对象的改变将反应到形参上，这里是一些代理来解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mixArgs(first, second) &#123;</span><br><span class="line">    console.log(first === arguments[0]);</span><br><span class="line">    console.log(second === arguments[1]);</span><br><span class="line">    first = &quot;c&quot;;</span><br><span class="line">    second = &quot;d&quot;;</span><br><span class="line">    console.log(first === arguments[0]);</span><br><span class="line">    console.log(second === arguments[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixArgs(&quot;a&quot;, &quot;b&quot;);</span><br></pre></td></tr></table></figure>
<p>这里是输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>在ES5中arguments对象与形参总是同步更新，当frist和second被赋予新的值，arguments[0]和arguments[1]也相应的更新，当使用&#x3D;&#x3D;&#x3D;比较时会得到ture。  </p>
<p>但是在ES5严格模式中消除这些在argumnets对象让人疑惑的地方，在严格模式中arguments将不会和形参同步更新，这里同样是mixArgs()函数但是是在严格模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mixArgs(first, second) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">    console.log(first === arguments[0]);</span><br><span class="line">    console.log(second === arguments[1]);</span><br><span class="line">    first = &quot;c&quot;;</span><br><span class="line">    second = &quot;d&quot;</span><br><span class="line">    console.log(first === arguments[0]);</span><br><span class="line">    console.log(second === arguments[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixArgs(&quot;a&quot;, &quot;b&quot;);</span><br></pre></td></tr></table></figure>
<p>调用mixArgs输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>这次当改变first和second并没有影响arguments对象，使用输出结果将是你正常期待的。<br>在ES6中不顾是不是严格模式当使用默认参数值将会导致argument对象的表现行为像是在ES5中严格模式一样，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// not in strict mode</span><br><span class="line">function mixArgs(first, second = &quot;b&quot;) &#123;</span><br><span class="line">    console.log(arguments.length);</span><br><span class="line">    console.log(first === arguments[0]);</span><br><span class="line">    console.log(second === arguments[1]);</span><br><span class="line">    first = &quot;c&quot;;</span><br><span class="line">    second = &quot;d&quot;</span><br><span class="line">    console.log(first === arguments[0]);</span><br><span class="line">    console.log(second === arguments[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixArgs(&quot;a&quot;);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>在这个例子中，arguments.length为1这是因为只有一个产生传入，同时这也意味着arguments[1]位undefined，这意味着first等于arguments[0],同时改变first和seond将不会反应到arguments，这种表现行为在严格和非严格模式都是可行的，所以你可以通过arguments总是获取调用函数时实参的值。  </p>
<h4 id="默认参数表达式"><a href="#默认参数表达式" class="headerlink" title="默认参数表达式"></a>默认参数表达式</h4><p>默认参数值中最有趣的是默认值不一定是原始值，你也可以通过执行一个函数来获取默认参数值像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getValue() &#123;</span><br><span class="line">    return 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(first, second = getValue()) &#123;</span><br><span class="line">    return first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 1));     // 2</span><br><span class="line">console.log(add(1));        // 6</span><br></pre></td></tr></table></figure>
<p>这里第二个参数没有提供，getvalue()被调用获取正确的默认参数值，记住getVlue()只有在调用add()是没有传入第二个参数时才被调用，在函数声明解析的时候不会被调用，这意味着如果getvalue()被重写了，他可能返回不同的值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let value = 5;</span><br><span class="line"></span><br><span class="line">function getValue() &#123;</span><br><span class="line">    return value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(first, second = getValue()) &#123;</span><br><span class="line">    return first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 1));     // 2</span><br><span class="line">console.log(add(1));        // 6</span><br><span class="line">console.log(add(1));        // 7</span><br></pre></td></tr></table></figure>
<p>在这个例子中，value的值以5开始并且在每次调用getVlau()后递增，当第二次调用add(1)时返回7这是因为value递增过了。  </p>
<p>这个行为特征又引进了新的能力，你可以使用前面的参数作为后面参数的默认参数值，这里是例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(first, second = first) &#123;</span><br><span class="line">    return first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 1));     // 2</span><br><span class="line">console.log(add(1));        // 2</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，第二个参数的默认值是第一个参数，这意味着只需传入一个参数让两个参数拥有相同的值，所以add(1,1)返回和add(1)一样，想更远一些，你可以将第一个参数当做第二个参数的默认参数表达式中的参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getValue(value) &#123;</span><br><span class="line">    return value + 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(first, second = getValue(first)) &#123;</span><br><span class="line">    return first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 1));     // 2</span><br><span class="line">console.log(add(1));        // 7</span><br></pre></td></tr></table></figure>
<p>这个例子中设置second等于getValue(first)返回的值，所以add(1,1)任然等于2，add(1)返回7。<br>在调用add(undefined,1)时将会抛出一个错误，因为second是在first之后定义，因此不能将不存在的变量赋值为默认参数，为了理解为什么会这样，重新理解下TDZ很重要。</p>
<h4 id="默认参数值中的TDZ"><a href="#默认参数值中的TDZ" class="headerlink" title="默认参数值中的TDZ"></a>默认参数值中的TDZ</h4><p>第一章中介绍的暂时性死区(TDZ)是针对的let和const，并且在默认参数值中当参数不能获取到时也有一个TDZ，和let声明相似的是每个参数创建一个绑定标识符，这个标识符在没有初始化前访问将抛出一个错误，参数的初始化是发生在函数调用时，既不是在传值时也不在使用默认参数值时。  </p>
<p>为了探究默认参数值的TDZ，再看一下默认参数表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getValue(value) &#123;</span><br><span class="line">    return value + 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(first, second = getValue(first)) &#123;</span><br><span class="line">    return first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 1));     // 2</span><br><span class="line">console.log(add(1));        // 7</span><br></pre></td></tr></table></figure>
<p>调用add(1,1)和add(1)实际上相当于执行了创建first和second参数值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// JavaScript representation of call to add(1, 1)</span><br><span class="line">let first = 1;</span><br><span class="line">let second = 1;</span><br><span class="line"></span><br><span class="line">// JavaScript representation of call to add(1)</span><br><span class="line">let first = 1;</span><br><span class="line">let second = getValue(first);</span><br></pre></td></tr></table></figure>
<p>当第一次执行add()时，first和second绑定被添加到一个参数特定的TDZ中(和let的运行方式相同)，所以当second可以用first来初始化因为first在那个时候已经初始化了，反过来就不可以，现在看重写add()函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(first = second, second) &#123;</span><br><span class="line">    return first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 1));         // 2</span><br><span class="line">console.log(add(undefined, 1)); // throws error</span><br></pre></td></tr></table></figure>

<p>在这个例子中调用add(1,1)和add(undefined, 1)对应着下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// JavaScript representation of call to add(1, 1)</span><br><span class="line">let first = 1;</span><br><span class="line">let second = 1;</span><br><span class="line"></span><br><span class="line">// JavaScript representation of call to add(undefined, 1)</span><br><span class="line">let first = second;</span><br><span class="line">let second = 1;</span><br></pre></td></tr></table></figure>
<p>在这个例子中调用add(undefined,1)将抛出一个错误，这是因为在初始化first时second还没有初始化，在这个时候second在TDZ中任何对second的引用都将抛出一个错误，这和第一章中讨论的let绑定一样。  </p>
<h3 id="匿名参数"><a href="#匿名参数" class="headerlink" title="匿名参数"></a>匿名参数</h3><p>到目前为止，这章中只是覆盖了函数定义中的命名参数，但是js函数没有限制你传入参数数量和命名参数数量的关系，你可以多传也可以少传与命名参数数量，默认参数值是处理少传参数的情况，并且ES6也在寻求多传参数的情况。  </p>
<h4 id="在ES5中的匿名参数"><a href="#在ES5中的匿名参数" class="headerlink" title="在ES5中的匿名参数"></a>在ES5中的匿名参数</h4><p>早些时候js提供了arguments对象来检查当在函数定义时没有一一指定每一个参数而调用时函数的所有参数，在大多数情况下检测arguments有效，经过处理起来有些麻烦，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function pick(object) &#123;</span><br><span class="line">    let result = Object.create(null);</span><br><span class="line"></span><br><span class="line">    // start at the second parameter</span><br><span class="line">    for (let i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        result[arguments[i]] = object[arguments[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let book = &#123;</span><br><span class="line">    title: &quot;Understanding ECMAScript 6&quot;,</span><br><span class="line">    author: &quot;Nicholas C. Zakas&quot;,</span><br><span class="line">    year: 2015</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let bookData = pick(book, &quot;author&quot;, &quot;year&quot;);</span><br><span class="line"></span><br><span class="line">console.log(bookData.author);   // &quot;Nicholas C. Zakas&quot;</span><br><span class="line">console.log(bookData.year);     // 2015</span><br></pre></td></tr></table></figure>
<p>这个函数在模仿Underscore.js库的pick()方法，这个方法返回一个给定对象子集的副本，这个例子中只有第一个参数为原始对象外其他都是要返回对象的属性。  </p>
<p>对于pick()函数这里有几点需要注意的，首先这个函数对于能处理多个参数的暗示一点都不明显，第二点，因为第一个参数命名且直接使用的，当你在寻找属性来复制时，你必须要从arguments下标1而不是0开始，记住正确的使用arguments并不难，但是这需要你多记一件事了。</p>
<h4 id="不定参数-rest-parameters"><a href="#不定参数-rest-parameters" class="headerlink" title="不定参数(rest parameters)"></a>不定参数(rest parameters)</h4><p>不定参数是由三个点(…)加上一个命名参数组成，这个命名参数变成一个包含其余传入函数参数的数组，看pick()是如何用多用参数重写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function pick(object, ...keys) &#123;</span><br><span class="line">    let result = Object.create(null);</span><br><span class="line"></span><br><span class="line">    for (let i = 0, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">        result[keys[i]] = object[keys[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个版本中的函数，keys就是不定参数它包含了在object之后传入的所有参数（不像arguments包含所有传入参数）这意味着你可以在从头开始遍历keys不用担心出错，作为福利你可以通过看函数就知道他可以处理任意数量的参数。  </p>
<ul>
<li>notes:不定参数不会影响函数的length属性，这个属性只受命名参数个数影响，pick()的length值为1因为只有一个命名参数。</li>
</ul>
<h4 id="不定参数的限制"><a href="#不定参数的限制" class="headerlink" title="不定参数的限制"></a>不定参数的限制</h4><p>这里有两条对不定参数的限制，首先一个函数只能有一个不定参数，并且不定参数一定只能是最后一个，如下代码将不会起效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Syntax error: Can&#x27;t have a named parameter after rest parameters</span><br><span class="line">function pick(object, ...keys, last) &#123;</span><br><span class="line">    let result = Object.create(null);</span><br><span class="line"></span><br><span class="line">    for (let i = 0, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">        result[keys[i]] = object[keys[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里参数last接在不定参数keys后面，将会造成一个语法错误。  </p>
<p>第二个限制是不定参数不能在对象字面量setter使用，这意味着下面代码将会造成一个语法错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let object = &#123;</span><br><span class="line"></span><br><span class="line">    // Syntax error: Can&#x27;t use rest param in setter</span><br><span class="line">    set name(...value) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个限制存在是因为对象字面量setters限制为个参数，不定参数定义上来说可以是无限个参数，所以在这样的上下午中不能使用。  </p>
<h4 id="不定参数对arguments对象的影响"><a href="#不定参数对arguments对象的影响" class="headerlink" title="不定参数对arguments对象的影响"></a>不定参数对arguments对象的影响</h4><p>在ES中不定参数被设计成取代arguments，在原来的ES4中废除了arguments和新增不定参数允许传入不受限制数量的参数，ES4最终没能实现，但是这个这个想法保留下来了并在ES6中被重新引进了，尽管aguments没有从这门语言中移除。   </p>
<p>arguments对象和不定参数在函数被调用是共同反应着传入的参数，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function checkArgs(...args) &#123;</span><br><span class="line">    console.log(args.length);</span><br><span class="line">    console.log(arguments.length);</span><br><span class="line">    console.log(args[0], arguments[0]);</span><br><span class="line">    console.log(args[1], arguments[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkArgs(&quot;a&quot;, &quot;b&quot;);</span><br></pre></td></tr></table></figure>
<p>调用checkArgs()输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">a a</span><br><span class="line">b b</span><br></pre></td></tr></table></figure>
<p>arguments对象那个仍然反应着传入的参数不管有没使用不定参数。  </p>
<p>你所知道的全部是可以开始使用不定参数了。</p>
<h4 id="Function构造器新增特性"><a href="#Function构造器新增特性" class="headerlink" title="Function构造器新增特性"></a>Function构造器新增特性</h4><p>Function构造器作为js的一部分并不经常使用，它能让你动态的创建函数，构造器的参数为生成函数的参数和函数体（字符串），这里是例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var add = new Function(&quot;first&quot;, &quot;second&quot;, &quot;return first + second&quot;);</span><br><span class="line"></span><br><span class="line">console.log(add(1, 1));     // 2</span><br></pre></td></tr></table></figure>

<p>ES6允许Function构造器使用默认参数和不定参数，你只需添加相应的标示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var add = new Function(&quot;first&quot;, &quot;second = first&quot;,</span><br><span class="line">        &quot;return first + second&quot;);</span><br><span class="line"></span><br><span class="line">console.log(add(1, 1));     // 2</span><br><span class="line">console.log(add(1));        // 2</span><br></pre></td></tr></table></figure>

<p>这个例子中second被赋予first的默认值。  </p>
<p>对于不定参数你只需添加… 在最后一个参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var pickFirst = new Function(&quot;...args&quot;, &quot;return args[0]&quot;);</span><br><span class="line"></span><br><span class="line">console.log(pickFirst(1, 2));   // 1</span><br></pre></td></tr></table></figure>

<h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><p>与不定参数最相关的是展开运算符，不定参数允许你用多个独立的参数合并为一个数组，然而展开运算符允许你用一个给定数组分割成独立的项当做参数传入函数，看Math.max()方法，它允许你接受任意数量的参数并返回其中值最高的，这里是使用的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let value1 = 25,</span><br><span class="line">    value2 = 50;</span><br><span class="line"></span><br><span class="line">console.log(Math.max(value1, value2));      // 50</span><br></pre></td></tr></table></figure>
<p>当你处理只有两个值是Math.max()非常简单，传入两个值返回最高的，但是你要使用一个数组传入时？Math.max()不允许你使用数组，在早先的ES5中，你要么被这个数组困住要么使用apply()如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let values = [25, 50, 75, 100]</span><br><span class="line"></span><br><span class="line">console.log(Math.max.apply(Math, values));  // 100</span><br></pre></td></tr></table></figure>
<p>这种解决方案会生效，但是使用apply()这种方式有点令人困惑，加了这段额外代码后这实际上看起来抽象了。  </p>
<p>ES6中扩展运算符让这种情况看起来更容易，你可以传入数组进去而不是使用apply(),js引擎将数组拆分成独立的参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let values = [25, 50, 75, 100]</span><br><span class="line"></span><br><span class="line">// equivalent to</span><br><span class="line">// console.log(Math.max(25, 50, 75, 100));</span><br><span class="line">console.log(Math.max(...values));      </span><br></pre></td></tr></table></figure>
<p>现在调用Math.max()看起来更加的方便了并且避免了this的绑定（调用Math.max.apply的第一个参数）。  </p>
<p>你也可以将展开运算符和其他参数混用。如果你想让Math.max()返回的最小值为0时（只是防止负数的情况）。你可以传入一个展开运算符的参数和另一个其他参数，入下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let values = [-25, -50, -75, -100]</span><br><span class="line"></span><br><span class="line">console.log(Math.max(...values, 0));        // 0</span><br></pre></td></tr></table></figure>
<p>在这个例子中传入Math.max()的最后参数为0，这个参数是在展开运算符参数后的参数。</p>
<h3 id="ES6中name属性"><a href="#ES6中name属性" class="headerlink" title="ES6中name属性"></a>ES6中name属性</h3><p>介于可以有不同的方法定义一个函数，识别函数在js中可能会有些挑战。另外匿名函数表达式在栈轨迹的结果常常难以解读直接导致了debuging有点困难。综合这些原因，ES6为函数添加name属性。  </p>
<h4 id="选择一个合适的名字"><a href="#选择一个合适的名字" class="headerlink" title="选择一个合适的名字"></a>选择一个合适的名字</h4><p>所以的函数在ES6程序中都将有一个合适值的name属性，为了看看实际程序中到底如何，看下面程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var doAnotherThing = function() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(doSomething.name);          // &quot;doSomething&quot;</span><br><span class="line">console.log(doAnotherThing.name);       // &quot;doAnotherThing&quot;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，dosomthing()有一个name属性等于”dosomething”因为这是一个函数声明，匿名函数表达式doantherThing()有一个name属性等于”doAntherThing”这是因为这是表达式赋于的名字。</p>
<h4 id="特殊情况下的name属性"><a href="#特殊情况下的name属性" class="headerlink" title="特殊情况下的name属性"></a>特殊情况下的name属性</h4><p>对于函数声明和匿名函数表达式的名字是容易找到的，ES6为了让所有的函数都要合适的name属性做了更多的事，看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var doSomething = function doSomethingElse() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    get firstName() &#123;</span><br><span class="line">        return &quot;Nicholas&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(doSomething.name);      // &quot;doSomethingElse&quot;</span><br><span class="line">console.log(person.sayName.name);   // &quot;sayName&quot;</span><br><span class="line"></span><br><span class="line">var descriptor = Object.getOwnPropertyDescriptor(person, &quot;firstName&quot;);</span><br><span class="line">console.log(descriptor.get.name); // &quot;get firstName&quot;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，doSomething.name是”doSomethingElse”这是因为匿名函数表达式拥有自己的名字，并且这个名字优先于被赋予变量的名字。person.sayName()的name属性为”sayName”,这是因为这个值是在字面量对象的值。相似的person.sayName()实际上是一个getter函数，但是有点不同的是name属性为”get firstName”,setter函数也会在前面添加”set”(不管是setter还是getter函数都必须使用Object.getOwnPropertyDescriptor()来检索)   </p>
<p>这里有两个关于函数name属性的特殊情况，当使用bind()后返回的函数它们的name属性都将在前面加上”bound”属性，当函数是使用Function构造器生成的都将有个”anonymous”的name属性，如下例:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var doSomething = function() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(doSomething.bind().name);   // &quot;bound doSomething&quot;</span><br><span class="line"></span><br><span class="line">console.log((new Function()).name);     // &quot;anonymous&quot;</span><br></pre></td></tr></table></figure>
<p>在这个例子中绑定函数的name属性总是在前面加上”bound”字符串，所以绑定版的doSomething() name属性为”bound doSomething”。</p>
<p>记住name的值对于任何函数都不一定是同一个name值。name属性是让你debugging的，而不是使用name的值得到函数的引用。  </p>
<h4 id="澄清函数的多重性"><a href="#澄清函数的多重性" class="headerlink" title="澄清函数的多重性"></a>澄清函数的多重性</h4><p>在早先的ES5中函数在调用时有没使用new具有多重性，当使用了new这时函数内部的this值是一个新对象并且默认将新对象返回，如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;Nicholas&quot;);</span><br><span class="line">var notAPerson = Person(&quot;Nicholas&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person);        // &quot;[Object object]&quot;</span><br><span class="line">console.log(notAPerson);    // &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
<p>当没有使用new调用Person()时创造的notPerson值为undefined(并且在非严格模式的全局对象变量上设置name属性)，通常在js中函数首字母大写暗示是一个用new调用的函数。这样的多重意义调用在ES6中也做了相应的改变。  </p>
<p>在js中函数拥有两个不同的内部专用方法分别是：[[Call]]和[[Construct]]。当函数调用时没有使用new，[[Call]]方法被执行了，它的表现形式为函数体内部代码执行了。当一个函数调用时使用了new，这时[[Construct]]方法被调用了。方法[[Counstruct]]表达创建一个新对象，调用一个新目标，同时用this设置新目标来执行函数体，一个拥有[[Construct]]的函数别叫做构造器。  </p>
<ul>
<li>记住不是所有的函数有[[Construct]]方法，所以不是所有函数可以使用new调用，在接下来讨论的箭头函数就没有[[Constuct]]函数。</li>
</ul>
<h3 id="在ES5中一个函数是如何调用"><a href="#在ES5中一个函数是如何调用" class="headerlink" title="在ES5中一个函数是如何调用"></a>在ES5中一个函数是如何调用</h3><p>在ES5中判断一个函数是否是用new调用最流行的方法是使用instanceof，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    if (this instanceof Person) &#123;</span><br><span class="line">        this.name = name;   // using new</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new Error(&quot;You must use new with Person.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;Nicholas&quot;);</span><br><span class="line">var notAPerson = Person(&quot;Nicholas&quot;);  // throws error</span><br></pre></td></tr></table></figure>
<p>这里用this的值来检查是不是构造器的实例，如果是，代码将正常执行，如果this不是Person的实例将抛出一个错误，这是因为[[Constuct]]方法创建了一个Person实例并复制给this。但是这种方法并不可靠因为this可以是Person实例并且在不适用new的情况下，如下例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    if (this instanceof Person) &#123;</span><br><span class="line">        this.name = name;   // using new</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new Error(&quot;You must use new with Person.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;Nicholas&quot;);</span><br><span class="line">var notAPerson = Person.call(person, &quot;Michael&quot;);    // works!</span><br></pre></td></tr></table></figure>
<p>当调用Person.call()时传入person作为第一个参数，这意味着在Person函数体内this被设置为person了，对于这个函数，这是没有办法去区分是否适用new调用的。</p>
<h4 id="new-target-元属性"><a href="#new-target-元属性" class="headerlink" title="new.target 元属性"></a>new.target 元属性</h4><p>为了解决这个问题，ES6引进new.target这个元属性。原属性是关于目标（如new）的非对象信息。当函数的[[Constructor]]方法被调用时，new.target会被赋予new操作符目标值，这个target通常是创建新实例的构造器，如果[[call]]被执行时，new.target为undefined。  </p>
<p>这个new的元属性让你可以安全的检查function是否是使用new调用的如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    if (typeof new.target !== &quot;undefined&quot;) &#123;</span><br><span class="line">        this.name = name;   // using new</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new Error(&quot;You must use new with Person.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;Nicholas&quot;);</span><br><span class="line">var notAPerson = Person.call(person, &quot;Michael&quot;);    // error!</span><br></pre></td></tr></table></figure>
<p>通过使用new.target代替instanceof,当没有使用new调用Person时构造器将抛出一个错误。  </p>
<p>你也可以指定特殊的构造器和new.target进行比较，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    if (new.target === Person) &#123;</span><br><span class="line">        this.name = name;   // using new</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new Error(&quot;You must use new with Person.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function AnotherPerson(name) &#123;</span><br><span class="line">    Person.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;Nicholas&quot;);</span><br><span class="line">var anotherPerson = new AnotherPerson(&quot;Nicholas&quot;);  // error!</span><br></pre></td></tr></table></figure>
<ul>
<li>警告：new.target不能再函数外使用（语法错误）</li>
</ul>
<h3 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h3><p>在早先的ES3中函数声明在一个块级里（块级函数）技术上回引起一个语法错误，但是不是所有的浏览器都支持这样的行为，不幸的是这种语法在每个浏览里表现得有点不同，所以在实践中最好是避免在块级中声明函数(最好的替代方法是使用函数表达式)。  </p>
<p>为了同一个这个行为的不一致，在ES5严格模式下函数声明发生在块都会入下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line"></span><br><span class="line">    // Throws a syntax error in ES5, not so in ES6</span><br><span class="line">    function doSomething() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ES5中这个代码将抛出一个语法错误，但在ES6中函数doSomething()被认为一个块级声明，并且能在相同的块中获取到并调用。如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(typeof doSomething);        // &quot;function&quot;</span><br><span class="line"></span><br><span class="line">    function doSomething() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(typeof doSomething);            // &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
<p>块级函数在定义块中被提升到块顶部，所以typeof doSomething 返回”function”尽管这是在声明函数前的代码，一旦if块执行完成，doSomething()将不再存在。  </p>
<h4 id="何时使用块级函数"><a href="#何时使用块级函数" class="headerlink" title="何时使用块级函数"></a>何时使用块级函数</h4><p>块级函数和let函数表达式很像一旦执行流离开了定义块存储的内容就将移除，一个关键不同的地方是块级函数会有函数提升，但是使用let的函数表达式不会提升，如例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(typeof doSomething);        // throws error</span><br><span class="line"></span><br><span class="line">    let doSomething = function () &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(typeof doSomething);</span><br></pre></td></tr></table></figure>
<p>这段代码中，代码停在了typeof doSomething执行时，这是因为let声明还没执行让doSomething停留在TDZ，知道这点不同后，你就可以根据是否需要函数提升是使用块级函数声明还是使用let声明块级表达式。</p>
<h4 id="非严格模式下的块级函数"><a href="#非严格模式下的块级函数" class="headerlink" title="非严格模式下的块级函数"></a>非严格模式下的块级函数</h4><p>ES6同样允许块级函数在非严格模式下使用，经管表现行为会稍有不一致，函数提升不再是在块的顶部，而是提升到包含函数或全局作用域中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ECMAScript 6 behavior</span><br><span class="line">if (true) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(typeof doSomething);        // &quot;function&quot;</span><br><span class="line"></span><br><span class="line">    function doSomething() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(typeof doSomething);            // &quot;function&quot;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，doSomething()被提升全局作用域中了所以在执行完if块后任然存在，ES6标准化了这种原来在众多浏览器中不兼容的行为，所以在所有的ES6运行时钟都将表现一致。  </p>
<p>尽管块级函数提升了你在js声明函数的能力，但是ES6也引进了一种全新的函数声明方式。  </p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在崭新的ES6中箭头函数是最有趣的部分之一，箭头函数如其名字一样通过新语法箭头”&#x3D;&gt;”定义函数，但是箭头函数和原来传统函数有很多重要的不同地方:  </p>
<ul>
<li>__没有 this, super, arguments,和 new.target 绑定__，箭头函数这些值是由包含最近的容器提供。</li>
<li><strong>不能使用new调用</strong> 箭头函数没有[[Constuct]]方法所以不能被当做构造器，如果使用new调用箭头函数将抛出一个错误。</li>
<li><strong>没有prototype</strong>  既然你不在调用箭头函数时使用new，这里就没要对prototype的需要了，使用箭头函数的prototype属性并不存在。</li>
<li><strong>不改变this值</strong> 函数内部的this值在整个函数生命周期都将不会改变。</li>
<li><strong>没有argument对象</strong>  既然箭头函数没有arguments绑定，你必须依赖命名和不定参数来获取函数的函数。</li>
<li><strong>不支持重复命名参数</strong> 箭头函数不管是在严格或者非严格模式都不支持重复命名参数，与之相对的是非箭头函数只有在严格模式才不支持重复命名参数。</li>
</ul>
<p> 产生这些差异有以下原因。首先this绑定是js错误常见来源，this在函数体内很难跟踪，因此会导致一些意想不到的行为，但是箭头函数消除了这个疑惑，其次通过限制箭头函数在执行的时候就一个this值，js引擎可以更容易优化这些操作，不像普通的函数可以作为构造器或者其他修改。   </p>
<p> 其余的不同同样可以集中在减少函数内错误和歧义，通过这样做js引擎可以更好的优化箭头函数。 </p>
<ul>
<li>note: 箭头函数同样拥有name属性并且遵循其他函数遵循的规则.</li>
</ul>
<h4 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h4><p> 箭头函数的使用语法有很多种这些都取决于你想完成什么，所有的语法都以函数参数开始，紧接着箭头，最后是函数体。函数参数和函数的使用方式取决于你使用的目的，如下：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var reflect = value =&gt; value;</span><br><span class="line"></span><br><span class="line">// effectively equivalent to:</span><br><span class="line"></span><br><span class="line">var reflect = function(value) &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br> 当箭头函数只有一个参数时，就一个参数没有更多的语法了，在箭头的后面也是右边表达式求值并立即返回，尽管没有明确的return语句，这个箭头函数将返回以第一个传入的参数值。  </p>
<p> 如果你传入超过一个参数的参数，你必须在参数的两边加圆括号包住它们。  </p>
<p> 如果这个箭头函数没有参数，你必须用一对圆括号包住一个空的声明，如下：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var getName = () =&gt; &quot;Nicholas&quot;;</span><br><span class="line"></span><br><span class="line">// effectively equivalent to:</span><br><span class="line"></span><br><span class="line">var getName = function() &#123;</span><br><span class="line">    return &quot;Nicholas&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> 当你的箭头函数函数体包含超过一个表达式的时候，你就需要用一对括弧包住。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var sum = (num1, num2) =&gt; &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// effectively equivalent to:</span><br><span class="line"></span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br> 如果你想创建一个什么都不做的箭头函数，如下：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var doNothing = () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// effectively equivalent to:</span><br><span class="line"></span><br><span class="line">var doNothing = function() &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>括弧通常是用来表示函数体的，但是在箭头函数的函数体只想返回一个对象字面量时必须被包一对圆括号里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);</span><br><span class="line"></span><br><span class="line">// effectively equivalent to:</span><br><span class="line"></span><br><span class="line">var getTempItem = function(id) &#123;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        name: &quot;Temp&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将对象字面量用圆括号包裹起来是表示这是一个对象直面量而不是函数体。</p>
<h4 id="创建立即执行函数表达式"><a href="#创建立即执行函数表达式" class="headerlink" title="创建立即执行函数表达式"></a>创建立即执行函数表达式</h4><p>js中一个很使用函数流行的方式是立即执行函数(IIFE)，IIFE让你定义一个匿名函数后并立即执行没有任何引用保存，当你想创建一个作用域和程序中的其他作用域相隔离时就可以使用这种方式。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let person = function(name) &#123;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        getName: function() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;(&quot;Nicholas&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person.getName());      // &quot;Nicholas&quot;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，IIFE被用作创建一个拥有getName()方法的对象，这个方法将name参数作为返回值。它有效的将nem设置为返回对象的私有属性。  </p>
<p>你也可以用箭头函数完成同样的事，只要你将箭头函数用圆括号包裹起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let person = ((name) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        getName: function() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)(&quot;Nicholas&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person.getName());      // &quot;Nicholas&quot;</span><br></pre></td></tr></table></figure>
<p>注意圆括号只将箭头函数的定义包裹起来，并没有包裹(“Nicholas”)，这就和普通函数有一些不一样，在普通函数里这里的圆括号既可以在函数体外，也可以将传参包住。  </p>
<h4 id="没有this绑定"><a href="#没有this绑定" class="headerlink" title="没有this绑定"></a>没有this绑定</h4><p>js中最容易出错的地方之一就函数内部this的绑定，因为单个函数this的值依赖于执行时的上下午环境（对象），它很有可能的使用一个对象，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: &quot;123456&quot;,</span><br><span class="line"></span><br><span class="line">    init: function() &#123;</span><br><span class="line">        document.addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class="line">            this.doSomething(event.type);     // error</span><br><span class="line">        &#125;, false);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: function(type) &#123;</span><br><span class="line">        console.log(&quot;Handling &quot; + type  + &quot; for &quot; + this.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码中，对象PageHandler用来处理页面上的交互效果，init()方法是来初始化交互当调用this.dosomething(),然而这段代码不会起效。   </p>
<p>调用this.doSomething()报错，是因为this指向事件目标对象(这段代码指向document)，而不是PageHandler,如果你尝试在document上调用一个不存在的方法就将报错。  </p>
<p>你可以通过调用bind()方法将函数上this的值绑定到PageHandler：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: &quot;123456&quot;,</span><br><span class="line"></span><br><span class="line">    init: function() &#123;</span><br><span class="line">        document.addEventListener(&quot;click&quot;, (function(event) &#123;</span><br><span class="line">            this.doSomething(event.type);     // no error</span><br><span class="line">        &#125;).bind(this), false);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: function(type) &#123;</span><br><span class="line">        console.log(&quot;Handling &quot; + type  + &quot; for &quot; + this.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在这段代码可以如期待一样执行，但是它看起来有点奇怪，通过调用bind(this)你实际上创建了一个新的函数，这个函数this值绑定到目前的this值上也就是PageHandler。为了避免产生这段多余的代码，箭头函数是不错的选择。  </p>
<p>箭头函数没有this绑定，这意味着箭头函数this的值只由作用域链上上段作用域觉定，如果箭头函数被一个非箭头函数包含，this就将和包含函数的this一样，否则this的值就等于全局作用上this的值，这里有一个用箭头函数写的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var PageHandler = &#123;</span><br><span class="line"></span><br><span class="line">    id: &quot;123456&quot;,</span><br><span class="line"></span><br><span class="line">    init: function() &#123;</span><br><span class="line">        document.addEventListener(&quot;click&quot;,</span><br><span class="line">                event =&gt; this.doSomething(event.type), false);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: function(type) &#123;</span><br><span class="line">        console.log(&quot;Handling &quot; + type  + &quot; for &quot; + this.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子中的事件处理是一个箭头函数调用this.doSomething()，this的值和调用init()方法的this值一样，所以这版代码和使用bind(this)的一样，尽管doSomething()方法没有返回值，但是整个函数体只有一个语句，使用这里就没必要用括弧。   </p>
<p>箭头函数被设计成一次性函数，所以不能被new调用，这就为什么缺少prototype属性原因了，如果你尝试new操作符和箭头函数一起使用，你将得到一个错误，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var MyType = () =&gt; &#123;&#125;,</span><br><span class="line">    object = new MyType();  // error - you can&#x27;t use arrow functions with &#x27;new&#x27;</span><br></pre></td></tr></table></figure>
<p>这段代码盗用 newMype()将会失败，这是因为MyType是一个箭头函数因此没有[[Constrcut]]行为，这样的话js引擎知道不能使用new调用箭头函数就能更好的优化。</p>
<h4 id="箭头函数和数组"><a href="#箭头函数和数组" class="headerlink" title="箭头函数和数组"></a>箭头函数和数组</h4><p>箭头函数简洁的语法使它在处理数组时更加理想，如果你想用普通函数为一个数组排序，你可以如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var result = values.sort(function(a, b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用箭头函数将会更加简洁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var result = values.sort((a, b) =&gt; a - b);</span><br></pre></td></tr></table></figure>

<h4 id="没有arguments绑定"><a href="#没有arguments绑定" class="headerlink" title="没有arguments绑定"></a>没有arguments绑定</h4><p>经管箭头函数没有它自己的arguments对象，但是它可以从包换它的函数里获取到一个arguments对象，这个arguments对象会一直存在不管箭头函数是不是后执行。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createArrowFunctionReturningFirstArg() &#123;</span><br><span class="line">    return () =&gt; arguments[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arrowFunction = createArrowFunctionReturningFirstArg(5);</span><br><span class="line"></span><br><span class="line">console.log(arrowFunction());       // 5</span><br></pre></td></tr></table></figure>
<p>在createArrowFunctionReturnFirstArg()里arguments[0]倍创建的箭头函数引用，这个引用包含了传入createArrowFunctionReturnFirstArg()的第一个参数，当箭头函数后执行返回5,尽管箭头函数已经不在创建的上下文中了，但是根据作用域链的关系任然可以访问到argments。  </p>
<h4 id="识别箭头函数"><a href="#识别箭头函数" class="headerlink" title="识别箭头函数"></a>识别箭头函数</h4><p>尽管箭头函数使用和普通函数不同的语法，但是仍旧是函数，并且也可以项普通函数一样识别，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var comparator = (a, b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line">console.log(typeof comparator);                 // &quot;function&quot;</span><br><span class="line">console.log(comparator instanceof Function);    // true</span><br></pre></td></tr></table></figure>

<p>箭头函数typeof和instanceof的console.log()结果和普通函数的一样。</p>
<p>像其他函数一样，你也可以对箭头函数使用call(),apply(),和bind()，尽管this-binding将不会影响，这里有些例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line"></span><br><span class="line">console.log(sum.call(null, 1, 2));      // 3</span><br><span class="line">console.log(sum.apply(null, [1, 2]));   // 3</span><br><span class="line"></span><br><span class="line">var boundSum = sum.bind(null, 1, 2);</span><br><span class="line"></span><br><span class="line">console.log(boundSum());                // 3</span><br></pre></td></tr></table></figure>
<p>sum()函数调用时使用call()和apply()来传入参数，这和其他函数一样，bind()方法的使用方法也和其他函数调用一样。  </p>
<p>箭头函数适用于在任何可以使用匿名函数表达式的地方，下一部分将覆盖ES6另一个重要的改变，但是这个是内部的，并没有新语法。  </p>
<h4 id="尾调函数优化"><a href="#尾调函数优化" class="headerlink" title="尾调函数优化"></a>尾调函数优化</h4><p>也许在ES6的函数变化中最有趣的地方是引擎优化，所谓的引擎优化就尾调函数的优化，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">    return doSomethingElse();   // tail call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾调函数在ES5处理方式和其他函数调用处理方式一样：一个新的栈帧创建并别压入函数调用的调用栈里，这意味先前所有的栈帧都保存在内存中，但是这意味着当容易造成调用栈过大的问题。  </p>
<h3 id="尾调函数区别"><a href="#尾调函数区别" class="headerlink" title="尾调函数区别"></a>尾调函数区别</h3><p>ES6为了某些尾递归在严格模式(非严格模式下的尾调用不变)下减少调用栈的体积采取了一定优化措施，具体而言不再为尾调用创建新的栈帧，将当前栈帧清除，并重复使用（前体满足如下条件）:  </p>
<ul>
<li><ol>
<li>尾调用不需要访问当前栈帧变量(意味着函数不是闭包)</li>
</ol>
</li>
<li><ol start="2">
<li>当前函数在尾调用时没有除了return以外的操作。</li>
</ol>
</li>
<li><ol start="3">
<li>当前函数调用的结果为尾调用返回的值。</li>
</ol>
</li>
</ul>
<p>如下代码很容易满足这所有3条规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    // optimized</span><br><span class="line">    return doSomethingElse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数中使用了尾调用doSinethingElse(),并且立即返回结果，没有对本地作用域任何变量的访问，一个小小的变化，将不做优化:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    // not optimized - no return</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    // not optimized - must add after returning</span><br><span class="line">    return 1 + doSomethingElse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    // not optimized - call isn&#x27;t in tail position</span><br><span class="line">    var result = doSomethingElse();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    var num = 1,</span><br><span class="line">        func = () =&gt; num;</span><br><span class="line"></span><br><span class="line">    // not optimized - function is a closure</span><br><span class="line">    return func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何利用尾调用优化"><a href="#如何利用尾调用优化" class="headerlink" title="如何利用尾调用优化"></a>如何利用尾调用优化</h4><p>在实际工作中，尾调用优化都是幕后发生的所以你不需要想太多除非你试图优化一个函数，一个最基础的使用尾调用优化的地方就递归函数，这里优化需要极大的努力，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function factorial(n) &#123;</span><br><span class="line"></span><br><span class="line">    if (n &lt;= 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // not optimized - must multiply after returning</span><br><span class="line">        return n * factorial(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function factorial(n, p = 1) &#123;</span><br><span class="line"></span><br><span class="line">    if (n &lt;= 1) &#123;</span><br><span class="line">        return 1 * p;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let result = n * p;</span><br><span class="line"></span><br><span class="line">        // optimized</span><br><span class="line">        return factorial(n - 1, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数在ES6中并没有经历太多变化，但是一些列增加的变化让函数更容易使用。  </p>
<p>函数默认参数让你在某些参数没有传入时更容易指定默认值，在ES6之前指定默认参数值将需要更多代码检查参数是否传入并指定默认值。  </p>
<p>不定参数让你指定一个数组包含所有剩余参数。用一个真正的数组将比使用arguments对象将更加灵活。  </p>
<p>扩展操作符和不定参数是一对小伙伴，扩展操作符让你将一个数组转换为一系列调用函数时的参数，在ES6之前要达到相应的效果，要么手工指定每个参数或使用apply(),但是有了扩展操作符后你可以轻松的将数组传入函数调用并不用担心this的指向(apply()会改变this指向)。   </p>
<p>为函数新增的name属性将帮助你bebugging和求值时更容易识别函数，另外ES6中正式定义了块级函数的行为。</p>
<p>在ES6中普通函数的执行被[[Call]]定义，当函数用new执行的行为被[[Construct]]定义。元属性new.target也允许你知道函数到底是普通调用还是new调用。  </p>
<p>在ES6的函数中最大的改变就是箭头函数了，它被设计成代替匿名函数表达式。箭头函数拥有更加简洁的语法和词法上this的绑定，并且没有arguments对象。另外箭头函数不能改变this的绑定，所以不能被当做函数构造器&gt;</p>
<p>尾调用优化让你在某些情况下保持更小体积的调用栈，这种优化是由js引擎自动执行的，但是你得重写你的递归函数才能享受到这种优化。</p>
]]></content>
  </entry>
  <entry>
    <title>第五章 解构</title>
    <url>/2017/07/25/%E7%AC%AC5%E7%AB%A0%20%E8%A7%A3%E6%9E%84/</url>
    <content><![CDATA[<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>对象和数组字面量是js中最常用的标记，并且多亏JSON数据格式的流行它们成为了这面语言重要的一部分。对于定义对象和数组时相当常见的，同样从这些结构中系统的取出需要的部分也是同样常见。ES6为了简化这个过程添加了destructuring（解构：将大数据结构分解为很多小数据结构的过程）。这种中将为你展示如何使用在对象和数组上使用解构。  </p>
<span id="more"></span>
<h4 id="为什么解构是有用的"><a href="#为什么解构是有用的" class="headerlink" title="为什么解构是有用的"></a>为什么解构是有用的</h4><p>在ES5和之前，为了从对象和数组中提取信息需要很多看起来一样的代码，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let options = &#123;</span><br><span class="line">        repeat: true,</span><br><span class="line">        save: false</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">// extract data from the object</span><br><span class="line">let repeat = options.repeat,</span><br><span class="line">    save = options.save;</span><br></pre></td></tr></table></figure>
<p>这段代码为了从对象options获取repeat和save值并将之用保存到同名的本地变量，虽然这段代码看起简单但是想象下如果你有很多变量需要赋值，你需要一个一个赋值.并且如果这是一个混乱的数据结构你需要为了一点数据而遍历整个数据结构。  </p>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>对象解构语法：用对象字面量赋值操作符左边部分表示，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let node = &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123;type, name&#125; = node;</span><br><span class="line"></span><br><span class="line">console.log(type); // &quot;Identifier&quot;</span><br><span class="line">console.log(name); // &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>这段代码中node.type和node.name的值分别存在了type和name中，这个语法和第4章中介绍的对象字面量初始化速记一样。标识符type和name声明为本地变量并从node对象中读取值。</p>
<ul>
<li>note：在使用解构声明变量（var let const）都必须提供一个初始化值（等号右边）</li>
</ul>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>到目前为止对象解构都是在变量声明上，但是在赋值中也可以用解构，如下，当你在变量定义后想重新赋值时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let node = &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    type = &quot;Literal&quot;,</span><br><span class="line">    name = 5;</span><br><span class="line"></span><br><span class="line">    // assign different values using destructuring</span><br><span class="line">    (&#123; type, name &#125; = node);</span><br><span class="line"></span><br><span class="line">    console.log(type);      // &quot;Identifier&quot;</span><br><span class="line">    console.log(name);      // &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，对象node中type和name在声明的同时赋值初始化，同时两个同名变量type和name声明并赋值初始化。下一行代码中利用解构变量从node对象中读取相应的值，注意你必须在解构赋值语句两步加园括号。这是因为花括号一般期待为一个块级语句，同时块级语句是不能出现在赋值语句左边的。加上圆括号后的花括号表示不应该解释为块级语句而应该解释为表达式。</p>
<p>一个解构赋值表达式的求值结果为表达式右边(&#x3D;号的后面)，这意味着你可以在任何需要使用解构赋值表达式求值结果的地方地方使用。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let node = &#123;</span><br><span class="line">        type: &quot;Identifier&quot;,</span><br><span class="line">        name: &quot;foo&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    type = &quot;Literal&quot;,</span><br><span class="line">    name = 5;</span><br><span class="line"></span><br><span class="line">function outputInfo(value) &#123;</span><br><span class="line">    console.log(value === node);        // true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outputInfo(&#123; type, name &#125; = node);</span><br><span class="line"></span><br><span class="line">console.log(type);      // &quot;Identifier&quot;</span><br><span class="line">console.log(name);      // &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>调用函数uptpuInfo()时传入了一个解构赋值表达式。这个表达式求值结果为node，同时type和name都被赋值。</p>
<ul>
<li>warning： 如果解构赋值表达式的(&#x3D;号后面的表达式)右边求值为null或者undefined则会抛出一个错误，这是因为任何尝试在null或者undefined读取属性都将抛出一个运行时错误。</li>
</ul>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>当你在使用解构赋值语句时，你指定的本地变量在对象上并不存在同名属性时，本地变量会被赋值为undefined,如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let node = &#123;</span><br><span class="line">        type: &quot;Identifier&quot;,</span><br><span class="line">        name: &quot;foo&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">let &#123; type, name, value &#125; = node;</span><br><span class="line"></span><br><span class="line">console.log(type);      // &quot;Identifier&quot;</span><br><span class="line">console.log(name);      // &quot;foo&quot;</span><br><span class="line">console.log(value);     // undefined</span><br></pre></td></tr></table></figure>
<p>这段单面定义了一个多余的本地变量value并且尝试赋值，但是在node上并没有对应的value属性，所以最终被赋值为undefined。  </p>
<p>你可以选择性的为特定不存在的属性添加默认值，你只需要在指定属性名后面加上&#x3D;和相应的默认值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let node = &#123;</span><br><span class="line">        type: &quot;Identifier&quot;,</span><br><span class="line">        name: &quot;foo&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">let &#123; type, name, value = true &#125; = node;</span><br><span class="line"></span><br><span class="line">console.log(type);      // &quot;Identifier&quot;</span><br><span class="line">console.log(name);      // &quot;foo&quot;</span><br><span class="line">console.log(value);     // true</span><br></pre></td></tr></table></figure>
<p>在这段例子中，变量value被赋予了true的默认值，默认值只有在node上没有对应属性或者属性值为undefined时起效，这个和第三章中函数的默认参数相似。</p>
<h4 id="赋予不同的本地变量名"><a href="#赋予不同的本地变量名" class="headerlink" title="赋予不同的本地变量名"></a>赋予不同的本地变量名</h4><p>目前为止，每个解构赋值都是利用的对象属性名和本地变量名相同的条件，但是ES6允许你使用不同名字来赋值，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let node = &#123;</span><br><span class="line">        type: &quot;Identifier&quot;,</span><br><span class="line">        name: &quot;foo&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">let &#123; type: localType, name: localName &#125; = node;</span><br><span class="line"></span><br><span class="line">console.log(localType);     // &quot;Identifier&quot;</span><br><span class="line">console.log(localName);     // &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><p>数组解构语法与对象解构语法相当相似，它只是用数组字面量语法代替了对象字面量语法而已，具体的解构操作由数组中的位置决定，而不是对象中属性名。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line"></span><br><span class="line">let [ firstColor, secondColor ] = colors;</span><br><span class="line"></span><br><span class="line">console.log(firstColor);        // &quot;red&quot;</span><br><span class="line">console.log(secondColor);       // &quot;green&quot;</span><br></pre></td></tr></table></figure>
<p>这里的数组解构将数组中”red”和”green”值存在变量firstColor和secondColor上，之所以会这样是因为它们在数组中的位置，至于变量名字可以随便取，如果在对应位置没有响应的变量名解构将忽略它。记住解构过程是不会给不数组本身。  </p>
<p>在数组解构中你也可以省略掉你不想要的值只在对应位置提供相应的变量名，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line"></span><br><span class="line">let [ , , thirdColor ] = colors;</span><br><span class="line"></span><br><span class="line">console.log(thirdColor);        // &quot;blue&quot;</span><br></pre></td></tr></table></figure>
<p>这段代码利用了解构赋值来获取数组(colors)里的第三项。在thridColor前面的逗号都是数组项的占位符，你可以轻松的选出数组中间位置的变量而不需要提供前面变量的名字。  </p>
<ul>
<li>__warning__：和对象解构一样你必须为初始化值通过var，let，const</li>
</ul>
<h4 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>你也利用解构来赋值，但是和对象解构不一样的是你需要为变量加一层大括号，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ],</span><br><span class="line">    firstColor = &quot;black&quot;,</span><br><span class="line">    secondColor = &quot;purple&quot;;</span><br><span class="line"></span><br><span class="line">[ firstColor, secondColor ] = colors;</span><br><span class="line"></span><br><span class="line">console.log(firstColor);        // &quot;red&quot;</span><br><span class="line">console.log(secondColor);       // &quot;green&quot;</span><br></pre></td></tr></table></figure>
<p>这段代码中的解构赋值和前一次的数组解构例子相似，唯一的不同是firstColor和secondColor先定义，大多数这些就是你需要知道关于数组解构的东西了，但是更多的是你会发现知道这些就已经很有用了。  </p>
<p>数组解构赋值有一个非常独特用处，那就是交换两个变量值。值的交换在排序算数中是一种相当常规的操作，在ES5中交换两个变量值需要一个临时变量，如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Swapping variables in ECMAScript 5</span><br><span class="line">let a = 1,</span><br><span class="line">    b = 2,</span><br><span class="line">    tmp;</span><br><span class="line"></span><br><span class="line">tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line"></span><br><span class="line">console.log(a);     // 2</span><br><span class="line">console.log(b);     // 1</span><br></pre></td></tr></table></figure>
<p>ES5中交换a和b值中间变量tmp是必不可少的，利用解构赋值就不再需要这样的额外变量，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Swapping variables in ECMAScript 6</span><br><span class="line">let a = 1,</span><br><span class="line">    b = 2;</span><br><span class="line"></span><br><span class="line">[ a, b ] = [ b, a ];</span><br><span class="line"></span><br><span class="line">console.log(a);     // 2</span><br><span class="line">console.log(b);     // 1</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Warning</strong>: 和对象解构相同当解构赋值表达式右边数组项有求值为null或undefined时都将抛出一个错误。</li>
</ul>
<h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><p>数组解构赋值运行你为数组中任何位置项提供默认值，同样的当给定的位置不存在，或者存在值为undefined时这个默认值被使用，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let colors = [ &quot;red&quot; ];</span><br><span class="line"></span><br><span class="line">let [ firstColor, secondColor = &quot;green&quot; ] = colors;</span><br><span class="line"></span><br><span class="line">console.log(firstColor);        // &quot;red&quot;</span><br><span class="line">console.log(secondColor);       // &quot;green&quot;</span><br></pre></td></tr></table></figure>
<p>这段代码中，colors数组只有一项，所以并没有为secondColor所匹配项，但是因为secondColor有默认项，最终它的值就为默认项值。  </p>
<h4 id="复杂数组解构"><a href="#复杂数组解构" class="headerlink" title="复杂数组解构"></a>复杂数组解构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let colors = [ &quot;red&quot;, [ &quot;green&quot;, &quot;lightgreen&quot; ], &quot;blue&quot; ];</span><br><span class="line"></span><br><span class="line">// later</span><br><span class="line"></span><br><span class="line">let [ firstColor, [ secondColor ] ] = colors;</span><br><span class="line"></span><br><span class="line">console.log(firstColor);        // &quot;red&quot;</span><br><span class="line">console.log(secondColor);       // &quot;green&quot;</span><br></pre></td></tr></table></figure>

<h4 id="不定项数组解构"><a href="#不定项数组解构" class="headerlink" title="不定项数组解构"></a>不定项数组解构</h4><p>第三章为函数引进了不定参数，同样数组解构也有类似的概念不定项(rest items),不定项用…加一个变量名语法表示数组中其余项，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line"></span><br><span class="line">let [ firstColor, ...restColors ] = colors;</span><br><span class="line"></span><br><span class="line">console.log(firstColor);        // &quot;red&quot;</span><br><span class="line">console.log(restColors.length); // 2</span><br><span class="line">console.log(restColors[0]);     // &quot;green&quot;</span><br><span class="line">console.log(restColors[1]);     // &quot;blue&quot;</span><br></pre></td></tr></table></figure>
<p>colors中的第一项赋值给firstColor，然后其余项赋值给一个新数组restColors.   </p>
<p>js数组能力中有一项明显的遗漏那就是复制，在ES5中，开发者常常使用concat()方法来代替复制数组方法，如： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// cloning an array in ECMAScript 5</span><br><span class="line">var colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line">var clonedColors = colors.concat();</span><br><span class="line"></span><br><span class="line">console.log(clonedColors);      //&quot;[red,green,blue]&quot;</span><br></pre></td></tr></table></figure>
<p>concat()方法意在将两个数组连接，当调用时没有传参将返回调用者的一份复制，在ES6中，在ES6中可以用数据结构中的不定项做相同的事情，如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// cloning an array in ECMAScript 6</span><br><span class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line">let [ ...clonedColors ] = colors;</span><br><span class="line"></span><br><span class="line">console.log(clonedColors);      //&quot;[red,green,</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>warning</strong>: 不定项在数组解构时必须为最后一项，不定项后面不能添加逗号如果有将报错。</li>
</ul>
<h3 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h3><p> 对象和数组解构可以一起使用，这样你就可以从一个对象数组相互嵌套的解构中提取想要的值。如：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> let node = &#123;</span><br><span class="line">        type: &quot;Identifier&quot;,</span><br><span class="line">        name: &quot;foo&quot;,</span><br><span class="line">        loc: &#123;</span><br><span class="line">            start: &#123;</span><br><span class="line">                line: 1,</span><br><span class="line">                column: 1</span><br><span class="line">            &#125;,</span><br><span class="line">            end: &#123;</span><br><span class="line">                line: 1,</span><br><span class="line">                column: 4</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        range: [0, 3]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">let &#123;</span><br><span class="line">    loc: &#123; start &#125;,</span><br><span class="line">    range: [ startIndex ]</span><br><span class="line">&#125; = node;</span><br><span class="line"></span><br><span class="line">console.log(start.line);        // 1</span><br><span class="line">console.log(start.column);      // 1</span><br><span class="line">console.log(startIndex);        // 0</span><br></pre></td></tr></table></figure><br>这段代码将node.loc.start和node.range[0]的值提取到对应的start和startIndex中了，利用这种混合解构你就可以从JSON中提取任何你想要的值。  </p>
<h3 id="解构参数"><a href="#解构参数" class="headerlink" title="解构参数"></a>解构参数</h3><p>解构拥有很多有用的使用场景，其中之一就为函数传参时.当js函数需要接受很多参数项时，一个常见的模式创建一个option对象来指定这些参数，如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// properties on options represent additional parameters</span><br><span class="line">function setCookie(name, value, options) &#123;</span><br><span class="line"></span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    let secure = options.secure,</span><br><span class="line">        path = options.path,</span><br><span class="line">        domain = options.domain,</span><br><span class="line">        expires = options.expires;</span><br><span class="line"></span><br><span class="line">    // code to set the cookie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// third argument maps to options</span><br><span class="line">setCookie(&quot;type&quot;, &quot;js&quot;, &#123;</span><br><span class="line">    secure: true,</span><br><span class="line">    expires: 60000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>许多的js库都包含setCookie()这个函数，函数name和value参数必选，但是secure,path,domain,expires可选，既然这些属性顺序都没有优先级，将这些属性添加到一个对象的属性上是一个不错的方法，但是这样一来你就不能通过看函数定义知道要传入哪些参数，你必须看函数体。  </p>
<p>解构参数提供了一个更好替代方案，这样你就可以看函数定义而知道要传哪些参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setCookie(name, value, &#123; secure, path, domain, expires &#125;) &#123;</span><br><span class="line"></span><br><span class="line">    // code to set the cookie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(&quot;type&quot;, &quot;js&quot;, &#123;</span><br><span class="line">    secure: true,</span><br><span class="line">    expires: 60000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="必传的解构参数"><a href="#必传的解构参数" class="headerlink" title="必传的解构参数"></a>必传的解构参数</h4><p>解构参数有一个奇怪的地方是，在使用解构参数时如果没有提供默认值和调用时并没传解构的对象将会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Error!</span><br><span class="line">setCookie(&quot;type&quot;, &quot;js&quot;);</span><br></pre></td></tr></table></figure>
<p>第三个参数缺失时，其值如预想一样将被设为undifined,造成错误的原因是因为解构参数实际上就是解构声明的简写，当调用setCookie()时，js引擎实际会这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setCookie(name, value, options) &#123;</span><br><span class="line"></span><br><span class="line">    let &#123; secure, path, domain, expires &#125; = options;</span><br><span class="line"></span><br><span class="line">    // code to set the cookie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果解构参数是必选的，这样的行为是正常的，但是如果你的解构参数时可选时，你可以为解构参数提供一个默认值，如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setCookie(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解构参数默认值"><a href="#解构参数默认值" class="headerlink" title="解构参数默认值"></a>解构参数默认值</h4><p>你可以为解构参数指定默认值，这和你解构赋值时很像。只需要在参数后面添加等号和特定的默认参数值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setCookie(name, value,</span><br><span class="line">    &#123;</span><br><span class="line">        secure = false,</span><br><span class="line">        path = &quot;/&quot;,</span><br><span class="line">        domain = &quot;example.com&quot;,</span><br><span class="line">        expires = new Date(Date.now() + 360000000)</span><br><span class="line">    &#125; = &#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>javscript</category>
      </categories>
  </entry>
  <entry>
    <title>this</title>
    <url>/2017/12/05/%E7%AC%AC%E4%B8%89%E7%AB%A0this/</url>
    <content><![CDATA[<ul>
<li>1 <a href="#1">导言</a></li>
<li>2 <a href="#2">定义</a></li>
<li>3 <a href="#3">全局环境下的this值</a></li>
<li>4 <a href="#4">函数中的this值</a><ul>
<li>1 <a href="#4.1">引用类型</a></li>
<li>2  <a href="#4.2">函数调用与非引用类型</a></li>
<li>3  <a href="#4.3">引用类型与this的值为null</a></li>
<li>4  <a href="#4.4">构造器函数中的this值</a></li>
<li>5  <a href="#4.5">手动设置函数调用时this的值</a><span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a><span id="1">导言</span></h2><p>在这篇文章中我们将讨论更多和<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/">执行上下文</a>相关的细节.这次我们讨论的话题为this关键字.  </p>
<p>实践表明,this在不同执行上下文的值常常引起讨论. </p>
<p>许多的开发者常常认为关键字this在编程语言中只和面向对象编程相关,也就是this只是指向由构造函数创建的对象.在ECMAScript中this概念也的确是这样实现了，但是如我们所见到了,this并不止止于新创建的对象.  </p>
<p>让我们看看this值在ECMAScript中的具体细节.  </p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><span id="2">定义</span></h2><p>this是执行上下文的一个属性.它是上下文代码执行时的一个特别对象.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">    VO: &#123;...&#125;,</span><br><span class="line">    this: thisValue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里VO是<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/">变量对象</a>,它在我们先前章节中有讨论.  </p>
<p>this直接和这个上下文的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/#types-of-executable-code">可执行代码类型</a>相关.它的值在进入上下文时决定,且在代码运行时不可改变.  </p>
<p>让我们仔细看这些例子.</p>
<h2 id="在全局环境下this的值"><a href="#在全局环境下this的值" class="headerlink" title="在全局环境下this的值"></a><span id='3'>在全局环境下this的值</span></h2><p>在这里所有的东西都足够简单.在全局环境下,this的值总是全局对象本身.因此可以直接引用它.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// explicit property definition of</span><br><span class="line">// the global object</span><br><span class="line">this.a = 10; // global.a = 10</span><br><span class="line">console.log(a); // 10</span><br><span class="line"> </span><br><span class="line">// implicit definition via assigning</span><br><span class="line">// to unqualified identifier</span><br><span class="line">b = 20;</span><br><span class="line">console.log(this.b); // 20</span><br><span class="line"> </span><br><span class="line">// also implicit via variable declaration</span><br><span class="line">// because variable object of the global context</span><br><span class="line">// is the global object itself</span><br><span class="line">var c = 30;</span><br><span class="line">console.log(this.c); // 30</span><br></pre></td></tr></table></figure>


<h2 id="在函数中this的值"><a href="#在函数中this的值" class="headerlink" title="在函数中this的值"></a><span id="4">在函数中this的值</span></h2><p>当this在函数中就变得有趣了,这种情况将更难和引起更多讨论.  </p>
<p>this在这种代码里最主要的特点是它的值是动态绑定到函数的.  </p>
<p>如上面所提到的一样,this值是在进入上下文时决定的.并且在函数代码中this值可以每次都绝对不一样.  </p>
<p>但是,在运行时的this值是不变的.i.e你绝对不可能对它赋予一个新的值,那是因为它不是一个变量值(相反的是,在Python中它被明确定义为self对象,且这个对象可以在运行时改变):  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = &#123;x: 10&#125;;</span><br><span class="line"> </span><br><span class="line">var bar = &#123;</span><br><span class="line">  x: 20,</span><br><span class="line">  test: function () &#123;</span><br><span class="line"> </span><br><span class="line">    console.log(this === bar); // true</span><br><span class="line">    console.log(this.x); // 20</span><br><span class="line">     </span><br><span class="line">    this = foo; // error, can&#x27;t change this value</span><br><span class="line">  </span><br><span class="line">    console.log(this.x); // if there wasn&#x27;t an error, then would be 10, not 20</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// on entering the context this value is</span><br><span class="line">// determined as &quot;bar&quot; object; why so - will</span><br><span class="line">// be discussed below in detail</span><br><span class="line"> </span><br><span class="line">bar.test(); // true, 20</span><br><span class="line"> </span><br><span class="line">foo.test = bar.test;</span><br><span class="line"> </span><br><span class="line">// however here this value will now refer</span><br><span class="line">// to &quot;foo&quot; – even though we&#x27;re calling the same function</span><br><span class="line"> </span><br><span class="line">foo.test(); // false, 10</span><br></pre></td></tr></table></figure>

<p>所以什么样的因素决定在函数代码中this的值?这里主要有几个因素.  </p>
<p>首先,通常的一个函数调用,this的值由调用者(激活上下文的代码)决定.i.e.在父级上下文中调用函数，this的值由调用表达式的形式决定(换句话说也是就函数如何语法上调用).  </p>
<p>将这个概念记住和理解是很重要的，因为只有这样你才能对this在任何上下文的值都准确知道. 这个概念准确的说是调用表达式的形式(the form of a call expression),i.e.调用函数的方式影响这个上下文this值.  </p>
<p>(我们在一些js文章甚至书上看到,this的值依赖于函数是如何定义的：如果一个全局函数那么this值就设置为全局对象,如果函数是一个对象的方法那么this的值总是设置为这个对象–多么错误的描述).我们继续,我们看到甚至普通全局函数通过不同形式的调用表达式this的也会有不同.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); // global</span><br><span class="line"> </span><br><span class="line">console.log(foo === foo.prototype.constructor); // true</span><br><span class="line"> </span><br><span class="line">// but with another form of the call expression</span><br><span class="line">// of the same function, this value is different</span><br><span class="line"> </span><br><span class="line">foo.prototype.constructor(); // foo.prototype</span><br></pre></td></tr></table></figure>

<p>这和对象上定义的方法相似，this的值不总是为那个对象: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this === foo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); // foo, true</span><br><span class="line"> </span><br><span class="line">var exampleFunc = foo.bar;</span><br><span class="line"> </span><br><span class="line">console.log(exampleFunc === foo.bar); // true</span><br><span class="line"> </span><br><span class="line">// again with another form of the call expression</span><br><span class="line">// of the same function, we have different this value</span><br><span class="line"> </span><br><span class="line">exampleFunc(); // global, false</span><br></pre></td></tr></table></figure>


<p>所以调用表达式是如何影响this的值?为了完全的理解如何影响this值,我们需要了解一种内部类型– 引用类型( Referece type ).  </p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a><span id="4.1">引用类型</span></h3><p>用伪代码表示引用类型可以把它当成一个拥有两个属性的对象:base(i.e.属性所属与对象)和属性名：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var valueOfReferenceType = &#123;</span><br><span class="line">  base: &lt;base object&gt;,</span><br><span class="line">  propertyName: &lt;property name&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：从ES5开始引用包含属性可以使用”严格(stirct)”–这个标识决定引用是否在严格模式里求值.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"> </span><br><span class="line">// Access foo.</span><br><span class="line">foo;</span><br><span class="line"> </span><br><span class="line">// Reference for `foo`.</span><br><span class="line">const fooReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &#x27;foo&#x27;,</span><br><span class="line">  strict: true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为引用类型(Reference type)的值只有两种情况中：</p>
<ul>
<li>1 当处理一个标识符时</li>
<li>2 或者处理一个属性访问符</li>
</ul>
<p>标识符在标识符求值过程决定. 且具体可以参考<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/">第4章.作用域链</a>,最终会返回一个为引用类型的值(它对this很重要).  </p>
<p>标识符有这些类型：变量名,函数名，函数参数，在全局对象上的不规范属性,如下例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = 10;</span><br><span class="line">function bar() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>作为处理标识符的中间结果引用类型值,如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fooReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &#x27;foo&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">var barReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &#x27;bar&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了从引用类型的到对象真正的值，还需要经过getValue方法,伪代码如下: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function GetValue(value) &#123;</span><br><span class="line"> </span><br><span class="line">  if (Type(value) != Reference) &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  var base = GetBase(value);</span><br><span class="line"> </span><br><span class="line">  if (base === null) &#123;</span><br><span class="line">    throw new ReferenceError;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  return base.[[Get]](GetPropertyName(value));</span><br></pre></td></tr></table></figure>

<p>其中的内部方法[[Get]]返回这个对象属性的真正值,这和从原型链上获取属性的分析相同.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetValue(fooReference); // 10</span><br><span class="line">GetValue(barReference); // function object &quot;bar&quot;</span><br></pre></td></tr></table></figure>

<p>属性访问器也有两种类型：点标记(当提前知道属性名为一个合理的标识符名时),或者方括号标记:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo.bar();</span><br><span class="line">foo[&#x27;bar&#x27;]();</span><br></pre></td></tr></table></figure>

<p>在返回的中间计算过程中,我们可以得到也可以得到引用类型的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fooBarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  propertyName: &#x27;bar&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">GetValue(fooBarReference); // function object &quot;bar&quot;</span><br></pre></td></tr></table></figure>

<p>所以在函数上下文中引用类型是如何与this的值相关联的?–重要的时刻来到了.在函数上下文中this值的一般准信规则如下:  </p>
<ul>
<li>在函数上下文中this的值是头调用者提供,并且由当前调用表达式形式决定(函数是如何语法上调用).</li>
</ul>
<p>如果在调用圆括号(…)的右边,是一个引用类型的值那么this的值就被设定为引用类型的base对象.  </p>
<p>剩余的其他情况(i.e:和引用类型不一样的值),this值被设置为null.但是因为this的值为null没有任何道理,所以就隐式转为全局对象.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); // global</span><br></pre></td></tr></table></figure>

<p>在调用圆括号的左边是一个引用类型值(因为foo是一个标识符):  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fooReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &#x27;foo&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的this值为引用类型的bese对象,type i.e. 全局对象.  </p>
<p>和属性访问器相似的:   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); // foo</span><br></pre></td></tr></table></figure>

<p>我们这个引用类型值的base就是foo对象.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fooBarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  propertyName: &#x27;bar&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是,对同一个函数用另一调用表达式调用那么this的值就不一样了:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var test = foo.bar;</span><br><span class="line">test(); // global</span><br></pre></td></tr></table></figure>

<p>因为tests是一个标识符,也就会产生另外的引用类型,它的base对象(全局对象)就会被当做this的值:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var testReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &#x27;test&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意:在ES5中的严格模式,this的值在不是全局对象而是undefined</li>
</ul>
<p>现在我们可以准确的知道,为什么同样的函数用不同的调用表达式激活,拥有不同的this值–答案是有不同中间引用类型值:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); // global, because</span><br><span class="line"> </span><br><span class="line">var fooReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &#x27;foo&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">console.log(foo === foo.prototype.constructor); // true</span><br><span class="line"> </span><br><span class="line">// another form of the call expression</span><br><span class="line"> </span><br><span class="line">foo.prototype.constructor(); // foo.prototype, because</span><br><span class="line"> </span><br><span class="line">var fooPrototypeConstructorReference = &#123;</span><br><span class="line">  base: foo.prototype,</span><br><span class="line">  propertyName: &#x27;constructor&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他this值例子:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.bar);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var x = &#123;bar: 10&#125;;</span><br><span class="line">var y = &#123;bar: 20&#125;;</span><br><span class="line"> </span><br><span class="line">x.test = foo;</span><br><span class="line">y.test = foo;</span><br><span class="line"> </span><br><span class="line">x.test(); // 10</span><br><span class="line">y.test(); // 20</span><br></pre></td></tr></table></figure>

<h3 id="函数调用与非引用类型"><a href="#函数调用与非引用类型" class="headerlink" title="函数调用与非引用类型"></a><span id="4.2">函数调用与非引用类型</span></h3><p>如我们所提到的,在调用圆括号的左边不是一个引用类型值时,this的值自动设置为null,并且最后被设置为全局对象.  </p>
<p>让我们看看下面表达式:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  console.log(this); // null =&gt; global</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>在上面的情况中,我们的函数对象那个不是引用类型(不是标识符也不是属性访问器),相应的this的值最终被设置为全局对象.  </p>
<p>看一些复杂的例子:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); // Reference, OK =&gt; foo</span><br><span class="line">(foo.bar)(); // Reference, OK =&gt; foo</span><br><span class="line"> </span><br><span class="line">(foo.bar = foo.bar)(); // global?</span><br><span class="line">(false || foo.bar)(); // global?</span><br><span class="line">(foo.bar, foo.bar)(); // global?</span><br></pre></td></tr></table></figure>

<p>为什么一个属性访问器,在某些时候this的值不是bese对象而是全局对象?</p>
<p>最后三个调用,在进行某些操作后,调用圆括号的左边已经不是引用类型了.  </p>
<p>第一个调用比较明显就不说了.</p>
<p>第二种情况有一个圆括号运算符,没有什么副作用,调用圆括号的左边任然是引用类型值,所以返回foo.  </p>
<p>第三种情况中,赋值运算符不和圆括号运算符一样,它会调用GetValue方法(<a href="http://bclary.com/2004/11/07/#a-11.13.1">11.13.1</a>的第三步),返回一个函数对象本身(而不是引用类型值)这意味着this的值为设置为null最终设置为全局.  </p>
<p>和第四种和第五种情况相似的–逗号运算符与逻辑或表达式调用GetValue方法,响应的会返回函数本身值而不是引用类型值,this最终设置为全局对象.  </p>
<h3 id="引用类型与this的值为null"><a href="#引用类型与this的值为null" class="headerlink" title="引用类型与this的值为null"></a><span id="4.3">引用类型与this的值为null</span></h3><p>这里存在一种情况：当调用圆括号左边是一个引用类型值,但是this值任然全局对象.这是因为引用类型的base对象为一个<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#variable-object-in-function-context">激活对象(activation object)</a>.   </p>
<p>我们可以在内部函数调用发现这种情况,如我们所知本地变量,内部函数,形参都被存储在函数的一个激活对象中:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    console.log(this); // global</span><br><span class="line">  &#125;</span><br><span class="line">  bar(); // the same as AO.bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激活对象返回this的值总是null(i.e.伪代码AO.bar()与null.bar()等价).最终this值被转换为全局对象.</p>
<p>如果在一个with语句中,那就不一样了. 这是因为with语句将一个对象添加到作用域链的前端.i.e.这个对象那个在激活对象前.所以对应拥有引用类型值(要么通过标识符要么通过属性访问器).它的base对象就不和激活对象的bese对象相同了.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line"> </span><br><span class="line">with (&#123;</span><br><span class="line"> </span><br><span class="line">  foo: function () &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;,</span><br><span class="line">  x: 20</span><br><span class="line"> </span><br><span class="line">&#125;) &#123;</span><br><span class="line"> </span><br><span class="line">  foo(); // 20</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// because</span><br><span class="line"> </span><br><span class="line">var  fooReference = &#123;</span><br><span class="line">  base: __withObject,</span><br><span class="line">  propertyName: &#x27;foo&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和catch从句相似,但是ES5与ES3表现不一致.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  throw function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  e(); // __catchObject - in ES3, global - fixed in ES5</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// on idea</span><br><span class="line"> </span><br><span class="line">var eReference = &#123;</span><br><span class="line">  base: __catchObject,</span><br><span class="line">  propertyName: &#x27;e&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// but, as this is a bug</span><br><span class="line">// then this value is forced to global</span><br><span class="line">// null =&gt; global</span><br><span class="line"> </span><br><span class="line">var eReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &#x27;e&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样的也发生在具名函数表达式递归调用中. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function foo(bar) &#123;</span><br><span class="line"> </span><br><span class="line">  console.log(this);</span><br><span class="line"> </span><br><span class="line">  !bar &amp;&amp; foo(1); // &quot;should&quot; be special object, but always (correct) global</span><br><span class="line"> </span><br><span class="line">&#125;)(); // global</span><br></pre></td></tr></table></figure>

<h3 id="构造器函数中的this值"><a href="#构造器函数中的this值" class="headerlink" title="构造器函数中的this值"></a><span id="4.4">构造器函数中的this值</span></h3><p>和this相关的更多是在构造函数中this值.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  console.log(this); // newly created object, below - &quot;a&quot; object</span><br><span class="line">  this.x = 10;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var a = new A();</span><br><span class="line">console.log(a.x); // 10</span><br></pre></td></tr></table></figure>

<p>在这种情况,new 操作符会调用函数内部方法[[Construct]],依次,在对象创建好后,调用内部方法[[Call]],所有A函数创建的对象都指向this.  </p>
<h3 id="手动设置函数调用时this的值"><a href="#手动设置函数调用时this的值" class="headerlink" title="手动设置函数调用时this的值"></a><span id="4.5">手动设置函数调用时this的值</span></h3><p>在Function.prototype定义了两个可以改变this值的方法，call,apply.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var b = 10;</span><br><span class="line"> </span><br><span class="line">function a(c) &#123;</span><br><span class="line">  console.log(this.b);</span><br><span class="line">  console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">a(20); // this === global, this.b == 10, c == 20</span><br><span class="line"> </span><br><span class="line">a.call(&#123;b: 20&#125;, 30); // this === &#123;b: 20&#125;, this.b == 20, c == 30</span><br><span class="line">a.apply(&#123;b: 30&#125;, [40]) // this === &#123;b: 30&#125;, this.b == 30, c == 40</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>第四章 对象</title>
    <url>/2017/07/10/%E7%AC%AC4%E7%AB%A0%20%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="对象功能扩展"><a href="#对象功能扩展" class="headerlink" title="对象功能扩展"></a>对象功能扩展</h3><p>ES6在改进对象能力上花了很多的功夫，这是因为基本大部分js的值都是某种类型的对象，另外随着js应用程序复杂程度的提升代码中对象数量也随之提升。这也意味着对象需要更加高效的使用。  </p>
<p>ES6通过各种方法改进对象，从简单的语法扩展再到提供更多选择处理对象。 </p>
<span id="more"></span> 

<h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><p>js使用混合术语来描述标准里的对象，而不是通过执行环境(浏览器，Node.js)来描述，ES6规格书里明确定义了每种类别的对象。对于全面了解这面语言理解这些术语是相当重要的，对象的类别如下：</p>
<ul>
<li>__普通对象__拥有所有在js中内置默认行为的对象。</li>
<li>__外来对象__拥有和内置行为和默认行为不一致的对象。</li>
<li>__标准对象__哪些由ES6定义的对象，如Array,Date等，标准对象有可能是普通对象也有可能是外来对象。</li>
<li>__内置对象__在js开始执行之前就存在的对象，所有标准对象对象都是内置对象。</li>
</ul>
<p>我将在整本书里用这些术语来解释ES6定义的对象</p>
<h4 id="对象字面量语法扩展"><a href="#对象字面量语法扩展" class="headerlink" title="对象字面量语法扩展"></a>对象字面量语法扩展</h4><p>对象字面量是js中最流行的模式之一，JSON就是基于它的语法，并且几乎存在于所有的在因特网上js文件，它流行的原因在于其简洁创建对象的方式。幸运的是ES6通过各种扩展语法的方法使用对象字面量更加有用。  </p>
<h4 id="属性初始化速记"><a href="#属性初始化速记" class="headerlink" title="属性初始化速记"></a>属性初始化速记</h4><p>在早先ES5之前，对象字面量只是简单的name-value对集合，这意味着当属性和值初始化时有可能重复，如例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createPerson(name, age) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ES6中你可以通过属性初始化速记消除属性和本地变量。当对象属性和本地属性同名时，你可以仅包含名字而不需要冒号和值，如例createPerson()可以用ES6的方式重写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createPerson(name, age)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name, </span><br><span class="line">        age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当对象字面量的一个属性只有一个名字，js引擎将在附近作用域寻找与之名字相同的变量，如果找到了相同名字变量，将这个变量的值赋给字面量的这同名变量，在上面例子中对象字面量属性name就被赋予本地变量name值。  </p>
<p>这种扩展让对象字面量初始化更加简洁并且对消除命名错误起着一定的帮助，在js中将属性的值赋予一个本地同名变量的值是一种非常常见模式，这让这种扩展相当受欢迎。  </p>
<h4 id="简洁方法"><a href="#简洁方法" class="headerlink" title="简洁方法"></a>简洁方法</h4><p>ES6中添加了一种在对象字面中添加方法的语法，在早先的ES5和之前的语法中，你在对象字面量中添加方法必须需要指定一个名字和一个完整的函数定义，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在ES6中，可以将这种语法通过消除分号和function关键词来简化，这意味着你可以重写前面的例子如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种速写语法也称简洁方法语法，像先前的那个对象Person，sayName属性被赋予了一个匿名函数并且和ES5中sayName()函数具有相同特性。唯一的不同是简洁方法也许使用super，但是非简洁方法也许不需要。</p>
<h4 id="计算属性名称"><a href="#计算属性名称" class="headerlink" title="计算属性名称"></a>计算属性名称</h4><p>在ES5和之前中在对象实例上可以使用方括号而不是点标记来计算属性，方括号让你可以使用字符串和变量来指定属性名，这些字符串包含的字符如果被当做标识符使用会造成一个语法错误。如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;&#125;,</span><br><span class="line">    lastName = &quot;last name&quot;;</span><br><span class="line"></span><br><span class="line">person[&quot;first name&quot;] = &quot;Nicholas&quot;;</span><br><span class="line">person[lastName] = &quot;Zakas&quot;;</span><br><span class="line"></span><br><span class="line">console.log(person[&quot;first name&quot;]);      // &quot;Nicholas&quot;</span><br><span class="line">console.log(person[lastName]);          // &quot;Zakas&quot;</span><br></pre></td></tr></table></figure>
<p>因为lastName被赋值为”last name”,属性名字有空格就不能使用使用点标记。  </p>
<p>另外你可以直接使用字符串字面量当做对象字面量属性名，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    &quot;first name&quot;: &quot;Nicholas&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person[&quot;first name&quot;]);      // &quot;Nicholas&quot;</span><br></pre></td></tr></table></figure>
<p>这种模式在属性名称提前知道情况下可以用字符串字面量表示，然而如果属性名”first name”被包含在一个变量中或者必须通过计算，这就没有 用ES5方式定义对象字面量的属性了。  </p>
<p>在ES6中，计算属性名称是对象字面量语法的一部分，并且它们也同样使用方括号，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lastName = &quot;last name&quot;;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    &quot;first name&quot;: &quot;Nicholas&quot;,</span><br><span class="line">    [lastName]: &quot;Zakas&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person[&quot;first name&quot;]);      // &quot;Nicholas&quot;</span><br><span class="line">console.log(person[lastName]);          // &quot;Zakas&quot;</span><br></pre></td></tr></table></figure>
<p>对象字面量中的方括号暗示这个属性名称是计算过的，所以它的内容被求值为字符，这也就意味着你也可以用方括号包含一个表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var suffix = &quot; name&quot;;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    [&quot;first&quot; + suffix]: &quot;Nicholas&quot;,</span><br><span class="line">    [&quot;last&quot; + suffix]: &quot;Zakas&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person[&quot;first name&quot;]);      // &quot;Nicholas&quot;</span><br><span class="line">console.log(person[&quot;last name&quot;]);       // &quot;Zakas&quot;</span><br></pre></td></tr></table></figure>
<p>这些属性被求值为”first name”和”last name”,之后这些字符串可以被当做对象属性的引用。</p>
<h3 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h3><p>在ES设计目标中，有一个从ES5就开始了的，那就是通过在全局对象增加新的方法来避免在Object.prototype上创建新的全局方法或函数。因此ES6引进许多新方法在全局对象上结果是让某些工作更容易。</p>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>在js中当你想对比两个值时，你也许会用等于操作符(&#x3D;&#x3D;)或全等操作符(&#x3D;&#x3D;&#x3D;)来比较。大多数开发者更喜欢后者，这是因为这样可以避免比较中的强制类型转换。但是就算是全等操作符也不可能完全正确。如 +0和-0通过全等符(&#x3D;&#x3D;&#x3D;)比较也相等，但是在js引擎中它们表示两种不一样的值，同样 NaN &#x3D;&#x3D;&#x3D; NaN 返回false，这就必须要用isNaN()来检查NaN属性了。   </p>
<p>ES6通过引进Object.is()方法来弥补全等操作符(&#x3D;&#x3D;&#x3D;)的缺陷，这个方法接受两个参数如果返回true则表明真正的相等，只有当两个值拥有相同类型和值时才能算真正相等:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(+0 == -0);              // true</span><br><span class="line">console.log(+0 === -0);             // true</span><br><span class="line">console.log(Object.is(+0, -0));     // false</span><br><span class="line"></span><br><span class="line">console.log(NaN == NaN);            // false</span><br><span class="line">console.log(NaN === NaN);           // false</span><br><span class="line">console.log(Object.is(NaN, NaN));   // true</span><br><span class="line"></span><br><span class="line">console.log(5 == 5);                // true</span><br><span class="line">console.log(5 == &quot;5&quot;);              // true</span><br><span class="line">console.log(5 === 5);               // true</span><br><span class="line">console.log(5 === &quot;5&quot;);             // false</span><br><span class="line">console.log(Object.is(5, 5));       // true</span><br><span class="line">console.log(Object.is(5, &quot;5&quot;));     // false</span><br></pre></td></tr></table></figure>
<p>在许多情况，Object.is()和全等操作符(&#x3D;&#x3D;&#x3D;)作用相同,唯一的不同就体现在+0和-0，NaN的比较上，但是没有必要停止使用全等操作符(&#x3D;&#x3D;&#x3D;),是否选择使用Object.is()取决于你代码实际情况。</p>
<h4 id="Obejct-assign"><a href="#Obejct-assign" class="headerlink" title="Obejct.assign()"></a>Obejct.assign()</h4><p>在js中混合是对象组成最流行的模式，在使用混合时一个对象接受另一个对象的属性和方法，许多js库都有实现这样的一个混合方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mixin(receiver, supplier)&#123;</span><br><span class="line">    Object.keys(supplier).forEach(function(key)&#123;</span><br><span class="line">        receiver[key] = supplier[key];</span><br><span class="line">    &#125;);</span><br><span class="line">    return receiver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个mixin()方法通过遍历supplier本身属性来复制到receiver上()(这是一个浅复制，当复制一个对象时只复制对象的一个引用)。这让receiver不需要继承而得到新属性，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function EventTarget() &#123; /*...*/ &#125;</span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">    constructor: EventTarget,</span><br><span class="line">    emit: function() &#123; /*...*/ &#125;,</span><br><span class="line">    on: function() &#123; /*...*/ &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var myObject = &#123;&#125;;</span><br><span class="line">mixin(myObject, EventTarget.prototype);</span><br><span class="line"></span><br><span class="line">myObject.emit(&quot;somethingChanged&quot;);</span><br></pre></td></tr></table></figure>
<p>这里myObject 通过接收EventTarget.prototype对象行为，而获得相应的订阅和发布能力。  </p>
<p>这种模式流行到ES6都为之添加一个Obejct.assign()方法，它的表现方式和mixin()都相同接收一个receiver和多个suppliers，最后返回一个ceceiver，它的名字从mixin变到assign,同时这个名字反应实际的操作。因为这个mixin()函数实际上使用 &#x3D;操作符，所以不能复制 accessor 属性，Object.assign()就是反应这个区别的。  </p>
<p>你可以在任何使用mixin()的地方使用Object.assign()，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function EventTarget() &#123; /*...*/ &#125;</span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">    constructor: EventTarget,</span><br><span class="line">    emit: function() &#123; /*...*/ &#125;,</span><br><span class="line">    on: function() &#123; /*...*/ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myObject = &#123;&#125;</span><br><span class="line">Object.assign(myObject, EventTarget.prototype);</span><br><span class="line"></span><br><span class="line">myObject.emit(&quot;somethingChanged&quot;);</span><br></pre></td></tr></table></figure>

<p>方法Object.assign()可以接受任意多个suppliers，receiver接受属性的顺序由suppliers指定，这就意味着第二个supplier可以重写第一个supplier赋给receiver的值。如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var receiver = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(receiver,</span><br><span class="line">    &#123;</span><br><span class="line">        type: &quot;js&quot;,</span><br><span class="line">        name: &quot;file.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        type: &quot;css&quot;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(receiver.type);     // &quot;css&quot;</span><br><span class="line">console.log(receiver.name);     // &quot;file.js&quot;</span><br></pre></td></tr></table></figure>
<p>reviver.type的值为”css”因为第二个supplier重写第一个赋予的值。  </p>
<p>Object.assign方法在ES6中并不是什么大的添加，但这会格式化许多js库的这个方法。</p>
<h4 id="对象字面量属性名重叠"><a href="#对象字面量属性名重叠" class="headerlink" title="对象字面量属性名重叠"></a>对象字面量属性名重叠</h4><p>ES5严格模式中引进了检查对象字面量属性重叠，如果发现有重叠属性将会抛出一个错误，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    name: &quot;Greg&quot;        // syntax error in ES5 strict mode</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然而在ES6中无论是否在严格模式都将不会检查属性名重叠。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    name: &quot;Greg&quot;        // no error in ES6 strict mode</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person.name);       // &quot;Greg&quot;</span><br></pre></td></tr></table></figure>

<h4 id="可枚举属性排序"><a href="#可枚举属性排序" class="headerlink" title="可枚举属性排序"></a>可枚举属性排序</h4><p>ES5并没有定义对象枚举时属性顺序，它将这些都交给js引擎自行决定。然而在ES6中明确定义了枚举属性时属性返回的顺序，它影响Object.getOwnPropertyNames()和Reflect.ownKeys()以及Object.assign()。  </p>
<p>对象自身属性枚举基本顺序：  </p>
<ul>
<li><ol>
<li>所有数字键按升序排序。</li>
</ol>
</li>
<li><ol start="2">
<li>所有字符串按添加到对象顺序。</li>
</ol>
</li>
<li><ol start="3">
<li>所有symbol键按添加到对象顺序。</li>
</ol>
</li>
</ul>
<p>如下例： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    0: 1,</span><br><span class="line">    c: 1,</span><br><span class="line">    2: 1,</span><br><span class="line">    b: 1,</span><br><span class="line">    1: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.d = 1;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyNames(obj).join(&quot;&quot;));     // &quot;012acbd&quot;</span><br></pre></td></tr></table></figure>

<p>方法Object.getOwnPropertyNames()返回对象键值以0,1,2,a,c,d,b的顺序.注意数字键集合在一起并排序后返回，尽管这不是对象字面量中顺序。字符串键值在数字键值之后以添加到对象的顺序排序，先是在对象字面量上的，然后是动态添加的。</p>
<ul>
<li>note：在最新的chrome中Object.keys(),for-in,JSON.stringify()也是按这种顺序排序的。</li>
</ul>
<h3 id="更加强大的Prototypes"><a href="#更加强大的Prototypes" class="headerlink" title="更加强大的Prototypes"></a>更加强大的Prototypes</h3><p>在js中Prototypes是继承的基石，并且在ES6中prototypes将更强大，在js的早些版本中prototypes的使用被严重的限制起来，然而随着这门语言的成熟和开发者更加熟悉使用Prototypes,开发者想更多的控制prototypes并且以一种更简单的方式使用。结果是ES6引进了一些在prototype上的改进。</p>
<h4 id="对象上prototype改变"><a href="#对象上prototype改变" class="headerlink" title="对象上prototype改变"></a>对象上prototype改变</h4><p>正常情况下，对象的prototype在对象被创建时(构造器，Object.create())就指定了，对象的prototype在对象实例化后没有改变是ES5中js程序最大的前提假设。尽管ES5添加了Object.getPrototypeOf()方法来检测对象的prototype。但是现状是仍然缺少标准方法改变实例化后对象的prototype。  </p>
<p>ES6通过增加Object.setPrototypeof()方法来改变这种假设，这个方法可以任何对象的prototype。这个方法接受两个参数第一个为将要改变prototype的对象第二个为赋值的prototype值，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        return &quot;Hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        return &quot;Woof&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// prototype is person</span><br><span class="line">let friend = Object.create(person);</span><br><span class="line">console.log(friend.getGreeting());                      // &quot;Hello&quot;</span><br><span class="line">console.log(Object.getPrototypeOf(friend) === person);  // true</span><br><span class="line"></span><br><span class="line">// set prototype to dog</span><br><span class="line">Object.setPrototypeOf(friend, dog);</span><br><span class="line">console.log(friend.getGreeting());                      // &quot;Woof&quot;</span><br><span class="line">console.log(Object.getPrototypeOf(friend) === dog);     // true</span><br></pre></td></tr></table></figure>
<p>这段代码定义了两个基本对象：person，dog.两个对象都有一个返回字符串的方法getGreeting(),对象friend一开始继承自person对象，这意味着调用getGreeting()时输出”Hello”.当对象的prototype变成对象dog时,调用person.getGreeting()输出为”Woof”这是因为原来的与person对象的绑定已经断裂。  </p>
<p>对象的prototype实际上是一个被叫做[[Prototype]]的内部只读属性，方法Object.getPrototypeOf()返回存储在[[Prototype]]的值同时方法Object.setPrototypeOf()改变存储在[[Prototype]]的值，然而这些不是唯一能操作[[Prototype]]的方法。  </p>
<h4 id="用Super引用访问Prototype"><a href="#用Super引用访问Prototype" class="headerlink" title="用Super引用访问Prototype"></a>用Super引用访问Prototype</h4><p>原来提到过，prototypes在js中相当重要并且为了更容易使用它ES6为此花了很多功夫在上面，这其中有super引用，这让访问对象的prototype功能更加容易，如下为了重载prototype上同名函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        return &quot;Hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        return &quot;Woof&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        return Object.getPrototypeOf(this).getGreeting.call(this) + &quot;, hi!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// set prototype to person</span><br><span class="line">Object.setPrototypeOf(friend, person);</span><br><span class="line">console.log(friend.getGreeting());                      // &quot;Hello, hi!&quot;</span><br><span class="line">console.log(Object.getPrototypeOf(friend) === person);  // true</span><br><span class="line"></span><br><span class="line">// set prototype to dog</span><br><span class="line">Object.setPrototypeOf(friend, dog);</span><br><span class="line">console.log(friend.getGreeting());                      // &quot;Woof, hi!&quot;</span><br><span class="line">console.log(Object.getPrototypeOf(friend) === dog);     // true</span><br></pre></td></tr></table></figure>
<p>在这个例子中，在对象firend上调用和prototype上同名的getGreeting()方法。Object.getPrototypeOf()是为保障正确的prototype被使用，另一段额外的代码.call(this)是为了保障在prototype中this值设置正确。  </p>
<p>为了使用原型(prototype)上的方法而使用Object.getPrototypeOf()和.call(this)这看起来有点复杂了，所以ES6引进了super,super指向当前对象prototype，等效于Object.getPrototypeOf(this),你可以简化getGreeting()方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let friend = &#123;</span><br><span class="line">    getGreeting()&#123;</span><br><span class="line">        // in the previous example, this is the same as:</span><br><span class="line">        // Object.getPrototypeOf(this).getGreeting.call(this)</span><br><span class="line">        return super.getGreeting() +&quot; ,h1!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这上下文中调用super.getGreeting()相当于调用Object.getPrototypeOf(this).call(this),你可以通过super引用调用在原型上任何方法，但是如果原型链上没有此方法就会造成一个语法错误。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let friend = &#123;</span><br><span class="line">    getGreeting: function() &#123;</span><br><span class="line">        // syntax error</span><br><span class="line">        return super.getGreeting() + &quot;, hi!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子中调用super.getGreeting()造成一个语法错误，这是因为super在这个上下文下是无效的。</p>
<h4 id="正式定义方法"><a href="#正式定义方法" class="headerlink" title="正式定义方法"></a>正式定义方法</h4><p>在ES6之前，方法(method)的概念没有正式定义，方法只是对象上为函数而不是数据的属性，然而ES6正式定义方法：一个拥有内部属性[[HomeObject]]的函数，这个属性包含这个函数属于的对象，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line"></span><br><span class="line">    // method</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        return &quot;Hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// not a method</span><br><span class="line">function shareGreeting() &#123;</span><br><span class="line">    return &quot;Hi!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中定一个了一个拥有方法getGreeting()的对象person。getGreeting()的[[HomeObject]]值为person，另一方面shareGreeting()没有[[HomeObject]]属性，这是因为这个函数创建时没有指定为一个对象属性，大多数情况下这种差别并不明显，但在使用super时特别重要。  </p>
<p>任何super引用是基于[[HomeObject]]的，第一步是基于[[HomeObject]]调用Object.getPrototypeOf()找寻prototype的引用，如果在prototype上找到需要调用的同名属性或函数，最后this绑定方法调用，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        return &quot;Hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// prototype is person</span><br><span class="line">let friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        return super.getGreeting() + &quot;, hi!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.setPrototypeOf(friend, person);</span><br><span class="line"></span><br><span class="line">console.log(friend.getGreeting());  // &quot;Hello, hi!&quot;</span><br></pre></td></tr></table></figure>
<p>调用friend.getGreeting()返回一个字符串，这个字符串由person.getGreeting和” hi!”组成。friend.getGreeting()的[[HomeObject]]为friend,所以friend的prototype为person,最终super.getGreeting()等效于person.getGreeting.call(this)。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ES6对对象字面量做了几处改变，简写属性定义让当前作用域同名属性赋值更方便了，计算属性名称让你可以指定非字面量值作为属性名称，简写方法让你在定义方法时少打一些字符（:function），ES6对象严格模式下重复定义属性名不再限制这意味着你可以在严格模式定义两个重名属性而得到最后个属性。   </p>
<p>Object.assign()相当于一个标准的mixin模式。Object.is()是可以更加严格的等于比较甚至比&#x3D;&#x3D;&#x3D;还严格。   </p>
<p>枚举自身属性的顺序也在ES6中得到明确定义，数字升序优先，其次字符，最后symbol keys。   </p>
<p>多亏ES6对象在创建后仍然可以通过方法Object.setPrototypeOf()改变其prototype.   </p>
<p>最终你可以通过关键字super调用原型对象上的方法。（？）</p>
]]></content>
      <categories>
        <category>javscript</category>
      </categories>
  </entry>
  <entry>
    <title>http缓存详解</title>
    <url>/2017/10/25/%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-HTTP缓存概述"><a href="#1-HTTP缓存概述" class="headerlink" title="1 HTTP缓存概述"></a>1 HTTP缓存概述</h2><p>http缓存是一种利用第一次请求后保存副本其后的请求可以利用缓存响应的技术，它的主要目的为节省流量以及增加资源响应速度。  </p>
<h3 id="1-1-HTTP缓存的基本机制"><a href="#1-1-HTTP缓存的基本机制" class="headerlink" title="1.1 HTTP缓存的基本机制"></a>1.1 HTTP缓存的基本机制</h3><p>每次如果要获取缓存就得走过一套缓存机制，具体如下图：<br><img src="/2017/10/25/%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/cacheMechanism.png" alt="cacheMechanism">  </p>
<span id="more"></span>
<p>用户发起请求后，会现在缓存中查找是否存在相匹配的缓存，如果没有就向源服务器发起一个请求，如果有的话就会检测这个缓存是否”新鲜”，如果新鲜的话就直接将缓存返回用户，若不新鲜就会向源服务器发送带有验证标识的请求来验证是否可以使用这个已经过期的缓存，若这个验证标识都通过了验证那么就会向发送一个304(not modified)响应，这个响应没有对应的响应体它只会更新缓存的新鲜度，若未通过则重新返回一个带有响应体的响应。<br>概况起来可以如下：</p>
<ul>
<li><p>(1) 接收——缓存从网络中读取抵达的请求报文。</p>
</li>
<li><p>(2) 解析——缓存对报文进行解析，提取出 URL 和各种首部。</p>
</li>
<li><p>(3) 查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保<br>存在本地） 。</p>
</li>
<li><p>(4) 新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是<br>否有任何更新。</p>
</li>
<li><p>(5) 创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。</p>
</li>
<li><p>(6) 发送——缓存通过网络将响应发回给客户端。</p>
</li>
<li><p>(7) 日志——缓存可选地创建一个日志文件条目来描述这个事务</p>
</li>
<li><p>note： 上面都是理想情况下比如说没有cache-control的控制，都是可缓存的响应，响应都成功之类。</p>
</li>
</ul>
<h3 id="1-2-缓存基本种类"><a href="#1-2-缓存基本种类" class="headerlink" title="1.2 缓存基本种类"></a>1.2 缓存基本种类</h3><p>缓存可以被单个用户使用，也可以被成千上万人使用。单用户缓存被称为”私用缓存(private cache)”,一般的浏览器都具有内置的私有缓存，多用户缓存被称为”共享缓存(shared cache)”一般由共享代理服务器来实现或者叫代理缓存(proxy cache)。</p>
<ul>
<li>note： 缓存一般情况下都是多级缓存<br><img src="/2017/10/25/%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/cacheType.png" alt="cacheMechanism"></li>
</ul>
<h3 id="1-3-控制缓存cache-control"><a href="#1-3-控制缓存cache-control" class="headerlink" title="1.3 控制缓存cache-control"></a>1.3 控制缓存cache-control</h3><p>缓存机制由服务端和客服务共同实现默认缓存机制，但是可以通过cache-control与其他的头信息配合修改默认缓存的行为，比如说一般默认缓存GET请求，但是可以通过cache-control：public指令来让POST也可以缓存。具体的指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这份图表来自 RFC2616</span><br><span class="line"> Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive</span><br><span class="line">  cache-directive = cache-request-directive</span><br><span class="line">       | cache-response-directive</span><br><span class="line">  cache-request-directive =</span><br><span class="line">         &quot;no-cache&quot;                          ; Section 14.9.1</span><br><span class="line">       | &quot;no-store&quot;                          ; Section 14.9.2</span><br><span class="line">       | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; Section 14.9.3, 14.9.4</span><br><span class="line">       | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; Section 14.9.3</span><br><span class="line">       | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; Section 14.9.3</span><br><span class="line">       | &quot;no-transform&quot;                      ; Section 14.9.5</span><br><span class="line">       | &quot;only-if-cached&quot;                    ; Section 14.9.4</span><br><span class="line">       | cache-extension                     ; Section 14.9.6</span><br><span class="line">   cache-response-directive =</span><br><span class="line">         &quot;public&quot;                               ; Section 14.9.1</span><br><span class="line">       | &quot;private&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ] ; Section 14.9.1</span><br><span class="line">       | &quot;no-cache&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ]; Section 14.9.1</span><br><span class="line">       | &quot;no-store&quot;                             ; Section 14.9.2</span><br><span class="line">       | &quot;no-transform&quot;                         ; Section 14.9.5</span><br><span class="line">       | &quot;must-revalidate&quot;                      ; Section 14.9.4</span><br><span class="line">       | &quot;proxy-revalidate&quot;                     ; Section 14.9.4</span><br><span class="line">       | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; Section 14.9.3</span><br><span class="line">       | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; Section 14.9.3</span><br><span class="line">       | cache-extension                        ; Section 14.9.6</span><br><span class="line">  cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ]</span><br></pre></td></tr></table></figure>
<ul>
<li>note:cache-control指令是单向的，请求有响应不一定有，并且在计算如新鲜度的时候优先级不一样。</li>
</ul>
<h4 id="1-3-1-缓存方式控制"><a href="#1-3-1-缓存方式控制" class="headerlink" title="1.3.1 缓存方式控制"></a>1.3.1 缓存方式控制</h4><p>控制缓存方式的有这几种no-cache,no-store,public,priviate</p>
<ul>
<li><p>no-cache：<br>在请求”no-cache”指令暗示着缓存必须在成功的从源服务器上验证后才能使用，在响应中也一样。</p>
</li>
<li><p>no-store:<br>包含这个存储指令暗示缓存一定不能存储请求或响应的任何部分，”一定不能存储”在这个语境中意味着缓存一定不能有意的将信息储存在固态存储器上，同时在信息转发后尽快尽力将其内存中移除。</p>
</li>
</ul>
<p>这个指令并不可靠且没有充分的机制来保障其隐私。特别是在恶意或协商缓存中也许不会识别，并且在和网络通信过程中可能被黑掉。  </p>
<p>注意：如果一个请求中包含这个指令并且在缓存中找到匹配响应，那么这个no-store请求指令并不能适用于这个已经存储好的响应。</p>
<ul>
<li><p>public：<br>这个响应指令暗示着任何缓存都可以存储这个响应，哪怕这个响应默认不可缓存，或者只能缓存在私有缓存(包含认证信息的响应只能是私有缓存，默认情况下只有特定响应状态码的响应才能存储)</p>
</li>
<li><p>private<br>这个缓存指令暗示响应消息只能被单个用户存储，一定不能被共享缓存所存储。如果响应默认不能缓存但是有私有存储指令后也可以变得可缓存。</p>
</li>
</ul>
<h3 id="1-4-新鲜度检测"><a href="#1-4-新鲜度检测" class="headerlink" title="1.4 新鲜度检测"></a>1.4 新鲜度检测</h3><p>新鲜度检测与使用时期(age)和新鲜生存期(freshness_lifttime)相关，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$is_fresh_enough = ($age &lt; $freshness_lifetime);</span><br></pre></td></tr></table></figure>
<p>age表示的是响应从源服务器响应(或在验证后)之后经历的总时间，这其中包括在因特网和网关中游荡的时间，中间节点缓存存储时间，以及响应在你的缓存停留的时间。具体计算如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$apparent_age = max(0, $time_got_response - $Date_header_value);</span><br><span class="line">$corrected_apparent_age = max($apparent_age, $Age_header_value);</span><br><span class="line">$response_delay_estimate = ($time_got_response - $time_issued_request);</span><br><span class="line">$age_when_document_arrived_at_our_cache =</span><br><span class="line">$corrected_apparent_age + $response_delay_estimate;</span><br><span class="line"></span><br><span class="line">$how_long_copy_has_been_in_our_cache = $current_time - $time_got_response;</span><br><span class="line"></span><br><span class="line">$age = $age_when_document_arrived_at_our_cache +</span><br><span class="line">$how_long_copy_has_been_in_our_cache;</span><br></pre></td></tr></table></figure>
<p>freshness_lifttime表示缓存生存的时间长度，有服务器响应和客户端请求共同决定，服务器端响应如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub server_freshness_limit</span><br><span class="line">&#123;</span><br><span class="line">  local($heuristic,$server_freshness_limit,$time_since_last_modify);</span><br><span class="line">  $heuristic = 0;</span><br><span class="line">  if ($Max_Age_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $server_freshness_limit = $Max_Age_value;</span><br><span class="line">  &#125;</span><br><span class="line">  elseif ($Expires_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $server_freshness_limit = $Expires_value - $Date_value;</span><br><span class="line">  &#125;</span><br><span class="line">  elseif ($Last_Modified_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $time_since_last_modify = max(0, $Date_value -</span><br><span class="line">  　　　　　　　　 $Last_Modified_value);</span><br><span class="line">    $server_freshness_limit = int($time_since_last_modify *</span><br><span class="line">  　　　　　　　　 $lm_factor);</span><br><span class="line">    $heuristic = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    $server_freshness_limit = $default_cache_min_lifetime;</span><br><span class="line">    $heuristic = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if ($heuristic)</span><br><span class="line">  &#123;</span><br><span class="line">    if ($server_freshness_limit &gt; $default_cache_max_lifetime)</span><br><span class="line">    &#123; $server_freshness_limit = $default_cache_max_lifetime; &#125;</span><br><span class="line">    if ($server_freshness_limit &lt; $default_cache_min_lifetime)</span><br><span class="line">    &#123; $server_freshness_limit = $default_cache_min_lifetime; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return($server_freshness_limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端的请求如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub client_modified_freshness_limit</span><br><span class="line">&#123;</span><br><span class="line">  $age_limit = server_freshness_limit( ); ## From Example 7-2</span><br><span class="line">  if ($Max_Stale_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    if ($Max_Stale_value == $INT_MAX)</span><br><span class="line">    &#123; $age_limit = $INT_MAX; &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123; $age_limit = server_freshness_limit( ) + $Max_Stale_value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  if ($Min_Fresh_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $age_limit = min($age_limit, server_freshness_limit( ) -</span><br><span class="line">  　　　　　　　$Min_Fresh_value_set);</span><br><span class="line">  &#125;</span><br><span class="line">  if ($Max_Age_value_set)</span><br><span class="line">  &#123;</span><br><span class="line">    $age_limit = min($age_limit, $Max_Age_value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明显最终客户端cache-control的优先级要大一些</p>
<h3 id="1-5-响应过期验证"><a href="#1-5-响应过期验证" class="headerlink" title="1.5 响应过期验证"></a>1.5 响应过期验证</h3><p>在缓存文档过期前，缓存任意使用这些响应，而不需和源服务器相关联，但是一旦响应过期缓存的响应就必须与源服务器进行一次验证，验证这些响应是否在之后被修改过。如果修改过就必须返回一份新的响应。  </p>
<p>在验证中可以提供以下请求头进行验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If-Modified-Since: &#x27;Last-Modified 的值&#x27;</span><br><span class="line">If-None-Match: &#x27;ETag&#x27;</span><br></pre></td></tr></table></figure>
<p>If-Modified-Since包含的是文件上次修改的时间，如果源服务器上次修改的实际小于或者等于这个值时，就返回304并更新缓存新鲜度.<br>If-Node-Match包含的是响应中的Etag值，这个值是通过哈希计算信息产生的独一无二标记值，如果源服务器的Etag和这个值相同则返回304并更新缓存新鲜度.<br>如果验证没通过则返回一个全新的响应。</p>
<h2 id="2-如何利用缓存"><a href="#2-如何利用缓存" class="headerlink" title="2 如何利用缓存"></a>2 如何利用缓存</h2><p>更多地利用缓存资源，可以提高网站的性能和相应速度。为了优化缓存，过期时间设置得尽量长是一种很好的策略。对于定期或者频繁更新的资源，这么做是比较稳妥的，但是对于那些长期不更新的资源会有点问题。这些固定的资源在一定时间内受益于这种长期保持的缓存策略，但一旦要更新就会很困难。特指网页上引入的一些js&#x2F;css文件，当它们变动时需要尽快更新线上资源。  </p>
<p>web开发者发明了一种 Steve Sounders 称作加速（译者注：revving）的技术[1] 。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js&#x2F;css）变动了，只用在高频变动的资源文件（html）里做入口的改动。  </p>
<p>这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。<br><img src="/2017/10/25/%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/employCache.png" alt="employCache"></p>
<p>  参考：</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7234#section-5.2">RFC7234</a></li>
<li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.8">RFC2616</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">HTTP 缓存 |MDN</a></li>
<li><a href="https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching">HTTP 缓存 | google</a></li>
<li><a href="https://book.douban.com/subject/10746113/">HTTP权威指南</a></li>
</ul>
]]></content>
      <categories>
        <category>http</category>
      </categories>
  </entry>
  <entry>
    <title>记一次502错误</title>
    <url>/2020/05/11/%E8%AE%B0%E4%B8%80%E6%AC%A1502%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>生产环境的一个nodejs接口突然报错了，这个接口（http:xxxx&#x2F;api&#x2F;nodeservice&#x2F;screenshot）是一个返回当前页面截图的接口，报错表象为这个接口请求1-2分钟左右后报502 Bad Gateway错误。并且其他环境无法复现。</p>
<span id="more"></span>

<h2 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h2><ul>
<li><p>(1) 直接去生产环境查看nodejs日志发现这个截图除了时间慢了点还是会正常产生截图，并没有错误日志。</p>
</li>
<li><p>(2) 转变排查方向直接到代理nodejs接口的nginx，这个nginx和nodejs都以<code>docker container</code>的形式部署在同一台服务器上，并且nginx的日志都重定向到容器的标准输出上,在宿主机上使用下面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># $(docker ps | awk &#x27;/nginx/&#123;print $1&#125;&#x27;) 这行命令开启一个shell子进程返回出nginx的container ID</span><br><span class="line">docker logs -f  $(docker ps | awk &#x27;/nginx/&#123;print $1&#125;&#x27;) | grep screenshot</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/11/%E8%AE%B0%E4%B8%80%E6%AC%A1502%E9%94%99%E8%AF%AF/nginx_error_log.png" alt="nginx log"><br>图中有用错误信息为<code>upstream prematurely closed connection while reading response header from upstream</code>字面意思为<code>当从上游读取响应标头时，上游过早关闭连接</code>，检查了nginx的各种配置都没问题。那是不是就如日志提示一样是上游的nodejs出了问题。</p>
</li>
<li><p>(3) 转到nodejs容器来抓包分析，在linux上一般使用<code>tcpdump</code>进行抓包但是nodejs容器里没有安装<code>tcpdump</code>，并且<code>tcpdump</code>不能直接在宿主机上直接抓取容器内的包，因为docker的network使用了<a href="https://lwn.net/Articles/531114/">namespace的隔离</a>，两个环境的网络进行了隔离，还好有个nsenter工具可以根据容器的PID进入到容器network namespace</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># $(docker ps | awk &#x27;/nodeservice/&#123;print $1&#125;&#x27;) 和上面一样开启一个shell子进程获取nodeservice（nodejs容器名字）的容器ID </span><br><span class="line"># $(docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; $containerID) 开启一个子进程获取容器的PID </span><br><span class="line">nodePID=$(docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; $(docker ps | awk &#x27;/nodeservice/&#123;print $1&#125;&#x27;))</span><br><span class="line">nsenter -t $nodePID -n</span><br><span class="line">ifconifg</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/11/%E8%AE%B0%E4%B8%80%E6%AC%A1502%E9%94%99%E8%AF%AF/container.png" alt="container"><br>箭头中就是这个nodejs容器的ip（10.0.0.69）了，接下来直接使用tcpdump来抓包了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 网卡为eth0 协议指定为tcp 这里的端口8080，需要注意是容器内部监听端口并不是容器对外暴露端口</span><br><span class="line">tcpdump -i eth0 tcp port 8080</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/11/%E8%AE%B0%E4%B8%80%E6%AC%A1502%E9%94%99%E8%AF%AF/tcpdump.png" alt="tcpdump"><br>这下可以从截图中明显看出是容器的ip（10.0.0.69）主动向nginx发起FIN断掉TCP连接。问题一定出在了nodejs了</p>
</li>
<li><p>(4)接下来看nodejs服务这里主要使用的一个叫http的模块，<a href="https://nodejs.org/docs/latest-v10.x/api/http.html#http_server_timeout">这个模块在低node版本时超过2分钟会主动reset掉请求</a>如在10.x.x版本时默认2两分钟自动挂掉请求，当前最新的13.10.1不会，这里和我们现象很接近。验证下我们nodejs的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it $(docker ps | awk &#x27;/nodeservice/&#123;print $1&#125;&#x27;) node -v</span><br><span class="line">v10.15.1</span><br></pre></td></tr></table></figure>
<p>果然接下来就是修改了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 代码中添加下面一行，时间设置为0代表无限</span><br><span class="line">service.setimeout(0);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为什么nodejs日志没有记录这个 reset TCP 的操作，因为nodejs主要记录了error事件，而这个是一个timeout事件。</p>
</li>
</ul>
<p>参考文档：</p>
<ul>
<li><a href="https://lwn.net/Articles/531114/">Namespaces in operation</a></li>
<li><a href="https://nodejs.org/docs/latest-v10.x/api/http.html#http_server_timeout">server.timeout</a></li>
</ul>
]]></content>
      <tags>
        <tag>nodejs docker tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>词法环境：ES</title>
    <url>/2018/08/13/%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83ES/</url>
    <content><![CDATA[<h1 id="详解ECMA-262-5-3-2章-词法环境：ECMAScript的实现"><a href="#详解ECMA-262-5-3-2章-词法环境：ECMAScript的实现" class="headerlink" title="详解ECMA-262-5 3.2章  词法环境：ECMAScript的实现"></a>详解ECMA-262-5 3.2章  词法环境：ECMAScript的实现</h1><h2 id="导言-Intruduction"><a href="#导言-Intruduction" class="headerlink" title="导言(Intruduction)"></a>导言(Intruduction)</h2><p>在这一章中我们将继续词法环境的考察.在先前的<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/#environment-frames-model">3.1章</a>我们澄清了关于这一话题的通用理论.特别是我们已经学习了环境与静态作用域以及闭包间的紧密关系.  </p>
<p>我们已经知道ECMAScript使用了环境帧链的模型,在这个章节中我们将着手于词法环境在ECMAScript中的具体实现.特别是我们将讨论ES中使用的和通用理论中相对应结构和术语.  </p>
<p>我们将从定义开始，尽管我们已经在通用理论中给出了词法环境的定义，但是这里我们将给出和ECMA262-5相关的定义.  </p>
<span id="more"></span>
<h2 id="定义-Definitions"><a href="#定义-Definitions" class="headerlink" title="定义(Definitions)"></a>定义(Definitions)</h2><p>正如我们在通用理论中说的，环境是用于管理在逻辑上代码嵌套的数据(变量，函数，等).同样的ECMAScript也是相同的作用.  </p>
<ul>
<li>一个词法环境定义了在词法嵌套结构的代码情况中，标识符与变量值以及函数的关联.</li>
</ul>
<p>在ES中的词法环境包含两部分：一是环境记录以及一个对外部环境的引用.I.e.定义中环境和先前模型中讨论的单帧相对应.因此:  </p>
<ul>
<li>一个环境记录表示标识符与创建时词法作用域相的绑定</li>
</ul>
<p>这就是一个环境记录，它保存着当前上下文显示的变量.  </p>
<p>看下面例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line"> </span><br><span class="line">function foo() &#123;</span><br><span class="line">  var y = 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道这里有连个抽象的环境，它们分别对应着全局上下文和foo函数上下文:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// environment of the global context</span><br><span class="line"> </span><br><span class="line">globalEnvironment = &#123;</span><br><span class="line"> </span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line"> </span><br><span class="line">    // built-ins:</span><br><span class="line">    Object: function,</span><br><span class="line">    Array: function,</span><br><span class="line">    // etc ...</span><br><span class="line"> </span><br><span class="line">    // our bindings:</span><br><span class="line">    x: 10</span><br><span class="line"> </span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  outer: null // no parent environment</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// environment of the &quot;foo&quot; function</span><br><span class="line"> </span><br><span class="line">fooEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">    y: 20</span><br><span class="line">  &#125;,</span><br><span class="line">  outer: globalEnvironment</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个outer引用通常用于连接当前环境的父级环境,当然父级函数也有自己的oute连接.并且全局环境的outer指向null.  </p>
<p>全局环境是这个作用域链的顶端.这与ES原型继承很像:如果一个属性没在当前对象找到,那么它就搜寻其原型,接着原型的原型以此类推.直到找到为止,或者找到原型的顶部.环境和它一样：上下文中出现的变量(或标识符)像属性一样,outer连接代表着原型.  </p>
<p>如先前所说的一个词法环境可能包含多个内部词法环境.e.g,如果一个函数包含两个嵌套函数那么每个嵌套函数的outer引用指向相同的外部环境.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"> </span><br><span class="line">  var x = 10;</span><br><span class="line"> </span><br><span class="line">  function bar() &#123;</span><br><span class="line">    var y = 20;</span><br><span class="line">    console.log(x + y); // 30</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  function baz() &#123;</span><br><span class="line">    var z = 30;</span><br><span class="line">    console.log(x + y); // 40</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//Environments</span><br><span class="line"> </span><br><span class="line">// &quot;foo&quot; environmnet</span><br><span class="line"> </span><br><span class="line">fooEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;x: 10&#125;,</span><br><span class="line">  outer: globalEnvironment</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// both &quot;bar&quot; and &quot;baz&quot; have the same outer</span><br><span class="line">// environment -- the environment of &quot;foo&quot;</span><br><span class="line"> </span><br><span class="line">barEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;y: 20&#125;,</span><br><span class="line">  outer: fooEnvironment</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">bazEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;z: 30&#125;,</span><br><span class="line">  outer: fooEnvironment</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ECMAScript 定义了两种类型的环境记,它们主要是为是其实现目的.但是在某些细节上我们认为它们完全相同. </p>
<h2 id="环境记录类型-Environment-record-types"><a href="#环境记录类型-Environment-record-types" class="headerlink" title="环境记录类型(Environment record types)"></a>环境记录类型(Environment record types)</h2><p>在ES5文档中指明了两种类型的环境记录：声明环境记录和对象环境记录  </p>
<h3 id="声明环境记录-Declarative-environment-record"><a href="#声明环境记录-Declarative-environment-record" class="headerlink" title="声明环境记录(Declarative environment record)"></a>声明环境记录(Declarative environment record)</h3><p>声明环境记录通常用于出现在函数作用域的变量,函数,形参等等.(这种情况下和es3中活动变量很像)和catch语句.  </p>
<p>如下例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// all: &quot;a&quot;, &quot;b&quot; and &quot;c&quot;</span><br><span class="line">// bindings are bindings of</span><br><span class="line">// a declarative record</span><br><span class="line"> </span><br><span class="line">function foo(a) &#123;</span><br><span class="line">  var b = 10;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在catch从句中绑定是是期待参数:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; catch (e) &#123; // &quot;e&quot; is a binding of a declarative record</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下声明记录默认存储在低阶工具中(如虚拟机的寄存器,因此能提供快速访问),这是和原来ES3中的活动对象(activeaction object)主要的不同.  </p>
<p>规范没有要求(甚至间接不建议)声明记录的实现以一种低效率的简单对象.这样的结果导致声明环境不会直接默认暴露给用户级别,这也意味着我们不能像记录的属性一样直接访问这些绑定，同样的甚至在ES3中也不能访问(除非在Rhino实现的利用__parent__访问).  </p>
<p>隐形的,声明记录允许其使用<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-35.html#%_sec_5.5.6">词法处理</a>技术,这就意味着可以不通过任何作用域链直接获取需要的变量–不管作用域嵌套多深(如果存储是固定的或者不变的,所有的变量处理都可以在编译之前就可知道).但是ES5规范并没直接提到这个事实.  </p>
<p>再说一次,关于使用声明环境记录替代老的活动对象概念一切都是为了实现上的高效.  </p>
<p>因此,如Brendan Eich<a href="https://mail.mozilla.org/pipermail/es-discuss/2010-April/010915.html">提到的</a>(最后一段)–在ES3中活动对象的实现简直就是一个’a bug’  </p>
<p>理论上,环境的声明记录可以通过这种方式实现(原型的type不是规范里的,这里只是我用作说明)   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">environment = &#123;</span><br><span class="line">  // storage</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">    type: &quot;declarative&quot;,</span><br><span class="line">    // storage</span><br><span class="line">  &#125;,</span><br><span class="line">  // reference to the parent environment</span><br><span class="line">  outer: &lt;...&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Eval和内部函数也许会破坏优化-Eval-and-inner-functions-may-break-optimizations"><a href="#Eval和内部函数也许会破坏优化-Eval-and-inner-functions-may-break-optimizations" class="headerlink" title="Eval和内部函数也许会破坏优化(Eval and inner functions may break optimizations)"></a>Eval和内部函数也许会破坏优化(Eval and inner functions may break optimizations)</h4><p>注意,eval函数可以破坏环境记录的高效，这是因为使用eval的话根本不知道哪些应该绑定.  </p>
<p>比如说V8实现的引擎(我猜其他的也一样)会优化函数如不会创建arguments对象(如果它没在函数体内出现),也不会保存没用的父级变量.这样的函数会更加轻量,它自会保存使用词法变量.I.e如果父级变量没有使用–函数甚至不会有闭包.(截屏自chrome dev-tools)：<br><img src="/2018/08/13/%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83ES/withoutEval.png" alt="withoutEval"> </p>
<p>然后相同的函数,但是有一个空的eval调用:</p>
<p><img src="/2018/08/13/%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83ES/withEval.png" alt="withEval">  </p>
<p>因为使用了eval就不能提前知道哪些数据将会被使用,我们将看到所有的”重量东西”, argumnets对象,和闭包属性，ie父级环境.  </p>
<p>进一步，看一看后一种情况的outerFn,它同样创建了arguments对象因为拥有内部函数因此很难分析出内部函数是否使用argumnets.  </p>
<p>然而,这只是一种实现，它让我们看到了有哪些优化可以提供，也可以怎么取消这些优化.<br>让我们看看第二种环境记录类型–对象环境记录.  </p>
<h3 id="对象环境记录-Object-environment-record"><a href="#对象环境记录-Object-environment-record" class="headerlink" title="对象环境记录(Object environment record)"></a>对象环境记录(Object environment record)</h3><p>相反的,对象环境记录被用来定义在全局上下文下的变量，函数以及内部使用with语句.这些东西都以低效的方式存储在一个简单对象来实现.如上面提到的,这种情况的绑定都是以对象属性的形式.  </p>
<ul>
<li>这种存储着绑定的上下文被称作绑定对象</li>
</ul>
<p>在全局上下文的情况下,变量和全局对象相关联,正因如此我们才可以像全局对象属性一样引用它们:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">console.log(a); // 10</span><br><span class="line"> </span><br><span class="line">// &quot;this&quot; in the global context</span><br><span class="line">// is the global object itself</span><br><span class="line">console.log(this.a); // 10</span><br><span class="line"> </span><br><span class="line">// &quot;window&quot; is the reference to the</span><br><span class="line">// global object in the browser environment</span><br><span class="line">console.log(window.a); // 10</span><br></pre></td></tr></table></figure>

<p>在使用with语句的情况下,变量和with–对象属性相关联:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with (&#123;a: 10&#125;) &#123;</span><br><span class="line">  console.log(a); // 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次执行with语句时一个新的词法环境就被创建，这词法环境的环境记录是对象环境记录,而outer环境指向当前运行的环境.然后将当前运行环境替换为with创建的新环境.当with执行完毕当前运行环境又恢复为原来状态.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = 20;</span><br><span class="line"> </span><br><span class="line">with (&#123;a: 30&#125;) &#123;</span><br><span class="line">  console.log(a + b); // 50</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(a + b); // 30, restored</span><br></pre></td></tr></table></figure>

<p>伪代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// initial state</span><br><span class="line">context.lexicalEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;a: 10, b: 20&#125;,</span><br><span class="line">  outer: null</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// &quot;with&quot; executed</span><br><span class="line">previousEnvironment = context.lexicalEnvironment;</span><br><span class="line"> </span><br><span class="line">withEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;a: 30&#125;,</span><br><span class="line">  outer: context.lexicalEnvironment</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// replace current environment</span><br><span class="line">context.lexicalEnvironment = withEnvironment;</span><br><span class="line"> </span><br><span class="line">// &quot;with&quot; completed, restore the environment back</span><br><span class="line">context.lexicalEnvironment = previousEnvironment;</span><br></pre></td></tr></table></figure>

<p>效果上来看和catch从句一样,同样的将当前运行环境替换为新创建的那个环境，这不过这个环境的环境记录为声明环境记录.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var e = 10;</span><br><span class="line"> </span><br><span class="line">try &#123;</span><br><span class="line">  throw 20;</span><br><span class="line">&#125; catch (e) &#123; // replace the environment</span><br><span class="line">  console.log(e); // 20</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// and now it&#x27;s restored back</span><br><span class="line">console.log(e); // 10</span><br></pre></td></tr></table></figure>

<p>下面我将看看这些由with语句和catch从句创建的暂时环境使用函数表达式时的效果.   </p>
<p>因为对象环境记录的低效，在ES5严格模式下with语句被移除掉了.  </p>
<p>更多原因是，with语句在许多场合造成混淆(因为变量和函数声明的提升)并且其中一些真很让人困惑,这也是为什么with在ES5严格模式下去除.  </p>
<p>将全局对象从作用域链的底部移除是下一代ES的计划,全局环境记录也将从对象转为声明,使用modules这样的体系,全局绑定如parseInt,Math等等都将只是引入到全局上下文中,但是技术上来说它们将不再是全局对象的属性了,因为已经没有全局对象了.   </p>
<p>理论上来说,一个拥有对象环境记录的环境,可以以这种方式呈现:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">environment = &#123;</span><br><span class="line">  // storage</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">    type: &quot;object&quot;,</span><br><span class="line">    bindingObject: &#123;</span><br><span class="line">      // storage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // reference to the parent environment</span><br><span class="line">  outer: &lt;...&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>规范有说明到,bingdingObject是真正对象(e.g. 全局对象)的某种映射,但不是所有在原始对象的属性都被当做绑定对象的属性,比如说,属性名不能为标识符的变量就没有包含在绑定对象上，这是相当符合逻辑的这是因为它们不能被当做变量引用:   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// global properties</span><br><span class="line">this[&#x27;a&#x27;] = 10; // included in the binding object</span><br><span class="line">this[&#x27;hello world&#x27;] = 20; // isn&#x27;t included</span><br><span class="line"> </span><br><span class="line">console.log(a); // 10, can refer</span><br><span class="line">console.log(hello world); // cannot, syntax error</span><br></pre></td></tr></table></figure>

<p>然而,如何将原始对象同步的绑定规范并没有具体指出.  </p>
<h2 id="执行上下文结构-Structure-of-execution-context"><a href="#执行上下文结构-Structure-of-execution-context" class="headerlink" title="执行上下文结构(Structure of execution context)"></a>执行上下文结构(Structure of execution context)</h2><p>这里我们将简单提及ES5中执行上下文的结构.它和ES3中的有一点不同,并且有如下属性:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutionContextES5 = &#123;</span><br><span class="line">  ThisBinding: &lt;this value&gt;,</span><br><span class="line">  VariableEnvironment: &#123; ... &#125;,</span><br><span class="line">  LexicalEnvironment: &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到上下文中有变量环境和词法环境,这对阅读规范的读者常常造成疑惑，我们将简单的澄清它们，但是这里只是简单注意这是主要是来区分<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#function-declaration">函数声明</a>和<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#function-expression">函数表达式</a>的[[Scope]]值.  </p>
<p>让我们来看一看执行环境的属性.  </p>
<h3 id="this绑定-This-binding"><a href="#this绑定-This-binding" class="headerlink" title="this绑定(This binding)"></a>this绑定(This binding)</h3><p>This的值现在称为this绑定,然而除了术语改变了其他的从语义上(除了在严格模式上，this可能为undefined)没有什么改变,在全局模式下, this任然绑定的是全局对象本身：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function (global) &#123;</span><br><span class="line">  global.a = 10;</span><br><span class="line">&#125;)(this);</span><br><span class="line"> </span><br><span class="line">console.log(a); // 10</span><br></pre></td></tr></table></figure>

<p>并且在函数上下文中this的值仍由函数如何调用所决定.如果他是通过一个<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/#-reference-type">引用</a>调用,那么this的基本值由引用决定,其他情况–要么全局对象或者在严格模式下的undefined.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// --- Reference cases ---</span><br><span class="line"> </span><br><span class="line">// with a reference</span><br><span class="line">foo.bar(); // &quot;this&quot; is &quot;foo&quot; - the base</span><br><span class="line"> </span><br><span class="line">var bar = foo.bar;</span><br><span class="line"> </span><br><span class="line">// with the reference</span><br><span class="line">bar(); // &quot;this&quot; is the global, implicit base</span><br><span class="line">this.bar(); // the same, explicit base, the global</span><br><span class="line"> </span><br><span class="line">// with also but another reference</span><br><span class="line">bar.prototype.constructor(); // &quot;this&quot; is &quot;bar.prototype&quot;</span><br><span class="line"> </span><br><span class="line">// --- non-Reference cases ---</span><br><span class="line"> </span><br><span class="line">(foo.bar = foo.bar)(); // &quot;this&quot; is &quot;global&quot; or &quot;undefined&quot;</span><br><span class="line">(foo.bar || foo.bar)(); // &quot;this&quot; is &quot;global&quot; or &quot;undefined&quot;</span><br><span class="line">(function () &#123; this; &#125;)(); // &quot;this&quot; is &quot;global&quot; or &quot;undefined&quot;</span><br></pre></td></tr></table></figure>

<p>再次注意,在严格模式,不能通过如下模式获得全局对象:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  var global = (function () &#123; return this; &#125;)();</span><br><span class="line">  console.log(global); // undefined!</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>如和在这种情况下(包括间接调用和eval)处理这种技术将在<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#codethiscode-value-restrictions">严格模式</a>章节介绍.  </p>
<p>让我们回到环境来看规范中上下文中的变量环境和词法环境,这两部分常常造成误解并且在一些解释中描述常常不正确.  </p>
<h3 id="变量环境-Variable-environment"><a href="#变量环境-Variable-environment" class="headerlink" title="变量环境(Variable environment)"></a>变量环境(Variable environment)</h3><p>变量环境部分存储着初始化变量和函数的上下文.准确的说它的环境存储包含着进入上下文是填充的数据.这和ES3中的<a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#variable-object">变量对象</a>很像.  </p>
<p>当进入一个函数的上下文时,回想一下这时一个特别的argumnets对象用于表示传入的形参值被创建.在严格模式下arguments对象经历了<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#codeevalcode-and-codeargumentscode-restrictions">很多改变</a>,其中arguments将不能通过其属性改变其真正的参数值.还有callee(调用函数本身的引用)将在严格模式下废除.  </p>
<p>在这个代码里:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b = 20;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(10);</span><br></pre></td></tr></table></figure>

<p>理论上我们有如下VariableEnvironment构成foo函数的上下文:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fooContext.VariableEnvironment = &#123;</span><br><span class="line">  environmentRecord: &#123;</span><br><span class="line">    arguments: &#123;0: 10, length: 1, callee: foo&#125;,</span><br><span class="line">    a: 10,</span><br><span class="line">    b: 20</span><br><span class="line">  &#125;,</span><br><span class="line">  outer: globalEnvironment</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那LexicalEnvironment是如何组成的?好笑的是词法环境初始化只是VariableEnvironment的复制.  </p>
<h3 id="词法环境-lexical-environment"><a href="#词法环境-lexical-environment" class="headerlink" title="词法环境(lexical environment)"></a>词法环境(lexical environment)</h3><p>词法环境和变量环境本质上都是的词法环境(不管它们怎么命名)i.e.都是在内部函数创建时静态(词法)捕获外部绑定.  </p>
<p>正如我们先前提到的初始化LexicalEnvironment只是对VariableEnvironment的蓝本复制,看看下面例子:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fooContext.LexicalEnvironment = copy(fooContext.VariableEnvironment);</span><br></pre></td></tr></table></figure>

<p>然而接下来会发生什么,在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#code-execution">代码执行阶段</a>,提前在原有的词法环境通过with语句和catch从句来扩展(尽管如我们所说,在ES5中提前替换上下文环境，但是在ES3中没有扩展).    </p>
<p>with语句和catch从句如上面所示的在执行时替换上下文环境,并且这种情况和函数表达式有关.  </p>
<p>从<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-1-lexical-environments-common-theory/#rules-of-function-creation-and-application">函数创建的规则</a>的讨论中,我们知道闭包将在函数创建时将词法环境保存.  </p>
<p>如果一个函数表达式在一个with语句(或者cacth从句)创建,那么它应该保存(替换)当前词法环境.  </p>
<p>我们是直接将VariableEnvironment替换(而不是它的副本LexicalEnvironment),然后再其with语句执行结束后恢复过来,然而这就意味着FE将不能引用创建时的绑定,但是FE需要with-绑定.  </p>
<p>其实我们不会替换VariableEnvironment本身,因为FD也可以在with语句内调用,FD与FE相反的是可以使用初始化的状态,而不是从with-对象(我们将看下面的例子)</p>
<ul>
<li>这就是为什么,当函数声明(FD)时保存VariableEnvironment部分作为其[[Scope]]属性,而函数表达式(ES)保存其LexicalEnvironment部分.这是唯一可以区分它们两的地方.</li>
</ul>
<p>这个事实好笑的是在下一代ES或者ES5严格模式with语句将彻底消失，这样ES规范将在这个方面少了很多误解.  </p>
<p>让我们在看一下我们的分析：FE保存LexicalEnvironment,因为它需要在with执行时动态绑定,但是FD将保存VariableEnvironment,因为根据规范FD不能在一个块级内创建，并且它会<a href="http://dmitrysoshnikov.com/notes/note-4-two-words-about-hoisting/">提升</a>到顶部.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line"> </span><br><span class="line">// FD</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">with (&#123;a: 20&#125;) &#123;</span><br><span class="line"> </span><br><span class="line">  // FE</span><br><span class="line">  var bar = function () &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  foo(); // 10!, from VariableEnvrionment</span><br><span class="line">  bar(); // 20,  from LexicalEnvrionment</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); // 10</span><br><span class="line">bar(); // still 20</span><br></pre></td></tr></table></figure>

<p>理论上可以如下面: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// &quot;foo&quot; is created</span><br><span class="line">foo.[[Scope]] = globalContext.[[VariableEnvironment]];</span><br><span class="line"> </span><br><span class="line">// &quot;with&quot; is executed</span><br><span class="line">previousEnvironment = globalContext.[[LexicalEnvironment]];</span><br><span class="line"> </span><br><span class="line">globalContext.[[LexicalEnvironment]] = &#123;</span><br><span class="line">  environmentRecord: &#123;a: 20&#125;,</span><br><span class="line">  outer: previousEnvironment</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// &quot;bar&quot; is created</span><br><span class="line">bar.[[Scope]] = globalContext.[[LexicalEnvironment]];</span><br><span class="line"> </span><br><span class="line">// &quot;with&quot; is completed, restore the environment</span><br><span class="line">globalContext.[[LexicalEnvironment]] = previousEnvironment;</span><br></pre></td></tr></table></figure>

<p>为了从实例中更明显的看清区别,我们可以采用非标准模式在块级内创建FD,根据我们<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#implementations-extension-function-statement">所记得</a>规范将会报异常,但是如今的实现环境没有一个会报错.Firefox的函数语句有自己的非标准方式执行很多年,并且在其他实现环境如v8引擎也遵循下面行为:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line"> </span><br><span class="line">with (&#123;a: 20&#125;) &#123;</span><br><span class="line"> </span><br><span class="line">  // FD</span><br><span class="line">  function foo() &#123; // do not test in Firefox!</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // FE</span><br><span class="line">  var bar = function () &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  foo(); // 10!, from VariableEnvrionment</span><br><span class="line">  bar(); // 20,  from LexicalEnvrionment</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); // 10</span><br><span class="line">bar(); // still 20</span><br></pre></td></tr></table></figure>

<p>上面的代码这样运行的原因是因为FD(被提升到顶部)保存VariableEnvironment当做其[[Scope]],而FE保存其LexicalEnvironment(当with或catch执行时将被替换).  </p>
<p>注意：因为ES6标准的块级函数声明，这个例子洪foo函数就保存词法环境</p>
<h2 id="标识符求值-Identifier-resolution"><a href="#标识符求值-Identifier-resolution" class="headerlink" title="标识符求值(Identifier resolution)"></a>标识符求值(Identifier resolution)</h2><ul>
<li>标识符的求值是判断哪个标识符出现在那个词法环境绑定上</li>
</ul>
<p>换句话说,它和变量的<a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#scope-chain">作用域链查询</a>很像.如上说的也和原型链查询很像,只是将prototype的连接换成了连接着环境的outer连接.  </p>
<p>看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line"> </span><br><span class="line">(function foo() &#123;</span><br><span class="line"> </span><br><span class="line">  var b = 20;</span><br><span class="line"> </span><br><span class="line">  (function bar() &#123;</span><br><span class="line"> </span><br><span class="line">    var c = 30;</span><br><span class="line">    console.log(a + b + c); // 60</span><br><span class="line">     </span><br><span class="line">  &#125;)();</span><br><span class="line"> </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>标识符求值过程如a绑定一样的迭代求值. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function resolveIdentifier(lexicalEnvironment, identifier) &#123;</span><br><span class="line">  </span><br><span class="line">  // if it&#x27;s the final link, and we didn&#x27;t find</span><br><span class="line">  // anything, we have a case of a reference error</span><br><span class="line">  if (lexicalEnvironment == null) &#123;</span><br><span class="line">    throw ReferenceError(identifier + &quot; is not defined&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // return the binding (reference) if it exists;</span><br><span class="line">  // later we&#x27;ll be able to get the value from the reference</span><br><span class="line">  if (lexicalEnvironment.hasBinding(identifier)) &#123;</span><br><span class="line">    return new Reference(lexicalEnvironment, identifier);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // else try to find in the parent scope,</span><br><span class="line">  // recursively analyzing the outer environment</span><br><span class="line">  return resolveIdentifier(lexicalEnvironment.outer, identifier);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">resolveIdentifier(bar.[[LexicalEnvironment]], &quot;a&quot;) -&gt;</span><br><span class="line"> </span><br><span class="line">-- bar.[[LexicalEnvironment]] - not found,</span><br><span class="line">-- bar.[[LexicalEnvironment]].outer (i.e. foo.[[LexicalEnvironment]]) -&gt; not found</span><br><span class="line">-- bar.[[LexicalEnvironment]].outer.outer -&gt; found reference, value 10</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这一章中我们澄清了ECMAScript中词法环境的概念.我们也讲述了为什么要将原来的 变量&#x2F;激活 对象以及作用域链换成词法环境链–它们大多数的改变是为相关的高效实现.  </p>
<p>我们也看到了词法环境与闭包的相关性(再次注意,ED合FE在ECMScript都会参数闭包),我们再次回忆了this绑定是如何在不同的执行上下文取值.  </p>
<p>此外我们在提到了下一代ES关于环境的计划,如去除全局对象.</p>
]]></content>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包中的内存泄漏</title>
    <url>/2017/10/30/%E9%97%AD%E5%8C%85%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<p>闭包的定义：A closure is the combination of a function and the lexical environment within which that function was declared.(函数声明时函数内部变量有访问当前作用域链上变量的能力，哪怕变量被函数return出去以后。)</p>
<span id="more"></span>


<p>闭包具体场景：函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数被全局环境下的变量引用，就形成了闭包。</p>
<p>浏览器垃圾回收机制要点：  </p>
<ul>
<li>从根对象开始寻找，只要能顺着引用找到的，都不能被回收。顺着引用找不到的对象被视为垃圾，在下一个垃圾回收节点被回收。</li>
<li>变量显示引用次数如果标记为0也会被回收。</li>
</ul>
<p>内存泄漏定义：通俗的讲也就是当某个对象我们不再需要，但是仍在长时间在内存中。  </p>
<p>内存泄漏案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var t = null;</span><br><span class="line">  var replaceThing = function() &#123;</span><br><span class="line">      var o = t</span><br><span class="line">      var unused = function() &#123;</span><br><span class="line">          if (o)</span><br><span class="line">              console.log(&quot;hi&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      t = &#123;</span><br><span class="line">              longStr: new Array(1000000).join(&#x27;*&#x27;),</span><br><span class="line">              someMethod: function() &#123;</span><br><span class="line">                console.log(&quot;this is a test&quot;)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setInterval(replaceThing, 1)</span><br></pre></td></tr></table></figure>
<p>在replaceThing执行返回变量t以后，全局变量t有对replaceThing函数内变量访问的权利，这也是说内存保存着对o访问权利（注意此次o的引用次数因为在unsed有引用不为0），而o变量保存着上次执行的t，依次索引造成严重内存泄漏。下图是replaceThing执行三次后的情况：<br><img src="/2017/10/30/%E9%97%AD%E5%8C%85%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/threeTimesCircle.png" alt="内存泄漏"><br>这里在函数最后可以将o&#x3D;null解决内存泄漏，也可以将unsed去掉解决内存泄漏。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
</search>
